{"version":3,"file":"private.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/combobox/combobox.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/list-focus/list-focus.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/list-navigation/list-navigation.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/list-selection/list-selection.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/list-typeahead/list-typeahead.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/list/list.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/listbox/listbox.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/listbox/option.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/listbox/combobox-listbox.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/menu/menu.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/signal-like/signal-like.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/expansion/expansion.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/label/label.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/tabs/tabs.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/toolbar/toolbar.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/toolbar/toolbar-widget.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/accordion/accordion.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/tree/tree.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/tree/combobox-tree.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/deferred-content/deferred-content.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {KeyboardEventManager, PointerEventManager} from '../behaviors/event-manager';\nimport {computed, signal} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../behaviors/signal-like/signal-like';\nimport {ListItem} from '../behaviors/list/list';\n\n/** Represents the required inputs for a combobox. */\nexport interface ComboboxInputs<T extends ListItem<V>, V> {\n  /** The controls for the popup associated with the combobox. */\n  popupControls: SignalLike<ComboboxListboxControls<T, V> | ComboboxTreeControls<T, V> | undefined>;\n\n  /** The HTML input element that serves as the combobox input. */\n  inputEl: SignalLike<HTMLInputElement | undefined>;\n\n  /** The HTML element that serves as the combobox container. */\n  containerEl: SignalLike<HTMLElement | undefined>;\n\n  /** The filtering mode for the combobox. */\n  filterMode: SignalLike<'manual' | 'auto-select' | 'highlight'>;\n\n  /** The current value of the combobox. */\n  inputValue?: WritableSignalLike<string>;\n\n  /** The value of the first matching item in the popup. */\n  firstMatch: SignalLike<V | undefined>;\n\n  /** Whether the combobox is disabled. */\n  disabled: SignalLike<boolean>;\n\n  /** Whether the combobox is read-only. */\n  readonly: SignalLike<boolean>;\n\n  /** Whether the combobox is in a right-to-left context. */\n  textDirection: SignalLike<'rtl' | 'ltr'>;\n}\n\n/** An interface that allows combobox popups to expose the necessary controls for the combobox. */\nexport interface ComboboxListboxControls<T extends ListItem<V>, V> {\n  /** A unique identifier for the popup. */\n  id: () => string;\n\n  /** The ARIA role for the popup. */\n  role: SignalLike<'listbox' | 'tree' | 'grid'>;\n\n  // TODO(wagnermaciel): Add validation that ensures only readonly comboboxes can have multi-select popups.\n\n  /** Whether multiple items in the popup can be selected at once. */\n  multi: SignalLike<boolean>;\n\n  /** The ID of the active item in the popup. */\n  activeId: SignalLike<string | undefined>;\n\n  /** The list of items in the popup. */\n  items: SignalLike<T[]>;\n\n  /** Navigates to the given item in the popup. */\n  focus: (item: T, opts?: {focusElement?: boolean}) => void;\n\n  /** Navigates to the next item in the popup. */\n  next: () => void;\n\n  /** Navigates to the previous item in the popup. */\n  prev: () => void;\n\n  /** Navigates to the first item in the popup. */\n  first: () => void;\n\n  /** Navigates to the last item in the popup. */\n  last: () => void;\n\n  /** Selects the current item in the popup. */\n  select: (item?: T) => void;\n\n  /** Toggles the selection state of the given item in the popup. */\n  toggle: (item?: T) => void;\n\n  /** Clears the selection state of the popup. */\n  clearSelection: () => void;\n\n  /** Removes focus from any item in the popup. */\n  unfocus: () => void;\n\n  /** Returns the item corresponding to the given event. */\n  getItem: (e: PointerEvent) => T | undefined;\n\n  /** Returns the currently selected items in the popup. */\n  getSelectedItems: () => T[];\n\n  /** Sets the value of the combobox based on the selected item. */\n  setValue: (value: V | undefined) => void; // For re-setting the value if the popup was destroyed.\n}\n\nexport interface ComboboxTreeControls<T extends ListItem<V>, V>\n  extends ComboboxListboxControls<T, V> {\n  /** Whether the currently active item in the popup is collapsible. */\n  isItemCollapsible: () => boolean;\n\n  /** Expands the currently active item in the popup. */\n  expandItem: () => void;\n\n  /** Collapses the currently active item in the popup. */\n  collapseItem: () => void;\n\n  /** Checks if the currently active item in the popup is expandable. */\n  isItemExpandable: (item?: T) => boolean;\n\n  /** Expands all nodes in the tree. */\n  expandAll: () => void;\n\n  /** Collapses all nodes in the tree. */\n  collapseAll: () => void;\n\n  /** Toggles the expansion state of the currently active item in the popup. */\n  toggleExpansion: (item?: T) => void;\n\n  /** Whether the current active item is selectable. */\n  isItemSelectable: (item?: T) => boolean;\n}\n\n/** Controls the state of a combobox. */\nexport class ComboboxPattern<T extends ListItem<V>, V> {\n  /** Whether the combobox is expanded. */\n  expanded = signal(false);\n\n  /** The ID of the active item in the combobox. */\n  activeDescendant = computed(() => this.inputs.popupControls()?.activeId() ?? null);\n\n  /** The currently highlighted item in the combobox. */\n  highlightedItem = signal<T | undefined>(undefined);\n\n  /** Whether the most recent input event was a deletion. */\n  isDeleting = false;\n\n  /** Whether the combobox is focused. */\n  isFocused = signal(false);\n\n  /** The key used to navigate to the previous item in the list. */\n  expandKey = computed(() => (this.inputs.textDirection() === 'rtl' ? 'ArrowLeft' : 'ArrowRight'));\n\n  /** The key used to navigate to the next item in the list. */\n  collapseKey = computed(() =>\n    this.inputs.textDirection() === 'rtl' ? 'ArrowRight' : 'ArrowLeft',\n  );\n\n  /** The ID of the popup associated with the combobox. */\n  popupId = computed(() => this.inputs.popupControls()?.id() || null);\n\n  /** The autocomplete behavior of the combobox. */\n  autocomplete = computed(() => (this.inputs.filterMode() === 'highlight' ? 'both' : 'list'));\n\n  /** The ARIA role of the popup associated with the combobox. */\n  hasPopup = computed(() => this.inputs.popupControls()?.role() || null);\n\n  /** Whether the combobox is read-only. */\n  readonly = computed(() => this.inputs.readonly() || null);\n\n  /** The keydown event manager for the combobox. */\n  keydown = computed(() => {\n    if (!this.expanded()) {\n      const manager = new KeyboardEventManager()\n        .on('ArrowDown', () => this.open({first: true}))\n        .on('ArrowUp', () => this.open({last: true}))\n        .on('Escape', () => this.close({reset: !this.readonly()}));\n\n      if (this.readonly()) {\n        manager\n          .on('Enter', () => this.open({selected: true}))\n          .on(' ', () => this.open({selected: true}));\n      }\n\n      return manager;\n    }\n\n    const popupControls = this.inputs.popupControls();\n\n    if (!popupControls) {\n      return new KeyboardEventManager();\n    }\n\n    const manager = new KeyboardEventManager()\n      .on('ArrowDown', () => this.next())\n      .on('ArrowUp', () => this.prev())\n      .on('Home', () => this.first())\n      .on('End', () => this.last())\n      .on('Escape', () => this.close({reset: !this.readonly()}));\n\n    if (this.readonly()) {\n      manager.on(' ', () => this.select({commit: true, close: !popupControls.multi()}));\n    }\n\n    if (popupControls.role() === 'listbox') {\n      manager.on('Enter', () => this.select({commit: true, close: !popupControls.multi()}));\n    }\n\n    if (popupControls.role() === 'tree') {\n      const treeControls = popupControls as ComboboxTreeControls<T, V>;\n\n      if (treeControls.isItemSelectable()) {\n        manager.on('Enter', () => this.select({commit: true, close: true}));\n      } else if (treeControls.isItemExpandable()) {\n        manager.on('Enter', () => this.expandItem());\n      }\n\n      if (treeControls.isItemExpandable() || treeControls.isItemCollapsible()) {\n        manager.on(this.collapseKey(), () => this.collapseItem());\n      }\n\n      if (treeControls.isItemExpandable()) {\n        manager.on(this.expandKey(), () => this.expandItem());\n      }\n    }\n\n    return manager;\n  });\n\n  /** The pointerup event manager for the combobox. */\n  pointerup = computed(() =>\n    new PointerEventManager().on(e => {\n      const item = this.inputs.popupControls()?.getItem(e);\n\n      if (item) {\n        if (this.inputs.popupControls()?.role() === 'tree') {\n          const treeControls = this.inputs.popupControls() as ComboboxTreeControls<T, V>;\n\n          if (treeControls.isItemExpandable(item) && !treeControls.isItemSelectable(item)) {\n            treeControls.toggleExpansion(item);\n            this.inputs.inputEl()?.focus();\n            return;\n          }\n        }\n\n        this.select({item, commit: true, close: !this.inputs.popupControls()?.multi()});\n        this.inputs.inputEl()?.focus(); // Return focus to the input after selecting.\n      }\n\n      if (e.target === this.inputs.inputEl()) {\n        if (this.readonly()) {\n          this.expanded() ? this.close() : this.open({selected: true});\n        }\n      }\n    }),\n  );\n\n  constructor(readonly inputs: ComboboxInputs<T, V>) {}\n\n  /** Handles keydown events for the combobox. */\n  onKeydown(event: KeyboardEvent) {\n    if (!this.inputs.disabled()) {\n      this.keydown().handle(event);\n    }\n  }\n\n  /** Handles pointerup events for the combobox. */\n  onPointerup(event: PointerEvent) {\n    if (!this.inputs.disabled()) {\n      this.pointerup().handle(event);\n    }\n  }\n\n  /** Handles input events for the combobox. */\n  onInput(event: Event) {\n    if (this.inputs.disabled() || this.inputs.readonly()) {\n      return;\n    }\n\n    const inputEl = this.inputs.inputEl();\n\n    if (!inputEl) {\n      return;\n    }\n\n    this.open();\n    this.inputs.inputValue?.set(inputEl.value);\n    this.isDeleting = event instanceof InputEvent && !!event.inputType.match(/^delete/);\n\n    if (this.inputs.filterMode() === 'manual') {\n      const selectedItems = this.inputs.popupControls()?.getSelectedItems();\n      const searchTerm = selectedItems?.[0]?.searchTerm();\n\n      if (searchTerm && this.inputs.inputValue!() !== searchTerm) {\n        this.inputs.popupControls()?.clearSelection();\n      }\n    }\n\n    if (this.inputs.filterMode() === 'highlight' && !this.isDeleting) {\n      this.highlight();\n    }\n  }\n\n  /** Handles focus in events for the combobox. */\n  onFocusIn() {\n    this.isFocused.set(true);\n  }\n\n  /** Handles focus out events for the combobox. */\n  onFocusOut(event: FocusEvent) {\n    if (this.inputs.disabled()) {\n      return;\n    }\n\n    if (\n      !(event.relatedTarget instanceof HTMLElement) ||\n      !this.inputs.containerEl()?.contains(event.relatedTarget)\n    ) {\n      this.isFocused.set(false);\n\n      if (this.readonly()) {\n        this.close();\n        return;\n      }\n\n      if (this.inputs.filterMode() !== 'manual') {\n        this.commit();\n      } else {\n        const item = this.inputs\n          .popupControls()\n          ?.items()\n          .find(i => i.searchTerm() === this.inputs.inputEl()?.value);\n\n        if (item) {\n          this.select({item});\n        }\n      }\n\n      this.close();\n    }\n  }\n\n  /** The first matching item in the combobox. */\n  firstMatch = computed(() => {\n    // TODO(wagnermaciel): Consider whether we should not provide this default behavior for the\n    // listbox. Instead, we may want to allow users to have no match so that typing does not focus\n    // any option.\n    if (this.inputs.popupControls()?.role() === 'listbox') {\n      return this.inputs.popupControls()?.items()[0];\n    }\n\n    return this.inputs\n      .popupControls()\n      ?.items()\n      .find(i => i.value() === this.inputs.firstMatch());\n  });\n\n  /** Handles filtering logic for the combobox. */\n  onFilter() {\n    if (this.readonly()) {\n      return;\n    }\n\n    // TODO(wagnermaciel)\n    // When the user first interacts with the combobox, the popup will lazily render for the first\n    // time. This is a simple way to detect this and avoid auto-focus & selection logic, but this\n    // should probably be moved to the component layer instead.\n    const isInitialRender = !this.inputs.inputValue?.().length && !this.isDeleting;\n\n    if (isInitialRender) {\n      return;\n    }\n\n    // Avoid refocusing the input if a filter event occurs after focus has left the combobox.\n    if (!this.isFocused()) {\n      return;\n    }\n\n    if (this.inputs.popupControls()?.role() === 'tree') {\n      const treeControls = this.inputs.popupControls() as ComboboxTreeControls<T, V>;\n      this.inputs.inputValue?.().length ? treeControls.expandAll() : treeControls.collapseAll();\n    }\n\n    const item = this.firstMatch();\n\n    if (!item) {\n      this.inputs.popupControls()?.clearSelection();\n      this.inputs.popupControls()?.unfocus();\n      return;\n    }\n\n    this.inputs.popupControls()?.focus(item);\n\n    if (this.inputs.filterMode() !== 'manual') {\n      this.select({item});\n    }\n\n    if (this.inputs.filterMode() === 'highlight' && !this.isDeleting) {\n      this.highlight();\n    }\n  }\n\n  /** Highlights the currently selected item in the combobox. */\n  highlight() {\n    const inputEl = this.inputs.inputEl();\n    const selectedItems = this.inputs.popupControls()?.getSelectedItems();\n    const item = selectedItems?.[0];\n\n    if (!inputEl || !item) {\n      return;\n    }\n\n    const isHighlightable = item\n      .searchTerm()\n      .toLowerCase()\n      .startsWith(this.inputs.inputValue!().toLowerCase());\n\n    if (isHighlightable) {\n      inputEl.value =\n        this.inputs.inputValue!() + item.searchTerm().slice(this.inputs.inputValue!().length);\n      inputEl.setSelectionRange(this.inputs.inputValue!().length, item.searchTerm().length);\n      this.highlightedItem.set(item);\n    }\n  }\n\n  /** Closes the combobox. */\n  close(opts?: {reset: boolean}) {\n    if (!opts?.reset) {\n      this.expanded.set(false);\n      this.inputs.popupControls()?.unfocus();\n      return;\n    }\n\n    const popupControls = this.inputs.popupControls();\n\n    if (!this.expanded()) {\n      this.inputs.inputValue?.set('');\n      popupControls?.clearSelection();\n\n      const inputEl = this.inputs.inputEl();\n\n      if (inputEl) {\n        inputEl.value = '';\n      }\n    } else if (this.expanded()) {\n      this.close();\n\n      const selectedItem = popupControls?.getSelectedItems()?.[0];\n\n      if (selectedItem?.searchTerm() !== this.inputs.inputValue!()) {\n        popupControls?.clearSelection();\n      }\n    }\n\n    this.close();\n\n    if (!this.readonly()) {\n      this.inputs.popupControls()?.clearSelection();\n    }\n  }\n\n  /** Opens the combobox. */\n  open(nav?: {first?: boolean; last?: boolean; selected?: boolean}) {\n    this.expanded.set(true);\n    const inputEl = this.inputs.inputEl();\n\n    if (inputEl && this.inputs.filterMode() === 'highlight') {\n      const isHighlighting = inputEl.selectionStart !== inputEl.value.length;\n      this.inputs.inputValue?.set(inputEl.value.slice(0, inputEl.selectionStart || 0));\n      if (!isHighlighting) {\n        this.highlightedItem.set(undefined);\n      }\n    }\n\n    if (nav?.first) {\n      this.first();\n    }\n    if (nav?.last) {\n      this.last();\n    }\n    if (nav?.selected) {\n      const selectedItem = this.inputs\n        .popupControls()\n        ?.items()\n        .find(i => this.inputs.popupControls()?.getSelectedItems().includes(i));\n      selectedItem ? this.inputs.popupControls()?.focus(selectedItem) : this.first();\n    }\n  }\n\n  /** Navigates to the next focusable item in the combobox popup. */\n  next() {\n    this._navigate(() => this.inputs.popupControls()?.next());\n  }\n\n  /** Navigates to the previous focusable item in the combobox popup. */\n  prev() {\n    this._navigate(() => this.inputs.popupControls()?.prev());\n  }\n\n  /** Navigates to the first focusable item in the combobox popup. */\n  first() {\n    this._navigate(() => this.inputs.popupControls()?.first());\n  }\n\n  /** Navigates to the last focusable item in the combobox popup. */\n  last() {\n    this._navigate(() => this.inputs.popupControls()?.last());\n  }\n\n  /** Collapses the currently focused item in the combobox. */\n  collapseItem() {\n    const controls = this.inputs.popupControls() as ComboboxTreeControls<T, V>;\n    this._navigate(() => controls?.collapseItem());\n  }\n\n  /** Expands the currently focused item in the combobox. */\n  expandItem() {\n    const controls = this.inputs.popupControls() as ComboboxTreeControls<T, V>;\n    this._navigate(() => controls?.expandItem());\n  }\n\n  /** Selects an item in the combobox popup. */\n  select(opts: {item?: T; commit?: boolean; close?: boolean} = {}) {\n    const controls = this.inputs.popupControls();\n\n    if (opts.item) {\n      controls?.focus(opts.item, {focusElement: false});\n    }\n\n    controls?.multi() ? controls.toggle(opts.item) : controls?.select(opts.item);\n\n    if (opts.commit) {\n      this.commit();\n    }\n    if (opts.close) {\n      this.close();\n    }\n  }\n\n  /** Updates the value of the input based on the currently selected item. */\n  commit() {\n    const inputEl = this.inputs.inputEl();\n    const selectedItems = this.inputs.popupControls()?.getSelectedItems();\n\n    if (!inputEl) {\n      return;\n    }\n\n    inputEl.value = selectedItems?.map(i => i.searchTerm()).join(', ') || '';\n    this.inputs.inputValue?.set(inputEl.value);\n\n    if (this.inputs.filterMode() === 'highlight' && !this.readonly()) {\n      const length = inputEl.value.length;\n      inputEl.setSelectionRange(length, length);\n    }\n  }\n\n  /** Navigates and handles additional actions based on filter mode. */\n  private _navigate(operation: () => void) {\n    operation();\n\n    if (this.inputs.filterMode() !== 'manual') {\n      this.select();\n    }\n\n    if (this.inputs.filterMode() === 'highlight') {\n      // This is to handle when the user navigates back to the originally highlighted item.\n      // E.g. User types \"Al\", highlights \"Alice\", then navigates down and back up to \"Alice\".\n      const selectedItem = this.inputs.popupControls()?.getSelectedItems()[0];\n\n      if (!selectedItem) {\n        return;\n      }\n\n      if (selectedItem === this.highlightedItem()) {\n        this.highlight();\n      } else {\n        const inputEl = this.inputs.inputEl()!;\n        inputEl.value = selectedItem?.searchTerm()!;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../signal-like/signal-like';\n\n/** Represents an item in a collection, such as a listbox option, than may receive focus. */\nexport interface ListFocusItem {\n  /** A unique identifier for the item. */\n  id: SignalLike<string>;\n\n  /** The html element that should receive focus. */\n  element: SignalLike<HTMLElement | undefined>;\n\n  /** Whether an item is disabled. */\n  disabled: SignalLike<boolean>;\n\n  /** The index of the item in the list. */\n  index: SignalLike<number>;\n}\n\n/** Represents the required inputs for a collection that contains focusable items. */\nexport interface ListFocusInputs<T extends ListFocusItem> {\n  /** The focus strategy used by the list. */\n  focusMode: SignalLike<'roving' | 'activedescendant'>;\n\n  /** Whether the list is disabled. */\n  disabled: SignalLike<boolean>;\n\n  /** The items in the list. */\n  items: SignalLike<T[]>;\n\n  /** The active item. */\n  activeItem: WritableSignalLike<T | undefined>;\n\n  /** Whether disabled items in the list should be focusable. */\n  softDisabled: SignalLike<boolean>;\n\n  element: SignalLike<HTMLElement | undefined>;\n}\n\n/** Controls focus for a list of items. */\nexport class ListFocus<T extends ListFocusItem> {\n  /** The last item that was active. */\n  prevActiveItem = signal<T | undefined>(undefined);\n\n  /** The index of the last item that was active. */\n  prevActiveIndex = computed(() => {\n    return this.prevActiveItem() ? this.inputs.items().indexOf(this.prevActiveItem()!) : -1;\n  });\n\n  /** The current active index in the list. */\n  activeIndex = computed(() => {\n    return this.inputs.activeItem() ? this.inputs.items().indexOf(this.inputs.activeItem()!) : -1;\n  });\n\n  constructor(readonly inputs: ListFocusInputs<T>) {}\n\n  /** Whether the list is in a disabled state. */\n  isListDisabled(): boolean {\n    return this.inputs.disabled() || this.inputs.items().every(i => i.disabled());\n  }\n\n  /** The id of the current active item. */\n  getActiveDescendant(): string | undefined {\n    if (this.isListDisabled()) {\n      return undefined;\n    }\n    if (this.inputs.focusMode() === 'roving') {\n      return undefined;\n    }\n    return this.inputs.activeItem()?.id() ?? undefined;\n  }\n\n  /** The tab index for the list. */\n  getListTabIndex(): -1 | 0 {\n    if (this.isListDisabled()) {\n      return 0;\n    }\n    return this.inputs.focusMode() === 'activedescendant' ? 0 : -1;\n  }\n\n  /** Returns the tab index for the given item. */\n  getItemTabIndex(item: T): -1 | 0 {\n    if (this.isListDisabled()) {\n      return -1;\n    }\n    if (this.inputs.focusMode() === 'activedescendant') {\n      return -1;\n    }\n    return this.inputs.activeItem() === item ? 0 : -1;\n  }\n\n  /** Moves focus to the given item if it is focusable. */\n  focus(item: T, opts?: {focusElement?: boolean}): boolean {\n    if (this.isListDisabled() || !this.isFocusable(item)) {\n      return false;\n    }\n\n    this.prevActiveItem.set(this.inputs.activeItem());\n    this.inputs.activeItem.set(item);\n\n    if (opts?.focusElement || opts?.focusElement === undefined) {\n      this.inputs.focusMode() === 'roving'\n        ? item.element()?.focus()\n        : this.inputs.element()?.focus();\n    }\n\n    return true;\n  }\n\n  /** Returns true if the given item can be navigated to. */\n  isFocusable(item: T): boolean {\n    return !item.disabled() || this.inputs.softDisabled();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SignalLike} from '../signal-like/signal-like';\nimport {ListFocus, ListFocusInputs, ListFocusItem} from '../list-focus/list-focus';\n\n/** Represents an item in a collection, such as a listbox option, than can be navigated to. */\nexport interface ListNavigationItem extends ListFocusItem {}\n\n/** Represents the required inputs for a collection that has navigable items. */\nexport interface ListNavigationInputs<T extends ListNavigationItem> extends ListFocusInputs<T> {\n  /** Whether focus should wrap when navigating. */\n  wrap: SignalLike<boolean>;\n\n  /** Whether the list is vertically or horizontally oriented. */\n  orientation: SignalLike<'vertical' | 'horizontal'>;\n\n  /** The direction that text is read based on the users locale. */\n  textDirection: SignalLike<'rtl' | 'ltr'>;\n}\n\n/** Controls navigation for a list of items. */\nexport class ListNavigation<T extends ListNavigationItem> {\n  constructor(readonly inputs: ListNavigationInputs<T> & {focusManager: ListFocus<T>}) {}\n\n  /** Navigates to the given item. */\n  goto(item?: T, opts?: {focusElement?: boolean}): boolean {\n    return item ? this.inputs.focusManager.focus(item, opts) : false;\n  }\n\n  /** Navigates to the next item in the list. */\n  next(opts?: {focusElement?: boolean}): boolean {\n    return this._advance(1, opts);\n  }\n\n  /** Peeks the next item in the list. */\n  peekNext(): T | undefined {\n    return this._peek(1);\n  }\n\n  /** Navigates to the previous item in the list. */\n  prev(opts?: {focusElement?: boolean}): boolean {\n    return this._advance(-1, opts);\n  }\n\n  /** Peeks the previous item in the list. */\n  peekPrev(): T | undefined {\n    return this._peek(-1);\n  }\n\n  /** Navigates to the first item in the list. */\n  first(opts?: {focusElement?: boolean}): boolean {\n    const item = this.peekFirst();\n    return item ? this.goto(item, opts) : false;\n  }\n\n  /** Navigates to the last item in the list. */\n  last(opts?: {focusElement?: boolean}): boolean {\n    const item = this.peekLast();\n    return item ? this.goto(item, opts) : false;\n  }\n\n  /** Gets the first focusable item from the given list of items. */\n  peekFirst(items: T[] = this.inputs.items()): T | undefined {\n    return items.find(i => this.inputs.focusManager.isFocusable(i));\n  }\n\n  /** Gets the last focusable item from the given list of items. */\n  peekLast(items: T[] = this.inputs.items()): T | undefined {\n    for (let i = items.length - 1; i >= 0; i--) {\n      if (this.inputs.focusManager.isFocusable(items[i])) {\n        return items[i];\n      }\n    }\n    return;\n  }\n\n  /** Advances to the next or previous focusable item in the list based on the given delta. */\n  private _advance(delta: 1 | -1, opts?: {focusElement?: boolean}): boolean {\n    const item = this._peek(delta);\n    return item ? this.goto(item, opts) : false;\n  }\n\n  /** Peeks the next or previous focusable item in the list based on the given delta. */\n  private _peek(delta: 1 | -1): T | undefined {\n    const items = this.inputs.items();\n    const itemCount = items.length;\n    const startIndex = this.inputs.focusManager.activeIndex();\n    const step = (i: number) =>\n      this.inputs.wrap() ? (i + delta + itemCount) % itemCount : i + delta;\n\n    // If wrapping is enabled, this loop ultimately terminates when `i` gets back to `startIndex`\n    // in the case that all options are disabled. If wrapping is disabled, the loop terminates\n    // when the index goes out of bounds.\n    for (let i = step(startIndex); i !== startIndex && i < itemCount && i >= 0; i = step(i)) {\n      if (this.inputs.focusManager.isFocusable(items[i])) {\n        return items[i];\n      }\n    }\n\n    return;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../signal-like/signal-like';\nimport {ListFocus, ListFocusInputs, ListFocusItem} from '../list-focus/list-focus';\n\n/** Represents an item in a collection, such as a listbox option, than can be selected. */\nexport interface ListSelectionItem<V> extends ListFocusItem {\n  /** The value of the item. */\n  value: SignalLike<V>;\n\n  /** Whether the item is selectable. */\n  selectable: SignalLike<boolean>;\n}\n\n/** Represents the required inputs for a collection that contains selectable items. */\nexport interface ListSelectionInputs<T extends ListSelectionItem<V>, V> extends ListFocusInputs<T> {\n  /** Whether multiple items in the list can be selected at once. */\n  multi: SignalLike<boolean>;\n\n  /** The current value of the list selection. */\n  value: WritableSignalLike<V[]>;\n\n  /** The selection strategy used by the list. */\n  selectionMode: SignalLike<'follow' | 'explicit'>;\n}\n\n/** Controls selection for a list of items. */\nexport class ListSelection<T extends ListSelectionItem<V>, V> {\n  /** The start index to use for range selection. */\n  rangeStartIndex = signal<number>(0);\n\n  /** The end index to use for range selection. */\n  rangeEndIndex = signal<number>(0);\n\n  /** The currently selected items. */\n  selectedItems = computed(() =>\n    this.inputs.items().filter(item => this.inputs.value().includes(item.value())),\n  );\n\n  constructor(readonly inputs: ListSelectionInputs<T, V> & {focusManager: ListFocus<T>}) {}\n\n  /** Selects the item at the current active index. */\n  select(item?: ListSelectionItem<V>, opts = {anchor: true}) {\n    item = item ?? (this.inputs.focusManager.inputs.activeItem() as ListSelectionItem<V>);\n\n    if (\n      !item ||\n      item.disabled() ||\n      !item.selectable() ||\n      this.inputs.value().includes(item.value())\n    ) {\n      return;\n    }\n\n    if (!this.inputs.multi()) {\n      this.deselectAll();\n    }\n\n    const index = this.inputs.items().findIndex(i => i === item);\n    if (opts.anchor) {\n      this.beginRangeSelection(index);\n    }\n    this.inputs.value.update(values => values.concat(item.value()));\n  }\n\n  /** Deselects the item at the current active index. */\n  deselect(item?: ListSelectionItem<V>) {\n    item = item ?? this.inputs.focusManager.inputs.activeItem();\n\n    if (item && !item.disabled() && item.selectable()) {\n      this.inputs.value.update(values => values.filter(value => value !== item.value()));\n    }\n  }\n\n  /** Toggles the item at the current active index. */\n  toggle(item?: ListSelectionItem<V>) {\n    item = item ?? this.inputs.focusManager.inputs.activeItem();\n    if (item) {\n      this.inputs.value().includes(item.value()) ? this.deselect(item) : this.select(item);\n    }\n  }\n\n  /** Toggles only the item at the current active index. */\n  toggleOne() {\n    const item = this.inputs.focusManager.inputs.activeItem();\n    if (item) {\n      this.inputs.value().includes(item.value()) ? this.deselect() : this.selectOne();\n    }\n  }\n\n  /** Selects all items in the list. */\n  selectAll() {\n    if (!this.inputs.multi()) {\n      return; // Should we log a warning?\n    }\n\n    for (const item of this.inputs.items()) {\n      this.select(item, {anchor: false});\n    }\n\n    this.beginRangeSelection();\n  }\n\n  /** Deselects all items in the list. */\n  deselectAll() {\n    // If an item is not in the list, it forcefully gets deselected.\n    // This actually creates a bug for the following edge case:\n    //\n    // Setup: An item is not in the list (maybe it's lazily loaded), and it is disabled & selected.\n    // Expected: If deselectAll() is called, it should NOT get deselected (because it is disabled).\n    // Actual: Calling deselectAll() will still deselect the item.\n    //\n    // Why? Because we can't check if the item is disabled if it's not in the list.\n    //\n    // Alternatively, we could NOT deselect items that are not in the list, but this has the\n    // inverse (and more common) effect of keeping enabled items selected when they aren't in the\n    // list.\n\n    for (const value of this.inputs.value()) {\n      const item = this.inputs.items().find(i => i.value() === value);\n\n      item\n        ? this.deselect(item)\n        : this.inputs.value.update(values => values.filter(v => v !== value));\n    }\n  }\n\n  /**\n   * Selects all items in the list or deselects all\n   * items in the list if all items are already selected.\n   */\n  toggleAll() {\n    const selectableValues = this.inputs\n      .items()\n      .filter(i => !i.disabled() && i.selectable())\n      .map(i => i.value());\n\n    selectableValues.every(i => this.inputs.value().includes(i))\n      ? this.deselectAll()\n      : this.selectAll();\n  }\n\n  /** Sets the selection to only the current active item. */\n  selectOne() {\n    const item = this.inputs.focusManager.inputs.activeItem();\n    if (item && (item.disabled() || !item.selectable())) {\n      return;\n    }\n\n    this.deselectAll();\n\n    if (this.inputs.value().length > 0 && !this.inputs.multi()) {\n      return;\n    }\n\n    this.select();\n  }\n\n  /**\n   * Selects all items in the list up to the anchor item.\n   *\n   * Deselects all items that were previously within the\n   * selected range that are now outside of the selected range\n   */\n  selectRange(opts = {anchor: true}) {\n    const isStartOfRange = this.inputs.focusManager.prevActiveIndex() === this.rangeStartIndex();\n\n    if (isStartOfRange && opts.anchor) {\n      this.beginRangeSelection(this.inputs.focusManager.prevActiveIndex());\n    }\n\n    const itemsInRange = this._getItemsFromIndex(this.rangeStartIndex());\n    const itemsOutOfRange = this._getItemsFromIndex(this.rangeEndIndex()).filter(\n      i => !itemsInRange.includes(i),\n    );\n\n    for (const item of itemsOutOfRange) {\n      this.deselect(item);\n    }\n\n    for (const item of itemsInRange) {\n      this.select(item, {anchor: false});\n    }\n\n    if (itemsInRange.length) {\n      const item = itemsInRange.pop();\n      const index = this.inputs.items().findIndex(i => i === item);\n      this.rangeEndIndex.set(index);\n    }\n  }\n\n  /** Marks the given index as the start of a range selection. */\n  beginRangeSelection(index: number = this.inputs.focusManager.activeIndex()) {\n    this.rangeStartIndex.set(index);\n    this.rangeEndIndex.set(index);\n  }\n\n  /** Returns the items in the list starting from the given index.  */\n  private _getItemsFromIndex(index: number) {\n    if (index === -1) {\n      return [];\n    }\n\n    const upper = Math.max(this.inputs.focusManager.activeIndex(), index);\n    const lower = Math.min(this.inputs.focusManager.activeIndex(), index);\n\n    const items = [];\n    for (let i = lower; i <= upper; i++) {\n      items.push(this.inputs.items()[i]);\n    }\n\n    if (this.inputs.focusManager.activeIndex() < index) {\n      return items.reverse();\n    }\n\n    return items;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\nimport {ListFocus, ListFocusInputs, ListFocusItem} from '../list-focus/list-focus';\n\n/**\n * Represents an item in a collection, such as a listbox option, than can be navigated to by\n * typeahead.\n */\nexport interface ListTypeaheadItem extends ListFocusItem {\n  /** The text used by the typeahead search. */\n  searchTerm: SignalLike<string>;\n}\n\n/**\n * Represents the required inputs for a collection that contains items that can be navigated to by\n * typeahead.\n */\nexport interface ListTypeaheadInputs<T extends ListTypeaheadItem> extends ListFocusInputs<T> {\n  /** The amount of time before the typeahead search is reset. */\n  typeaheadDelay: SignalLike<number>;\n}\n\n/** Controls typeahead for a list of items. */\nexport class ListTypeahead<T extends ListTypeaheadItem> {\n  /** A reference to the timeout for resetting the typeahead search. */\n  timeout?: ReturnType<typeof setTimeout> | undefined;\n\n  /** The focus controller of the parent list. */\n  focusManager: ListFocus<T>;\n\n  /** Whether the user is actively typing a typeahead search query. */\n  isTyping = computed(() => this._query().length > 0);\n\n  /** Keeps track of the characters that typeahead search is being called with. */\n  private _query = signal('');\n\n  /** The index where that the typeahead search was initiated from. */\n  private _startIndex = signal<number | undefined>(undefined);\n\n  constructor(readonly inputs: ListTypeaheadInputs<T> & {focusManager: ListFocus<T>}) {\n    this.focusManager = inputs.focusManager;\n  }\n\n  /** Performs a typeahead search, appending the given character to the search string. */\n  search(char: string): boolean {\n    if (char.length !== 1) {\n      return false;\n    }\n\n    if (!this.isTyping() && char === ' ') {\n      return false;\n    }\n\n    if (this._startIndex() === undefined) {\n      this._startIndex.set(this.focusManager.activeIndex());\n    }\n\n    clearTimeout(this.timeout);\n    this._query.update(q => q + char.toLowerCase());\n    const item = this._getItem();\n\n    if (item) {\n      this.focusManager.focus(item);\n    }\n\n    this.timeout = setTimeout(() => {\n      this._query.set('');\n      this._startIndex.set(undefined);\n    }, this.inputs.typeaheadDelay() * 1000);\n\n    return true;\n  }\n\n  /**\n   * Returns the first item whose search term matches the\n   * current query starting from the the current anchor index.\n   */\n  private _getItem() {\n    let items = this.focusManager.inputs.items();\n    const after = items.slice(this._startIndex()! + 1);\n    const before = items.slice(0, this._startIndex()!);\n    items = after.concat(before);\n    items.push(this.inputs.items()[this._startIndex()!]);\n\n    const focusableItems = [];\n    for (const item of items) {\n      if (this.focusManager.isFocusable(item)) {\n        focusableItems.push(item);\n      }\n    }\n\n    return focusableItems.find(i => i.searchTerm().toLowerCase().startsWith(this._query()));\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {ListFocus, ListFocusInputs, ListFocusItem} from '../list-focus/list-focus';\nimport {\n  ListNavigation,\n  ListNavigationInputs,\n  ListNavigationItem,\n} from '../list-navigation/list-navigation';\nimport {\n  ListSelection,\n  ListSelectionInputs,\n  ListSelectionItem,\n} from '../list-selection/list-selection';\nimport {\n  ListTypeahead,\n  ListTypeaheadInputs,\n  ListTypeaheadItem,\n} from '../list-typeahead/list-typeahead';\n\n/** The operations that the list can perform after navigation. */\ninterface NavOptions {\n  toggle?: boolean;\n  select?: boolean;\n  selectOne?: boolean;\n  selectRange?: boolean;\n  anchor?: boolean;\n  focusElement?: boolean;\n}\n\n/** Represents an item in the list. */\nexport type ListItem<V> = ListTypeaheadItem &\n  ListNavigationItem &\n  ListSelectionItem<V> &\n  ListFocusItem;\n\n/** The necessary inputs for the list behavior. */\nexport type ListInputs<T extends ListItem<V>, V> = ListFocusInputs<T> &\n  ListNavigationInputs<T> &\n  ListSelectionInputs<T, V> &\n  ListTypeaheadInputs<T>;\n\n/** Controls the state of a list. */\nexport class List<T extends ListItem<V>, V> {\n  /** Controls navigation for the list. */\n  navigationBehavior: ListNavigation<T>;\n\n  /** Controls selection for the list. */\n  selectionBehavior: ListSelection<T, V>;\n\n  /** Controls typeahead for the list. */\n  typeaheadBehavior: ListTypeahead<T>;\n\n  /** Controls focus for the list. */\n  focusBehavior: ListFocus<T>;\n\n  /** Whether the list is disabled. */\n  disabled = computed(() => this.focusBehavior.isListDisabled());\n\n  /** The id of the current active item. */\n  activeDescendant = computed(() => this.focusBehavior.getActiveDescendant());\n\n  /** The tab index of the list. */\n  tabIndex = computed(() => this.focusBehavior.getListTabIndex());\n\n  /** The index of the currently active item in the list. */\n  activeIndex = computed(() => this.focusBehavior.activeIndex());\n\n  /**\n   * The uncommitted index for selecting a range of options.\n   *\n   * NOTE: This is subtly distinct from the \"rangeStartIndex\" in the ListSelection behavior.\n   * The anchorIndex does not necessarily represent the start of a range, but represents the most\n   * recent index where the user showed intent to begin a range selection. Usually, this is wherever\n   * the user most recently pressed the \"Shift\" key, but if the user presses shift + space to select\n   * from the anchor, the user is not intending to start a new range from this index.\n   *\n   * In other words, \"rangeStartIndex\" is only set when a user commits to starting a range selection\n   * while \"anchorIndex\" is set whenever a user indicates they may be starting a range selection.\n   */\n  private _anchorIndex = signal(0);\n\n  /** Whether the list should wrap. Used to disable wrapping while range selecting. */\n  private _wrap = signal(true);\n\n  constructor(readonly inputs: ListInputs<T, V>) {\n    this.focusBehavior = new ListFocus(inputs);\n    this.selectionBehavior = new ListSelection({...inputs, focusManager: this.focusBehavior});\n    this.typeaheadBehavior = new ListTypeahead({...inputs, focusManager: this.focusBehavior});\n    this.navigationBehavior = new ListNavigation({\n      ...inputs,\n      focusManager: this.focusBehavior,\n      wrap: computed(() => this._wrap() && this.inputs.wrap()),\n    });\n  }\n\n  /** Returns the tab index for the given item. */\n  getItemTabindex(item: T) {\n    return this.focusBehavior.getItemTabIndex(item);\n  }\n\n  /** Navigates to the first option in the list. */\n  first(opts?: NavOptions) {\n    this._navigate(opts, () => this.navigationBehavior.first(opts));\n  }\n\n  /** Navigates to the last option in the list. */\n  last(opts?: NavOptions) {\n    this._navigate(opts, () => this.navigationBehavior.last(opts));\n  }\n\n  /** Navigates to the next option in the list. */\n  next(opts?: NavOptions) {\n    this._navigate(opts, () => this.navigationBehavior.next(opts));\n  }\n\n  /** Navigates to the previous option in the list. */\n  prev(opts?: NavOptions) {\n    this._navigate(opts, () => this.navigationBehavior.prev(opts));\n  }\n\n  /** Navigates to the given item in the list. */\n  goto(item: T, opts?: NavOptions) {\n    this._navigate(opts, () => this.navigationBehavior.goto(item, opts));\n  }\n\n  /** Removes focus from the list. */\n  unfocus() {\n    this.inputs.activeItem.set(undefined);\n  }\n\n  /** Marks the given index as the potential start of a range selection. */\n  anchor(index: number) {\n    this._anchorIndex.set(index);\n  }\n\n  /** Handles typeahead search navigation for the list. */\n  search(char: string, opts?: NavOptions) {\n    this._navigate(opts, () => this.typeaheadBehavior.search(char));\n  }\n\n  /** Checks if the list is currently typing for typeahead search. */\n  isTyping() {\n    return this.typeaheadBehavior.isTyping();\n  }\n\n  /** Selects the currently active item in the list. */\n  select(item?: T) {\n    this.selectionBehavior.select(item);\n  }\n\n  /** Sets the selection to only the current active item. */\n  selectOne() {\n    this.selectionBehavior.selectOne();\n  }\n\n  /** Deselects the currently active item in the list. */\n  deselect(item?: T) {\n    this.selectionBehavior.deselect(item);\n  }\n\n  /** Deselects all items in the list. */\n  deselectAll() {\n    this.selectionBehavior.deselectAll();\n  }\n\n  /** Toggles the currently active item in the list. */\n  toggle(item?: T) {\n    this.selectionBehavior.toggle(item);\n  }\n\n  /** Toggles the currently active item in the list, deselecting all other items. */\n  toggleOne() {\n    this.selectionBehavior.toggleOne();\n  }\n\n  /** Toggles the selection of all items in the list. */\n  toggleAll() {\n    this.selectionBehavior.toggleAll();\n  }\n\n  /** Checks if the given item is able to receive focus. */\n  isFocusable(item: T) {\n    return this.focusBehavior.isFocusable(item);\n  }\n\n  /** Handles updating selection for the list. */\n  updateSelection(opts: NavOptions = {anchor: true}) {\n    if (opts.toggle) {\n      this.selectionBehavior.toggle();\n    }\n    if (opts.select) {\n      this.selectionBehavior.select();\n    }\n    if (opts.selectOne) {\n      this.selectionBehavior.selectOne();\n    }\n    if (opts.selectRange) {\n      this.selectionBehavior.selectRange();\n    }\n    if (!opts.anchor) {\n      this.anchor(this.selectionBehavior.rangeStartIndex());\n    }\n  }\n\n  /**\n   * Safely performs a navigation operation.\n   *\n   * Handles conditionally disabling wrapping for when a navigation\n   * operation is occurring while the user is selecting a range of options.\n   *\n   * Handles boilerplate calling of focus & selection operations. Also ensures these\n   * additional operations are only called if the navigation operation moved focus to a new option.\n   */\n  private _navigate(opts: NavOptions = {}, operation: () => boolean) {\n    if (opts?.selectRange) {\n      this._wrap.set(false);\n      this.selectionBehavior.rangeStartIndex.set(this._anchorIndex());\n    }\n\n    const moved = operation();\n\n    if (moved) {\n      this.updateSelection(opts);\n    }\n\n    this._wrap.set(true);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {OptionPattern} from './option';\nimport {KeyboardEventManager, PointerEventManager, Modifier} from '../behaviors/event-manager';\nimport {computed, signal} from '@angular/core';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport {List, ListInputs} from '../behaviors/list/list';\n\n/** Represents the required inputs for a listbox. */\nexport type ListboxInputs<V> = ListInputs<OptionPattern<V>, V> & {\n  /** A unique identifier for the listbox. */\n  id: SignalLike<string>;\n\n  /** Whether the listbox is readonly. */\n  readonly: SignalLike<boolean>;\n};\n\n/** Controls the state of a listbox. */\nexport class ListboxPattern<V> {\n  listBehavior: List<OptionPattern<V>, V>;\n\n  /** Whether the list is vertically or horizontally oriented. */\n  orientation: SignalLike<'vertical' | 'horizontal'>;\n\n  /** Whether the listbox is disabled. */\n  disabled = computed(() => this.listBehavior.disabled());\n\n  /** Whether the listbox is readonly. */\n  readonly: SignalLike<boolean>;\n\n  /** The tab index of the listbox. */\n  tabIndex: SignalLike<-1 | 0> = computed(() => this.listBehavior.tabIndex());\n\n  /** The id of the current active item. */\n  activeDescendant = computed(() => this.listBehavior.activeDescendant());\n\n  /** Whether multiple items in the list can be selected at once. */\n  multi: SignalLike<boolean>;\n\n  /** The number of items in the listbox. */\n  setsize = computed(() => this.inputs.items().length);\n\n  /** Whether the listbox selection follows focus. */\n  followFocus = computed(() => this.inputs.selectionMode() === 'follow');\n\n  /** Whether the listbox should wrap. Used to disable wrapping while range selecting. */\n  wrap = signal(true);\n\n  /** The key used to navigate to the previous item in the list. */\n  prevKey = computed(() => {\n    if (this.inputs.orientation() === 'vertical') {\n      return 'ArrowUp';\n    }\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n  });\n\n  /** The key used to navigate to the next item in the list. */\n  nextKey = computed(() => {\n    if (this.inputs.orientation() === 'vertical') {\n      return 'ArrowDown';\n    }\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowLeft' : 'ArrowRight';\n  });\n\n  /** Represents the space key. Does nothing when the user is actively using typeahead. */\n  dynamicSpaceKey = computed(() => (this.listBehavior.isTyping() ? '' : ' '));\n\n  /** The regexp used to decide if a key should trigger typeahead. */\n  typeaheadRegexp = /^.$/;\n\n  /** The keydown event manager for the listbox. */\n  keydown = computed(() => {\n    const manager = new KeyboardEventManager();\n\n    if (this.readonly()) {\n      return manager\n        .on(this.prevKey, () => this.listBehavior.prev())\n        .on(this.nextKey, () => this.listBehavior.next())\n        .on('Home', () => this.listBehavior.first())\n        .on('End', () => this.listBehavior.last())\n        .on(this.typeaheadRegexp, e => this.listBehavior.search(e.key));\n    }\n\n    if (!this.followFocus()) {\n      manager\n        .on(this.prevKey, () => this.listBehavior.prev())\n        .on(this.nextKey, () => this.listBehavior.next())\n        .on('Home', () => this.listBehavior.first())\n        .on('End', () => this.listBehavior.last())\n        .on(this.typeaheadRegexp, e => this.listBehavior.search(e.key));\n    }\n\n    if (this.followFocus()) {\n      manager\n        .on(this.prevKey, () => this.listBehavior.prev({selectOne: true}))\n        .on(this.nextKey, () => this.listBehavior.next({selectOne: true}))\n        .on('Home', () => this.listBehavior.first({selectOne: true}))\n        .on('End', () => this.listBehavior.last({selectOne: true}))\n        .on(this.typeaheadRegexp, e => this.listBehavior.search(e.key, {selectOne: true}));\n    }\n\n    if (this.inputs.multi()) {\n      manager\n        .on(Modifier.Any, 'Shift', () => this.listBehavior.anchor(this.listBehavior.activeIndex()))\n        .on(Modifier.Shift, this.prevKey, () => this.listBehavior.prev({selectRange: true}))\n        .on(Modifier.Shift, this.nextKey, () => this.listBehavior.next({selectRange: true}))\n        .on([Modifier.Ctrl | Modifier.Shift, Modifier.Meta | Modifier.Shift], 'Home', () =>\n          this.listBehavior.first({selectRange: true, anchor: false}),\n        )\n        .on([Modifier.Ctrl | Modifier.Shift, Modifier.Meta | Modifier.Shift], 'End', () =>\n          this.listBehavior.last({selectRange: true, anchor: false}),\n        )\n        .on(Modifier.Shift, 'Enter', () =>\n          this.listBehavior.updateSelection({selectRange: true, anchor: false}),\n        )\n        .on(Modifier.Shift, this.dynamicSpaceKey, () =>\n          this.listBehavior.updateSelection({selectRange: true, anchor: false}),\n        );\n    }\n\n    if (!this.followFocus() && this.inputs.multi()) {\n      manager\n        .on(this.dynamicSpaceKey, () => this.listBehavior.toggle())\n        .on('Enter', () => this.listBehavior.toggle())\n        .on([Modifier.Ctrl, Modifier.Meta], 'A', () => this.listBehavior.toggleAll());\n    }\n\n    if (!this.followFocus() && !this.inputs.multi()) {\n      manager.on(this.dynamicSpaceKey, () => this.listBehavior.toggleOne());\n      manager.on('Enter', () => this.listBehavior.toggleOne());\n    }\n\n    if (this.inputs.multi() && this.followFocus()) {\n      manager\n        .on([Modifier.Ctrl, Modifier.Meta], this.prevKey, () => this.listBehavior.prev())\n        .on([Modifier.Ctrl, Modifier.Meta], this.nextKey, () => this.listBehavior.next())\n        .on([Modifier.Ctrl, Modifier.Meta], ' ', () => this.listBehavior.toggle())\n        .on([Modifier.Ctrl, Modifier.Meta], 'Enter', () => this.listBehavior.toggle())\n        .on([Modifier.Ctrl, Modifier.Meta], 'Home', () => this.listBehavior.first())\n        .on([Modifier.Ctrl, Modifier.Meta], 'End', () => this.listBehavior.last())\n        .on([Modifier.Ctrl, Modifier.Meta], 'A', () => {\n          this.listBehavior.toggleAll();\n          this.listBehavior.select(); // Ensure the currect option remains selected.\n        });\n    }\n\n    return manager;\n  });\n\n  /** The pointerdown event manager for the listbox. */\n  pointerdown = computed(() => {\n    const manager = new PointerEventManager();\n\n    if (this.readonly()) {\n      return manager.on(e => this.listBehavior.goto(this._getItem(e)!));\n    }\n\n    if (this.multi()) {\n      manager.on(Modifier.Shift, e =>\n        this.listBehavior.goto(this._getItem(e)!, {selectRange: true}),\n      );\n    }\n\n    if (!this.multi() && this.followFocus()) {\n      return manager.on(e => this.listBehavior.goto(this._getItem(e)!, {selectOne: true}));\n    }\n\n    if (!this.multi() && !this.followFocus()) {\n      return manager.on(e => this.listBehavior.goto(this._getItem(e)!, {toggle: true}));\n    }\n\n    if (this.multi() && this.followFocus()) {\n      return manager\n        .on(e => this.listBehavior.goto(this._getItem(e)!, {selectOne: true}))\n        .on(Modifier.Ctrl, e => this.listBehavior.goto(this._getItem(e)!, {toggle: true}));\n    }\n\n    if (this.multi() && !this.followFocus()) {\n      return manager.on(e => this.listBehavior.goto(this._getItem(e)!, {toggle: true}));\n    }\n\n    return manager;\n  });\n\n  constructor(readonly inputs: ListboxInputs<V>) {\n    this.readonly = inputs.readonly;\n    this.orientation = inputs.orientation;\n    this.multi = inputs.multi;\n    this.listBehavior = new List(inputs);\n  }\n\n  /** Returns a set of violations */\n  validate(): string[] {\n    const violations: string[] = [];\n\n    if (!this.inputs.multi() && this.inputs.value().length > 1) {\n      violations.push(\n        `A single-select listbox should not have multiple selected options. Selected options: ${this.inputs.value().join(', ')}`,\n      );\n    }\n\n    return violations;\n  }\n\n  /** Handles keydown events for the listbox. */\n  onKeydown(event: KeyboardEvent) {\n    if (!this.disabled()) {\n      this.keydown().handle(event);\n    }\n  }\n\n  onPointerdown(event: PointerEvent) {\n    if (!this.disabled()) {\n      this.pointerdown().handle(event);\n    }\n  }\n\n  /**\n   * Sets the listbox to it's default initial state.\n   *\n   * Sets the active index of the listbox to the first focusable selected\n   * item if one exists. Otherwise, sets focus to the first focusable item.\n   *\n   * This method should be called once the listbox and it's options are properly initialized,\n   * meaning the ListboxPattern and OptionPatterns should have references to each other before this\n   * is called.\n   */\n  setDefaultState() {\n    let firstItem: OptionPattern<V> | null = null;\n\n    for (const item of this.inputs.items()) {\n      if (this.listBehavior.isFocusable(item)) {\n        if (!firstItem) {\n          firstItem = item;\n        }\n        if (item.selected()) {\n          this.inputs.activeItem.set(item);\n          return;\n        }\n      }\n    }\n\n    if (firstItem) {\n      this.inputs.activeItem.set(firstItem);\n    }\n  }\n\n  protected _getItem(e: PointerEvent) {\n    if (!(e.target instanceof HTMLElement)) {\n      return;\n    }\n\n    const element = e.target.closest('[role=\"option\"]');\n    return this.inputs.items().find(i => i.element() === element);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport {List, ListInputs, ListItem} from '../behaviors/list/list';\n\n/**\n * Represents the properties exposed by a listbox that need to be accessed by an option.\n * This exists to avoid circular dependency errors between the listbox and option.\n */\ninterface ListboxPattern<V> {\n  inputs: ListInputs<OptionPattern<V>, V>;\n  listBehavior: List<OptionPattern<V>, V>;\n}\n\n/** Represents the required inputs for an option in a listbox. */\nexport interface OptionInputs<V> extends Omit<ListItem<V>, 'index' | 'selectable'> {\n  listbox: SignalLike<ListboxPattern<V> | undefined>;\n}\n\n/** Represents an option in a listbox. */\nexport class OptionPattern<V> {\n  /** A unique identifier for the option. */\n  id: SignalLike<string>;\n\n  /** The value of the option. */\n  value: SignalLike<V>;\n\n  /** The position of the option in the list. */\n  index = computed(() => this.listbox()?.inputs.items().indexOf(this) ?? -1);\n\n  /** Whether the option is active. */\n  active = computed(() => this.listbox()?.inputs.activeItem() === this);\n\n  /** Whether the option is selected. */\n  selected = computed(() => this.listbox()?.inputs.value().includes(this.value()));\n\n  /** Whether the option is selectable. */\n  selectable = () => true;\n\n  /** Whether the option is disabled. */\n  disabled: SignalLike<boolean>;\n\n  /** The text used by the typeahead search. */\n  searchTerm: SignalLike<string>;\n\n  /** A reference to the parent listbox. */\n  listbox: SignalLike<ListboxPattern<V> | undefined>;\n\n  /** The tab index of the option. */\n  tabIndex = computed(() => this.listbox()?.listBehavior.getItemTabindex(this));\n\n  /** The html element that should receive focus. */\n  element: SignalLike<HTMLElement | undefined>;\n\n  constructor(args: OptionInputs<V>) {\n    this.id = args.id;\n    this.value = args.value;\n    this.listbox = args.listbox;\n    this.element = args.element;\n    this.disabled = args.disabled;\n    this.searchTerm = args.searchTerm;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {ListboxInputs, ListboxPattern} from './listbox';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport {OptionPattern} from './option';\nimport {ComboboxPattern, ComboboxListboxControls} from '../combobox/combobox';\n\nexport type ComboboxListboxInputs<V> = ListboxInputs<V> & {\n  /** The combobox controlling the listbox. */\n  combobox: SignalLike<ComboboxPattern<OptionPattern<V>, V> | undefined>;\n};\n\nexport class ComboboxListboxPattern<V>\n  extends ListboxPattern<V>\n  implements ComboboxListboxControls<OptionPattern<V>, V>\n{\n  /** A unique identifier for the popup. */\n  id = computed(() => this.inputs.id());\n\n  /** The ARIA role for the listbox. */\n  role = computed(() => 'listbox' as const);\n\n  /** The id of the active (focused) item in the listbox. */\n  activeId = computed(() => this.listBehavior.activeDescendant());\n\n  /** The list of options in the listbox. */\n  items: SignalLike<OptionPattern<V>[]> = computed(() => this.inputs.items());\n\n  /** The tab index for the listbox. Always -1 because the combobox handles focus. */\n  override tabIndex: SignalLike<-1 | 0> = () => -1;\n\n  /** Whether multiple items in the list can be selected at once. */\n  override multi = computed(() => {\n    return this.inputs.combobox()?.readonly() ? this.inputs.multi() : false;\n  });\n\n  constructor(override readonly inputs: ComboboxListboxInputs<V>) {\n    if (inputs.combobox()) {\n      inputs.focusMode = () => 'activedescendant';\n      inputs.element = inputs.combobox()!.inputs.inputEl;\n    }\n\n    super(inputs);\n  }\n\n  /** Noop. The combobox handles keydown events. */\n  override onKeydown(_: KeyboardEvent): void {}\n\n  /** Noop. The combobox handles pointerdown events. */\n  override onPointerdown(_: PointerEvent): void {}\n\n  /** Noop. The combobox controls the open state. */\n  override setDefaultState(): void {}\n\n  /** Navigates to the specified item in the listbox. */\n  focus = (item: OptionPattern<V>, opts?: {focusElement?: boolean}) => {\n    this.listBehavior.goto(item, opts);\n  };\n\n  /** Navigates to the next focusable item in the listbox. */\n  next = () => this.listBehavior.next();\n\n  /** Navigates to the previous focusable item in the listbox. */\n  prev = () => this.listBehavior.prev();\n\n  /** Navigates to the last focusable item in the listbox. */\n  last = () => this.listBehavior.last();\n\n  /** Navigates to the first focusable item in the listbox. */\n  first = () => this.listBehavior.first();\n\n  /** Unfocuses the currently focused item in the listbox. */\n  unfocus = () => this.listBehavior.unfocus();\n\n  /** Selects the specified item in the listbox. */\n  select = (item?: OptionPattern<V>) => this.listBehavior.select(item);\n\n  /** Toggles the selection state of the given item in the listbox. */\n  toggle = (item?: OptionPattern<V>) => this.listBehavior.toggle(item);\n\n  /** Clears the selection in the listbox. */\n  clearSelection = () => this.listBehavior.deselectAll();\n\n  /** Retrieves the OptionPattern associated with a pointer event. */\n  getItem = (e: PointerEvent) => this._getItem(e);\n\n  /** Retrieves the currently selected items in the listbox. */\n  getSelectedItems = () => {\n    // NOTE: We need to do this funky for loop to preserve the order of the selected values.\n    const items = [];\n    for (const value of this.inputs.value()) {\n      const item = this.items().find(i => i.value() === value);\n      if (item) {\n        items.push(item);\n      }\n    }\n    return items;\n  };\n\n  /** Sets the value of the combobox listbox. */\n  setValue = (value: V | undefined) => this.inputs.value.set(value ? [value] : []);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, Signal, signal} from '@angular/core';\nimport {KeyboardEventManager} from '../behaviors/event-manager';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport {List, ListInputs, ListItem} from '../behaviors/list/list';\n\n/** The inputs for the MenuBarPattern class. */\nexport interface MenuBarInputs<V> extends Omit<ListInputs<MenuItemPattern<V>, V>, 'disabled'> {\n  /** The menu items contained in the menu. */\n  items: SignalLike<MenuItemPattern<V>[]>;\n\n  /** Callback function triggered when a menu item is selected. */\n  onSelect?: (value: V) => void;\n\n  /** The text direction of the menu bar. */\n  textDirection: SignalLike<'ltr' | 'rtl'>;\n}\n\n/** The inputs for the MenuPattern class. */\nexport interface MenuInputs<V>\n  extends Omit<ListInputs<MenuItemPattern<V>, V>, 'value' | 'disabled'> {\n  /** The unique ID of the menu. */\n  id: SignalLike<string>;\n\n  /** The menu items contained in the menu. */\n  items: SignalLike<MenuItemPattern<V>[]>;\n\n  /** A reference to the parent menu or menu trigger. */\n  parent: SignalLike<MenuTriggerPattern<V> | MenuItemPattern<V> | undefined>;\n\n  /** Callback function triggered when a menu item is selected. */\n  onSelect?: (value: V) => void;\n\n  /** The text direction of the menu bar. */\n  textDirection: SignalLike<'ltr' | 'rtl'>;\n}\n\n/** The inputs for the MenuTriggerPattern class. */\nexport interface MenuTriggerInputs<V> {\n  /** A reference to the menu trigger element. */\n  element: SignalLike<HTMLElement | undefined>;\n\n  /** A reference to the menu associated with the trigger. */\n  menu: SignalLike<MenuPattern<V> | undefined>;\n\n  /** The text direction of the menu bar. */\n  textDirection: SignalLike<'ltr' | 'rtl'>;\n}\n\n/** The inputs for the MenuItemPattern class. */\nexport interface MenuItemInputs<V> extends Omit<ListItem<V>, 'index' | 'selectable'> {\n  /** A reference to the parent menu or menu trigger. */\n  parent: SignalLike<MenuPattern<V> | MenuBarPattern<V> | undefined>;\n\n  /** A reference to the submenu associated with the menu item. */\n  submenu: SignalLike<MenuPattern<V> | undefined>;\n}\n\n/** The menu ui pattern class. */\nexport class MenuPattern<V> {\n  /** The unique ID of the menu. */\n  id: SignalLike<string>;\n\n  /** The role of the menu. */\n  role = () => 'menu';\n\n  /** Whether the menu is visible. */\n  isVisible = computed(() => (this.inputs.parent() ? !!this.inputs.parent()?.expanded() : true));\n\n  /** Controls list behavior for the menu items. */\n  listBehavior: List<MenuItemPattern<V>, V>;\n\n  /** Whether the menu or any of its child elements are currently focused. */\n  isFocused = signal(false);\n\n  /** Whether the menu has received focus. */\n  hasBeenFocused = signal(false);\n\n  /** Whether the menu should be focused on mouse over. */\n  shouldFocus = computed(() => {\n    const root = this.root();\n\n    if (root instanceof MenuTriggerPattern) {\n      return true;\n    }\n\n    if (root instanceof MenuBarPattern || root instanceof MenuPattern) {\n      return root.isFocused();\n    }\n\n    return false;\n  });\n\n  /** The key used to expand sub-menus. */\n  private _expandKey = computed(() => {\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowLeft' : 'ArrowRight';\n  });\n\n  /** The key used to collapse sub-menus. */\n  private _collapseKey = computed(() => {\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n  });\n\n  /** Represents the space key. Does nothing when the user is actively using typeahead. */\n  dynamicSpaceKey = computed(() => (this.listBehavior.isTyping() ? '' : ' '));\n\n  /** The regexp used to decide if a key should trigger typeahead. */\n  typeaheadRegexp = /^.$/;\n\n  /** The root of the menu. */\n  root: Signal<MenuTriggerPattern<V> | MenuBarPattern<V> | MenuPattern<V> | undefined> = computed(\n    () => {\n      const parent = this.inputs.parent();\n\n      if (!parent) {\n        return this;\n      }\n\n      if (parent instanceof MenuTriggerPattern) {\n        return parent;\n      }\n\n      const grandparent = parent.inputs.parent();\n\n      if (grandparent instanceof MenuBarPattern) {\n        return grandparent;\n      }\n\n      return grandparent?.root();\n    },\n  );\n\n  /** Handles keyboard events for the menu. */\n  keydownManager = computed(() => {\n    return new KeyboardEventManager()\n      .on('ArrowDown', () => this.next())\n      .on('ArrowUp', () => this.prev())\n      .on('Home', () => this.first())\n      .on('End', () => this.last())\n      .on('Enter', () => this.trigger())\n      .on('Escape', () => this.closeAll())\n      .on(this._expandKey, () => this.expand())\n      .on(this._collapseKey, () => this.collapse())\n      .on(this.dynamicSpaceKey, () => this.trigger())\n      .on(this.typeaheadRegexp, e => this.listBehavior.search(e.key));\n  });\n\n  constructor(readonly inputs: MenuInputs<V>) {\n    this.id = inputs.id;\n    this.listBehavior = new List<MenuItemPattern<V>, V>({\n      ...inputs,\n      value: signal([]),\n      disabled: () => false,\n    });\n  }\n\n  /** Sets the default state for the menu. */\n  setDefaultState() {\n    if (!this.inputs.parent()) {\n      this.inputs.activeItem.set(this.inputs.items()[0]);\n    }\n  }\n\n  /** Handles keyboard events for the menu. */\n  onKeydown(event: KeyboardEvent) {\n    this.keydownManager().handle(event);\n  }\n\n  /** Handles mouseover events for the menu. */\n  onMouseOver(event: MouseEvent) {\n    if (!this.isVisible()) {\n      return;\n    }\n\n    const item = this.inputs.items().find(i => i.element()?.contains(event.target as Node));\n\n    if (!item) {\n      return;\n    }\n\n    const activeItem = this?.inputs.activeItem();\n\n    if (activeItem && activeItem !== item) {\n      activeItem.close();\n    }\n\n    if (item.expanded() && item.submenu()?.inputs.activeItem()) {\n      item.submenu()?.inputs.activeItem()?.close();\n      item.submenu()?.listBehavior.unfocus();\n    }\n\n    item.open();\n    this.listBehavior.goto(item, {focusElement: this.shouldFocus()});\n  }\n\n  /** Handles mouseout events for the menu. */\n  onMouseOut(event: MouseEvent) {\n    if (this.isFocused()) {\n      return;\n    }\n\n    const root = this.root();\n    const parent = this.inputs.parent();\n    const relatedTarget = event.relatedTarget as Node | null;\n\n    if (!root || !parent || parent instanceof MenuTriggerPattern) {\n      return;\n    }\n\n    const grandparent = parent.inputs.parent();\n\n    if (!grandparent || grandparent instanceof MenuBarPattern) {\n      return;\n    }\n\n    if (!grandparent.inputs.element()?.contains(relatedTarget)) {\n      parent.close();\n    }\n  }\n\n  /** Handles click events for the menu. */\n  onClick(event: MouseEvent) {\n    const relatedTarget = event.target as Node | null;\n    const item = this.inputs.items().find(i => i.element()?.contains(relatedTarget));\n\n    if (item) {\n      item.open();\n      this.listBehavior.goto(item);\n      this.submit(item);\n    }\n  }\n\n  /** Handles focusin events for the menu. */\n  onFocusIn() {\n    this.isFocused.set(true);\n    this.hasBeenFocused.set(true);\n  }\n\n  /** Handles the focusout event for the menu. */\n  onFocusOut(event: FocusEvent) {\n    const parent = this.inputs.parent();\n    const parentEl = parent?.inputs.element();\n    const relatedTarget = event.relatedTarget as Node | null;\n\n    if (!relatedTarget) {\n      this.isFocused.set(false);\n      this.inputs.parent()?.close({refocus: true});\n    }\n\n    if (parent instanceof MenuItemPattern) {\n      const grandparent = parent.inputs.parent();\n      const siblings = grandparent?.inputs.items().filter(i => i !== parent);\n      const item = siblings?.find(i => i.element()?.contains(relatedTarget));\n\n      if (item) {\n        return;\n      }\n    }\n\n    if (\n      this.isVisible() &&\n      !parentEl?.contains(relatedTarget) &&\n      !this.inputs.element()?.contains(relatedTarget)\n    ) {\n      this.isFocused.set(false);\n      this.inputs.parent()?.close();\n    }\n  }\n\n  /** Focuses the previous menu item. */\n  prev() {\n    this.inputs.activeItem()?.close();\n    this.listBehavior.prev();\n  }\n\n  /** Focuses the next menu item. */\n  next() {\n    this.inputs.activeItem()?.close();\n    this.listBehavior.next();\n  }\n\n  /** Focuses the first menu item. */\n  first() {\n    this.inputs.activeItem()?.close();\n    this.listBehavior.first();\n  }\n\n  /** Focuses the last menu item. */\n  last() {\n    this.inputs.activeItem()?.close();\n    this.listBehavior.last();\n  }\n\n  /** Triggers the active menu item. */\n  trigger() {\n    this.inputs.activeItem()?.hasPopup()\n      ? this.inputs.activeItem()?.open({first: true})\n      : this.submit();\n  }\n\n  /** Submits the menu. */\n  submit(item = this.inputs.activeItem()) {\n    const root = this.root();\n\n    if (item && !item.disabled()) {\n      const isMenu = root instanceof MenuPattern;\n      const isMenuBar = root instanceof MenuBarPattern;\n      const isMenuTrigger = root instanceof MenuTriggerPattern;\n\n      if (!item.submenu() && isMenuTrigger) {\n        root.close({refocus: true});\n      }\n\n      if (!item.submenu() && isMenuBar) {\n        root.close();\n        root?.inputs.onSelect?.(item.value());\n      }\n\n      if (!item.submenu() && isMenu) {\n        root.inputs.activeItem()?.close({refocus: true});\n        root?.inputs.onSelect?.(item.value());\n      }\n    }\n  }\n\n  /** Collapses the current menu or focuses the previous item in the menubar. */\n  collapse() {\n    const root = this.root();\n    const parent = this.inputs.parent();\n\n    if (parent instanceof MenuItemPattern && !(parent.inputs.parent() instanceof MenuBarPattern)) {\n      parent.close({refocus: true});\n    } else if (root instanceof MenuBarPattern) {\n      root.prev();\n    }\n  }\n\n  /** Expands the current menu or focuses the next item in the menubar. */\n  expand() {\n    const root = this.root();\n    const activeItem = this.inputs.activeItem();\n\n    if (activeItem?.submenu()) {\n      activeItem.open({first: true});\n    } else if (root instanceof MenuBarPattern) {\n      root.next();\n    }\n  }\n\n  /** Closes the menu and all parent menus. */\n  closeAll() {\n    const root = this.root();\n\n    if (root instanceof MenuTriggerPattern) {\n      root.close({refocus: true});\n    }\n\n    if (root instanceof MenuBarPattern) {\n      root.close();\n    }\n\n    if (root instanceof MenuPattern) {\n      root.inputs.activeItem()?.close({refocus: true});\n    }\n  }\n}\n\n/** The menubar ui pattern class. */\nexport class MenuBarPattern<V> {\n  /** Controls list behavior for the menu items. */\n  listBehavior: List<MenuItemPattern<V>, V>;\n\n  /** The key used to navigate to the next item. */\n  private _nextKey = computed(() => {\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowLeft' : 'ArrowRight';\n  });\n\n  /** The key used to navigate to the previous item. */\n  private _previousKey = computed(() => {\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n  });\n\n  /** Represents the space key. Does nothing when the user is actively using typeahead. */\n  dynamicSpaceKey = computed(() => (this.listBehavior.isTyping() ? '' : ' '));\n\n  /** The regexp used to decide if a key should trigger typeahead. */\n  typeaheadRegexp = /^.$/;\n\n  /** Whether the menubar or any of its children are currently focused. */\n  isFocused = signal(false);\n\n  /** Whether the menubar has been focused. */\n  hasBeenFocused = signal(false);\n\n  /** Handles keyboard events for the menu. */\n  keydownManager = computed(() => {\n    return new KeyboardEventManager()\n      .on(this._nextKey, () => this.next())\n      .on(this._previousKey, () => this.prev())\n      .on('End', () => this.listBehavior.last())\n      .on('Home', () => this.listBehavior.first())\n      .on('Enter', () => this.inputs.activeItem()?.open({first: true}))\n      .on('ArrowUp', () => this.inputs.activeItem()?.open({last: true}))\n      .on('ArrowDown', () => this.inputs.activeItem()?.open({first: true}))\n      .on(this.dynamicSpaceKey, () => this.inputs.activeItem()?.open({first: true}))\n      .on(this.typeaheadRegexp, e => this.listBehavior.search(e.key));\n  });\n\n  constructor(readonly inputs: MenuBarInputs<V>) {\n    this.listBehavior = new List<MenuItemPattern<V>, V>({...inputs, disabled: () => false});\n  }\n\n  /** Sets the default state for the menubar. */\n  setDefaultState() {\n    this.inputs.activeItem.set(this.inputs.items()[0]);\n  }\n\n  /** Handles keyboard events for the menu. */\n  onKeydown(event: KeyboardEvent) {\n    this.keydownManager().handle(event);\n  }\n\n  /** Handles click events for the menu bar. */\n  onClick(event: MouseEvent) {\n    const item = this.inputs.items().find(i => i.element()?.contains(event.target as Node));\n\n    if (!item) {\n      return;\n    }\n\n    this.goto(item);\n    item.expanded() ? item.close() : item.open();\n  }\n\n  /** Handles mouseover events for the menu bar. */\n  onMouseOver(event: MouseEvent) {\n    const item = this.inputs.items().find(i => i.element()?.contains(event.target as Node));\n\n    if (item) {\n      this.goto(item, {focusElement: this.isFocused()});\n    }\n  }\n\n  /** Handles focusin events for the menu bar. */\n  onFocusIn() {\n    this.isFocused.set(true);\n    this.hasBeenFocused.set(true);\n  }\n\n  /** Handles focusout events for the menu bar. */\n  onFocusOut(event: FocusEvent) {\n    const relatedTarget = event.relatedTarget as Node | null;\n\n    if (!this.inputs.element()?.contains(relatedTarget)) {\n      this.isFocused.set(false);\n      this.close();\n    }\n  }\n\n  /** Goes to and optionally focuses the specified menu item. */\n  goto(item: MenuItemPattern<V>, opts?: {focusElement?: boolean}) {\n    const prevItem = this.inputs.activeItem();\n    this.listBehavior.goto(item, opts);\n\n    if (prevItem?.expanded()) {\n      prevItem?.close();\n      this.inputs.activeItem()?.open();\n    }\n\n    if (item === prevItem) {\n      if (item.expanded() && item.submenu()?.inputs.activeItem()) {\n        item.submenu()?.inputs.activeItem()?.close();\n        item.submenu()?.listBehavior.unfocus();\n      }\n    }\n  }\n\n  /** Focuses the next menu item. */\n  next() {\n    const prevItem = this.inputs.activeItem();\n    this.listBehavior.next();\n\n    if (prevItem?.expanded()) {\n      prevItem?.close();\n      this.inputs.activeItem()?.open({first: true});\n    }\n  }\n\n  /** Focuses the previous menu item. */\n  prev() {\n    const prevItem = this.inputs.activeItem();\n    this.listBehavior.prev();\n\n    if (prevItem?.expanded()) {\n      prevItem?.close();\n      this.inputs.activeItem()?.open({first: true});\n    }\n  }\n\n  /** Closes the menubar and refocuses the root menu bar item. */\n  close() {\n    this.inputs.activeItem()?.close({refocus: this.isFocused()});\n  }\n}\n\n/** The menu trigger ui pattern class. */\nexport class MenuTriggerPattern<V> {\n  /** Whether the menu is expanded. */\n  expanded = signal(false);\n\n  /** The role of the menu trigger. */\n  role = () => 'button';\n\n  /** Whether the menu trigger has a popup. */\n  hasPopup = () => true;\n\n  /** The menu associated with the trigger. */\n  menu: SignalLike<MenuPattern<V> | undefined>;\n\n  /** The tab index of the menu trigger. */\n  tabIndex = computed(() => (this.expanded() && this.menu()?.inputs.activeItem() ? -1 : 0));\n\n  /** Handles keyboard events for the menu trigger. */\n  keydownManager = computed(() => {\n    return new KeyboardEventManager()\n      .on(' ', () => this.open({first: true}))\n      .on('Enter', () => this.open({first: true}))\n      .on('ArrowDown', () => this.open({first: true}))\n      .on('ArrowUp', () => this.open({last: true}))\n      .on('Escape', () => this.close({refocus: true}));\n  });\n\n  constructor(readonly inputs: MenuTriggerInputs<V>) {\n    this.menu = this.inputs.menu;\n  }\n\n  /** Handles keyboard events for the menu trigger. */\n  onKeydown(event: KeyboardEvent) {\n    this.keydownManager().handle(event);\n  }\n\n  /** Handles click events for the menu trigger. */\n  onClick() {\n    this.expanded() ? this.close() : this.open({first: true});\n  }\n\n  /** Handles focusout events for the menu trigger. */\n  onFocusOut(event: FocusEvent) {\n    const element = this.inputs.element();\n    const relatedTarget = event.relatedTarget as Node | null;\n\n    if (\n      this.expanded() &&\n      !element?.contains(relatedTarget) &&\n      !this.inputs.menu()?.inputs.element()?.contains(relatedTarget)\n    ) {\n      this.close();\n    }\n  }\n\n  /** Opens the menu. */\n  open(opts?: {first?: boolean; last?: boolean}) {\n    this.expanded.set(true);\n\n    if (opts?.first) {\n      this.inputs.menu()?.first();\n    } else if (opts?.last) {\n      this.inputs.menu()?.last();\n    }\n  }\n\n  /** Closes the menu. */\n  close(opts: {refocus?: boolean} = {}) {\n    this.expanded.set(false);\n    this.menu()?.listBehavior.unfocus();\n\n    if (opts.refocus) {\n      this.inputs.element()?.focus();\n    }\n\n    let menuitems = this.inputs.menu()?.inputs.items() ?? [];\n\n    while (menuitems.length) {\n      const menuitem = menuitems.pop();\n      menuitem?._expanded.set(false);\n      menuitem?.inputs.parent()?.listBehavior.unfocus();\n      menuitems = menuitems.concat(menuitem?.submenu()?.inputs.items() ?? []);\n    }\n  }\n}\n\n/** The menu item ui pattern class. */\nexport class MenuItemPattern<V> implements ListItem<V> {\n  /** The value of the menu item. */\n  value: SignalLike<V>;\n\n  /** The unique ID of the menu item. */\n  id: SignalLike<string>;\n\n  /** Whether the menu item is disabled. */\n  disabled: SignalLike<boolean>;\n\n  /** The search term for the menu item. */\n  searchTerm: SignalLike<string>;\n\n  /** The element of the menu item. */\n  element: SignalLike<HTMLElement | undefined>;\n\n  /** Whether the menu item is active. */\n  isActive = computed(() => this.inputs.parent()?.inputs.activeItem() === this);\n\n  /** The tab index of the menu item. */\n  tabIndex = computed(() => {\n    if (this.submenu() && this.submenu()?.inputs.activeItem()) {\n      return -1;\n    }\n    return this.inputs.parent()?.listBehavior.getItemTabindex(this) ?? -1;\n  });\n\n  /** The position of the menu item in the menu. */\n  index = computed(() => this.inputs.parent()?.inputs.items().indexOf(this) ?? -1);\n\n  /** Whether the menu item is expanded. */\n  expanded = computed(() => (this.submenu() ? this._expanded() : null));\n\n  /** Whether the menu item is expanded. */\n  _expanded = signal(false);\n\n  /** The ID of the menu that the menu item controls. */\n  controls = signal<string | undefined>(undefined);\n\n  /** The role of the menu item. */\n  role = () => 'menuitem';\n\n  /** Whether the menu item has a popup. */\n  hasPopup = computed(() => !!this.submenu());\n\n  /** The submenu associated with the menu item. */\n  submenu: SignalLike<MenuPattern<V> | undefined>;\n\n  /** Whether the menu item is selectable. */\n  selectable: SignalLike<boolean>;\n\n  constructor(readonly inputs: MenuItemInputs<V>) {\n    this.id = inputs.id;\n    this.value = inputs.value;\n    this.element = inputs.element;\n    this.disabled = inputs.disabled;\n    this.submenu = this.inputs.submenu;\n    this.searchTerm = inputs.searchTerm;\n    this.selectable = computed(() => !this.submenu());\n  }\n\n  /** Opens the submenu. */\n  open(opts?: {first?: boolean; last?: boolean}) {\n    this._expanded.set(true);\n\n    if (opts?.first) {\n      this.submenu()?.first();\n    }\n    if (opts?.last) {\n      this.submenu()?.last();\n    }\n  }\n\n  /** Closes the submenu. */\n  close(opts: {refocus?: boolean} = {}) {\n    this._expanded.set(false);\n\n    if (opts.refocus) {\n      this.inputs.parent()?.listBehavior.goto(this);\n    }\n\n    let menuitems = this.inputs.submenu()?.inputs.items() ?? [];\n\n    while (menuitems.length) {\n      const menuitem = menuitems.pop();\n      menuitem?._expanded.set(false);\n      menuitem?.inputs.parent()?.listBehavior.unfocus();\n      menuitems = menuitems.concat(menuitem?.submenu()?.inputs.items() ?? []);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nexport type SignalLike<T> = () => T;\n\nexport interface WritableSignalLike<T> extends SignalLike<T> {\n  set(value: T): void;\n  update(updateFn: (value: T) => T): void;\n}\n\n/** Converts a getter setter style signal to a WritableSignalLike. */\nexport function convertGetterSetterToWritableSignalLike<T>(\n  getter: () => T,\n  setter: (v: T) => void,\n): WritableSignalLike<T> {\n  // tslint:disable-next-line:ban Have to use `Object.assign` to preserve the getter function.\n  return Object.assign(getter, {\n    set: setter,\n    update: (updateCallback: (v: T) => T) => setter(updateCallback(getter())),\n  });\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {computed} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../signal-like/signal-like';\n\n/** Represents an item that can be expanded or collapsed. */\nexport interface ExpansionItem {\n  /** Whether the item is expandable. */\n  expandable: SignalLike<boolean>;\n\n  /** Used to uniquely identify an expansion item. */\n  expansionId: SignalLike<string>;\n\n  /** Whether the expansion is disabled. */\n  disabled: SignalLike<boolean>;\n}\n\nexport interface ExpansionControl extends ExpansionItem {}\n/**\n * Controls a single item's expansion state and interactions,\n * delegating actual state changes to an Expansion manager.\n */\nexport class ExpansionControl {\n  /** Whether this specific item is currently expanded. Derived from the Expansion manager. */\n  readonly isExpanded = computed(() => this.inputs.expansionManager.isExpanded(this));\n\n  /** Whether this item can be expanded. */\n  readonly isExpandable = computed(() => this.inputs.expansionManager.isExpandable(this));\n\n  constructor(readonly inputs: ExpansionItem & {expansionManager: ListExpansion}) {\n    this.expansionId = inputs.expansionId;\n    this.expandable = inputs.expandable;\n    this.disabled = inputs.disabled;\n  }\n\n  /** Requests the Expansion manager to open this item. */\n  open() {\n    this.inputs.expansionManager.open(this);\n  }\n\n  /** Requests the Expansion manager to close this item. */\n  close() {\n    this.inputs.expansionManager.close(this);\n  }\n\n  /** Requests the Expansion manager to toggle this item. */\n  toggle() {\n    this.inputs.expansionManager.toggle(this);\n  }\n}\n\n/** Represents the required inputs for an expansion behavior. */\nexport interface ListExpansionInputs {\n  /** Whether multiple items can be expanded at once. */\n  multiExpandable: SignalLike<boolean>;\n\n  /** An array of ids of the currently expanded items. */\n  expandedIds: WritableSignalLike<string[]>;\n\n  /** An array of expansion items. */\n  items: SignalLike<ExpansionItem[]>;\n\n  /** Whether all expansions are disabled. */\n  disabled: SignalLike<boolean>;\n}\n\n/** Manages the expansion state of a list of items. */\nexport class ListExpansion {\n  /** A signal holding an array of ids of the currently expanded items. */\n  expandedIds: WritableSignalLike<string[]>;\n\n  constructor(readonly inputs: ListExpansionInputs) {\n    this.expandedIds = inputs.expandedIds;\n  }\n\n  /** Opens the specified item. */\n  open(item: ExpansionItem) {\n    if (!this.isExpandable(item)) return;\n    if (this.isExpanded(item)) return;\n    if (!this.inputs.multiExpandable()) {\n      this.closeAll();\n    }\n    this.expandedIds.update(ids => ids.concat(item.expansionId()));\n  }\n\n  /** Closes the specified item. */\n  close(item: ExpansionItem) {\n    if (this.isExpandable(item)) {\n      this.expandedIds.update(ids => ids.filter(id => id !== item.expansionId()));\n    }\n  }\n\n  /** Toggles the expansion state of the specified item. */\n  toggle(item: ExpansionItem) {\n    this.expandedIds().includes(item.expansionId()) ? this.close(item) : this.open(item);\n  }\n\n  /** Opens all focusable items in the list. */\n  openAll() {\n    if (this.inputs.multiExpandable()) {\n      for (const item of this.inputs.items()) {\n        this.open(item);\n      }\n    }\n  }\n\n  /** Closes all focusable items in the list. */\n  closeAll() {\n    for (const item of this.inputs.items()) {\n      this.close(item);\n    }\n  }\n\n  /** Checks whether the specified item is expandable / collapsible. */\n  isExpandable(item: ExpansionItem) {\n    return !this.inputs.disabled() && !item.disabled() && item.expandable();\n  }\n\n  /** Checks whether the specified item is currently expanded. */\n  isExpanded(item: ExpansionItem): boolean {\n    return this.expandedIds().includes(item.expansionId());\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\nimport {computed} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\n\n/** Represents the required inputs for the label control. */\nexport interface LabelControlInputs {\n  /** The default `aria-labelledby` ids. */\n  defaultLabelledBy: SignalLike<string[]>;\n}\n\n/** Represents the optional inputs for the label control. */\nexport interface LabelControlOptionalInputs {\n  /** The `aria-label`. */\n  label?: SignalLike<string | undefined>;\n\n  /** The user-provided `aria-labelledby` ids. */\n  labelledBy?: SignalLike<string[]>;\n}\n\n/** Controls label and description of an element. */\nexport class LabelControl {\n  /** The `aria-label`. */\n  readonly label = computed(() => this.inputs.label?.());\n\n  /** The `aria-labelledby` ids. */\n  readonly labelledBy = computed(() => {\n    const label = this.label();\n    const labelledBy = this.inputs.labelledBy?.();\n    const defaultLabelledBy = this.inputs.defaultLabelledBy();\n\n    if (labelledBy && labelledBy.length > 0) {\n      return labelledBy;\n    }\n\n    // If an aria-label is provided by developers, do not set aria-labelledby with the\n    // defaultLabelledBy value because if both attributes are set, aria-labelledby will be used.\n    if (label) {\n      return [];\n    }\n\n    return defaultLabelledBy;\n  });\n\n  constructor(readonly inputs: LabelControlInputs & LabelControlOptionalInputs) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {KeyboardEventManager, PointerEventManager} from '../behaviors/event-manager';\nimport {\n  ExpansionItem,\n  ExpansionControl,\n  ListExpansionInputs,\n  ListExpansion,\n} from '../behaviors/expansion/expansion';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport {LabelControl, LabelControlOptionalInputs} from '../behaviors/label/label';\nimport {List, ListInputs, ListItem} from '../behaviors/list/list';\n\n/** The required inputs to tabs. */\nexport interface TabInputs\n  extends Omit<ListItem<string>, 'searchTerm' | 'index' | 'selectable'>,\n    Omit<ExpansionItem, 'expansionId' | 'expandable'> {\n  /** The parent tablist that controls the tab. */\n  tablist: SignalLike<TabListPattern>;\n\n  /** The remote tabpanel controlled by the tab. */\n  tabpanel: SignalLike<TabPanelPattern | undefined>;\n}\n\n/** A tab in a tablist. */\nexport class TabPattern {\n  /** Controls expansion for this tab. */\n  readonly expansion: ExpansionControl;\n\n  /** A global unique identifier for the tab. */\n  readonly id: SignalLike<string>;\n\n  /** The index of the tab. */\n  readonly index = computed(() => this.inputs.tablist().inputs.items().indexOf(this));\n\n  /** A local unique identifier for the tab. */\n  readonly value: SignalLike<string>;\n\n  /** Whether the tab is disabled. */\n  readonly disabled: SignalLike<boolean>;\n\n  /** The html element that should receive focus. */\n  readonly element: SignalLike<HTMLElement | undefined>;\n\n  /** Whether the tab is selectable. */\n  readonly selectable = () => true;\n\n  /** The text used by the typeahead search. */\n  readonly searchTerm = () => ''; // Unused because tabs do not support typeahead.\n\n  /** Whether this tab has expandable content. */\n  readonly expandable = computed(() => this.expansion.expandable());\n\n  /** The unique identifier used by the expansion behavior. */\n  readonly expansionId = computed(() => this.expansion.expansionId());\n\n  /** Whether the tab is expanded. */\n  readonly expanded = computed(() => this.expansion.isExpanded());\n\n  /** Whether the tab is active. */\n  readonly active = computed(() => this.inputs.tablist().inputs.activeItem() === this);\n\n  /** Whether the tab is selected. */\n  readonly selected = computed(() => !!this.inputs.tablist().inputs.value().includes(this.value()));\n\n  /** The tab index of the tab. */\n  readonly tabIndex = computed(() => this.inputs.tablist().listBehavior.getItemTabindex(this));\n\n  /** The id of the tabpanel associated with the tab. */\n  readonly controls = computed(() => this.inputs.tabpanel()?.id());\n\n  constructor(readonly inputs: TabInputs) {\n    this.id = inputs.id;\n    this.value = inputs.value;\n    this.disabled = inputs.disabled;\n    this.element = inputs.element;\n    this.expansion = new ExpansionControl({\n      ...inputs,\n      expansionId: inputs.value,\n      expandable: () => true,\n      expansionManager: inputs.tablist().expansionManager,\n    });\n  }\n}\n\n/** The required inputs for the tabpanel. */\nexport interface TabPanelInputs extends LabelControlOptionalInputs {\n  id: SignalLike<string>;\n  tab: SignalLike<TabPattern | undefined>;\n  value: SignalLike<string>;\n}\n\n/** A tabpanel associated with a tab. */\nexport class TabPanelPattern {\n  /** A global unique identifier for the tabpanel. */\n  readonly id: SignalLike<string>;\n\n  /** A local unique identifier for the tabpanel. */\n  readonly value: SignalLike<string>;\n\n  /** Controls label for this tabpanel. */\n  readonly labelManager: LabelControl;\n\n  /** Whether the tabpanel is hidden. */\n  readonly hidden = computed(() => this.inputs.tab()?.expanded() === false);\n\n  /** The tab index of this tabpanel. */\n  readonly tabIndex = computed(() => (this.hidden() ? -1 : 0));\n\n  /** The aria-labelledby value for this tabpanel. */\n  readonly labelledBy = computed(() =>\n    this.labelManager.labelledBy().length > 0\n      ? this.labelManager.labelledBy().join(' ')\n      : undefined,\n  );\n\n  constructor(readonly inputs: TabPanelInputs) {\n    this.id = inputs.id;\n    this.value = inputs.value;\n    this.labelManager = new LabelControl({\n      ...inputs,\n      defaultLabelledBy: computed(() => (this.inputs.tab() ? [this.inputs.tab()!.id()] : [])),\n    });\n  }\n}\n\n/** The required inputs for the tablist. */\nexport type TabListInputs = Omit<ListInputs<TabPattern, string>, 'multi' | 'typeaheadDelay'> &\n  Omit<ListExpansionInputs, 'multiExpandable' | 'expandedIds' | 'items'>;\n\n/** Controls the state of a tablist. */\nexport class TabListPattern {\n  /** The list behavior for the tablist. */\n  readonly listBehavior: List<TabPattern, string>;\n\n  /** Controls expansion for the tablist. */\n  readonly expansionManager: ListExpansion;\n\n  /** Whether the tablist is vertically or horizontally oriented. */\n  readonly orientation: SignalLike<'vertical' | 'horizontal'>;\n\n  /** Whether the tablist is disabled. */\n  readonly disabled: SignalLike<boolean>;\n\n  /** The tab index of the tablist. */\n  readonly tabIndex = computed(() => this.listBehavior.tabIndex());\n\n  /** The id of the current active tab. */\n  readonly activeDescendant = computed(() => this.listBehavior.activeDescendant());\n\n  /** Whether selection should follow focus. */\n  readonly followFocus = computed(() => this.inputs.selectionMode() === 'follow');\n\n  /** The key used to navigate to the previous tab in the tablist. */\n  readonly prevKey = computed(() => {\n    if (this.inputs.orientation() === 'vertical') {\n      return 'ArrowUp';\n    }\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n  });\n\n  /** The key used to navigate to the next item in the list. */\n  readonly nextKey = computed(() => {\n    if (this.inputs.orientation() === 'vertical') {\n      return 'ArrowDown';\n    }\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowLeft' : 'ArrowRight';\n  });\n\n  /** The keydown event manager for the tablist. */\n  readonly keydown = computed(() => {\n    return new KeyboardEventManager()\n      .on(this.prevKey, () => this.listBehavior.prev({select: this.followFocus()}))\n      .on(this.nextKey, () => this.listBehavior.next({select: this.followFocus()}))\n      .on('Home', () => this.listBehavior.first({select: this.followFocus()}))\n      .on('End', () => this.listBehavior.last({select: this.followFocus()}))\n      .on(' ', () => this.listBehavior.select())\n      .on('Enter', () => this.listBehavior.select());\n  });\n\n  /** The pointerdown event manager for the tablist. */\n  readonly pointerdown = computed(() => {\n    return new PointerEventManager().on(e =>\n      this.listBehavior.goto(this._getItem(e)!, {select: true}),\n    );\n  });\n\n  constructor(readonly inputs: TabListInputs) {\n    this.disabled = inputs.disabled;\n    this.orientation = inputs.orientation;\n\n    this.listBehavior = new List({\n      ...inputs,\n      multi: () => false,\n      typeaheadDelay: () => 0, // Tabs do not support typeahead.\n    });\n\n    this.expansionManager = new ListExpansion({\n      ...inputs,\n      multiExpandable: () => false,\n      expandedIds: this.inputs.value,\n    });\n  }\n\n  /**\n   * Sets the tablist to its default initial state.\n   *\n   * Sets the active index of the tablist to the first focusable selected\n   * tab if one exists. Otherwise, sets focus to the first focusable tab.\n   *\n   * This method should be called once the tablist and its tabs are properly initialized.\n   */\n  setDefaultState() {\n    let firstItem: TabPattern | undefined;\n\n    for (const item of this.inputs.items()) {\n      if (!this.listBehavior.isFocusable(item)) continue;\n\n      if (firstItem === undefined) {\n        firstItem = item;\n      }\n\n      if (item.selected()) {\n        this.inputs.activeItem.set(item);\n        return;\n      }\n    }\n    if (firstItem !== undefined) {\n      this.inputs.activeItem.set(firstItem);\n    }\n  }\n\n  /** Handles keydown events for the tablist. */\n  onKeydown(event: KeyboardEvent) {\n    if (!this.disabled()) {\n      this.keydown().handle(event);\n    }\n  }\n\n  /** The pointerdown event manager for the tablist. */\n  onPointerdown(event: PointerEvent) {\n    if (!this.disabled()) {\n      this.pointerdown().handle(event);\n    }\n  }\n\n  /** Returns the tab item associated with the given pointer event. */\n  private _getItem(e: PointerEvent) {\n    if (!(e.target instanceof HTMLElement)) {\n      return;\n    }\n\n    const element = e.target.closest('[role=\"tab\"]');\n    return this.inputs.items().find(i => i.element() === element);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport {KeyboardEventManager} from '../behaviors/event-manager';\nimport {List, ListInputs} from '../behaviors/list/list';\nimport {ToolbarWidgetPattern} from './toolbar-widget';\n\n/** Represents the required inputs for a toolbar. */\nexport type ToolbarInputs<V> = Omit<\n  ListInputs<ToolbarWidgetPattern<V>, V>,\n  'multi' | 'typeaheadDelay' | 'value' | 'selectionMode' | 'focusMode'\n> & {\n  /** A function that returns the toolbar item associated with a given element. */\n  getItem: (e: Element) => ToolbarWidgetPattern<V> | undefined;\n};\n\n/** Controls the state of a toolbar. */\nexport class ToolbarPattern<V> {\n  /** The list behavior for the toolbar. */\n  readonly listBehavior: List<ToolbarWidgetPattern<V>, V>;\n\n  /** Whether the tablist is vertically or horizontally oriented. */\n  readonly orientation: SignalLike<'vertical' | 'horizontal'>;\n\n  /** Whether disabled items in the group should be focusable. */\n  readonly softDisabled: SignalLike<boolean>;\n\n  /** Whether the toolbar is disabled. */\n  readonly disabled = computed(() => this.listBehavior.disabled());\n\n  /** The tab index of the toolbar (if using activedescendant). */\n  readonly tabIndex = computed(() => this.listBehavior.tabIndex());\n\n  /** The id of the current active widget (if using activedescendant). */\n  readonly activeDescendant = computed(() => this.listBehavior.activeDescendant());\n\n  /** The currently active item in the toolbar. */\n  readonly activeItem = () => this.listBehavior.inputs.activeItem();\n\n  /** The key used to navigate to the previous widget. */\n  private readonly _prevKey = computed(() => {\n    if (this.inputs.orientation() === 'vertical') {\n      return 'ArrowUp';\n    }\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n  });\n\n  /** The key used to navigate to the next widget. */\n  private readonly _nextKey = computed(() => {\n    if (this.inputs.orientation() === 'vertical') {\n      return 'ArrowDown';\n    }\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowLeft' : 'ArrowRight';\n  });\n\n  /** The alternate key used to navigate to the previous widget. */\n  private readonly _altPrevKey = computed(() => {\n    if (this.inputs.orientation() === 'vertical') {\n      return this.inputs.textDirection() === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n    }\n    return 'ArrowUp';\n  });\n\n  /** The alternate key used to navigate to the next widget. */\n  private readonly _altNextKey = computed(() => {\n    if (this.inputs.orientation() === 'vertical') {\n      return this.inputs.textDirection() === 'rtl' ? 'ArrowLeft' : 'ArrowRight';\n    }\n    return 'ArrowDown';\n  });\n\n  /** The keydown event manager for the toolbar. */\n  private readonly _keydown = computed(() => {\n    const manager = new KeyboardEventManager();\n\n    return manager\n      .on(this._nextKey, () => this.listBehavior.next())\n      .on(this._prevKey, () => this.listBehavior.prev())\n      .on(this._altNextKey, () => this._groupNext())\n      .on(this._altPrevKey, () => this._groupPrev())\n      .on(' ', () => this.select())\n      .on('Enter', () => this.select())\n      .on('Home', () => this.listBehavior.first())\n      .on('End', () => this.listBehavior.last());\n  });\n\n  /** Navigates to the next widget in a widget group. */\n  private _groupNext() {\n    const currGroup = this.inputs.activeItem()?.group();\n    const nextGroup = this.listBehavior.navigationBehavior.peekNext()?.group();\n\n    if (!currGroup) {\n      return;\n    }\n\n    if (currGroup !== nextGroup) {\n      this.listBehavior.goto(\n        this.listBehavior.navigationBehavior.peekFirst(currGroup.inputs.items())!,\n      );\n\n      return;\n    }\n\n    this.listBehavior.next();\n  }\n\n  /** Navigates to the previous widget in a widget group. */\n  private _groupPrev() {\n    const currGroup = this.inputs.activeItem()?.group();\n    const nextGroup = this.listBehavior.navigationBehavior.peekPrev()?.group();\n\n    if (!currGroup) {\n      return;\n    }\n\n    if (currGroup !== nextGroup) {\n      this.listBehavior.goto(\n        this.listBehavior.navigationBehavior.peekLast(currGroup.inputs.items())!,\n      );\n\n      return;\n    }\n\n    this.listBehavior.prev();\n  }\n\n  /** Navigates to the widget targeted by a pointer event. */\n  private _goto(e: MouseEvent) {\n    const item = this.inputs.getItem(e.target as Element);\n\n    if (item) {\n      this.listBehavior.goto(item);\n      this.select();\n    }\n  }\n\n  select() {\n    const group = this.inputs.activeItem()?.group();\n\n    if (!group?.multi()) {\n      group?.inputs.items().forEach(i => this.listBehavior.deselect(i));\n    }\n\n    this.listBehavior.toggle();\n  }\n\n  constructor(readonly inputs: ToolbarInputs<V>) {\n    this.orientation = inputs.orientation;\n    this.softDisabled = inputs.softDisabled;\n\n    this.listBehavior = new List({\n      ...inputs,\n      multi: () => true,\n      focusMode: () => 'roving',\n      selectionMode: () => 'explicit',\n      value: signal([] as V[]),\n      typeaheadDelay: () => 0, // Toolbar widgets do not support typeahead.\n    });\n  }\n\n  /** Handles keydown events for the toolbar. */\n  onKeydown(event: KeyboardEvent) {\n    if (this.disabled()) return;\n    this._keydown().handle(event);\n  }\n\n  onPointerdown(event: PointerEvent) {\n    event.preventDefault();\n  }\n\n  /** Handles click events for the toolbar. */\n  onClick(event: MouseEvent) {\n    if (this.disabled()) return;\n    this._goto(event);\n  }\n\n  /**\n   * Sets the toolbar to its default initial state.\n   *\n   * Sets the active index to the selected widget if one exists and is focusable.\n   * Otherwise, sets the active index to the first focusable widget.\n   */\n  setDefaultState() {\n    const firstItem = this.listBehavior.navigationBehavior.peekFirst(this.inputs.items());\n\n    if (firstItem) {\n      this.inputs.activeItem.set(firstItem);\n    }\n  }\n\n  /** Validates the state of the toolbar and returns a list of accessibility violations. */\n  validate(): string[] {\n    const violations: string[] = [];\n    return violations;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport {ListItem} from '../behaviors/list/list';\nimport type {ToolbarPattern} from './toolbar';\nimport {ToolbarWidgetGroupPattern} from './toolbar-widget-group';\n\n/** Represents the required inputs for a toolbar widget in a toolbar. */\nexport interface ToolbarWidgetInputs<V>\n  extends Omit<ListItem<V>, 'searchTerm' | 'index' | 'selectable'> {\n  /** A reference to the parent toolbar. */\n  toolbar: SignalLike<ToolbarPattern<V>>;\n\n  /** A reference to the parent widget group. */\n  group: SignalLike<ToolbarWidgetGroupPattern<ToolbarWidgetPattern<V>, V> | undefined>;\n}\n\nexport class ToolbarWidgetPattern<V> implements ListItem<V> {\n  /** A unique identifier for the widget. */\n  readonly id = () => this.inputs.id();\n\n  /** The html element that should receive focus. */\n  readonly element = () => this.inputs.element();\n\n  /** Whether the widget is disabled. */\n  readonly disabled = () => this.inputs.disabled() || this.group()?.disabled() || false;\n\n  /** A reference to the parent toolbar. */\n  readonly group = () => this.inputs.group();\n\n  /** A reference to the toolbar containing the widget. */\n  readonly toolbar = () => this.inputs.toolbar();\n\n  /** The tabindex of the widget. */\n  readonly tabIndex = computed(() => this.toolbar().listBehavior.getItemTabindex(this));\n\n  /** The text used by the typeahead search. */\n  readonly searchTerm = () => ''; // Unused because toolbar does not support typeahead.\n\n  /** The value associated with the widget. */\n  readonly value = () => this.inputs.value();\n\n  /** Whether the widget is selectable. */\n  readonly selectable = () => true; // Unused because toolbar does not support selection.\n\n  /** The position of the widget within the toolbar. */\n  readonly index = computed(() => this.toolbar().inputs.items().indexOf(this) ?? -1);\n\n  /** Whether the widget is selected (only relevant in a selection group). */\n  readonly selected = computed(() =>\n    this.toolbar().listBehavior.inputs.value().includes(this.value()),\n  );\n\n  /** Whether the widget is currently the active one (focused). */\n  readonly active: SignalLike<boolean> = computed(() => this.toolbar().activeItem() === this);\n\n  constructor(readonly inputs: ToolbarWidgetInputs<V>) {}\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {KeyboardEventManager, PointerEventManager} from '../behaviors/event-manager';\nimport {\n  ExpansionItem,\n  ExpansionControl,\n  ListExpansion,\n  ListExpansionInputs,\n} from '../behaviors/expansion/expansion';\nimport {ListFocus, ListFocusInputs, ListFocusItem} from '../behaviors/list-focus/list-focus';\nimport {\n  ListNavigation,\n  ListNavigationInputs,\n  ListNavigationItem,\n} from '../behaviors/list-navigation/list-navigation';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\n\n/** Inputs of the AccordionGroupPattern. */\nexport type AccordionGroupInputs = Omit<\n  ListNavigationInputs<AccordionTriggerPattern> &\n    ListFocusInputs<AccordionTriggerPattern> &\n    Omit<ListExpansionInputs, 'items'>,\n  'focusMode'\n>;\n\nconst focusMode = () => 'roving' as const;\n\nexport interface AccordionGroupPattern extends AccordionGroupInputs {}\n/** A pattern controls the nested Accordions. */\nexport class AccordionGroupPattern {\n  /** Controls navigation for the group. */\n  navigation: ListNavigation<AccordionTriggerPattern>;\n\n  /** Controls focus for the group. */\n  focusManager: ListFocus<AccordionTriggerPattern>;\n\n  /** Controls expansion for the group. */\n  expansionManager: ListExpansion;\n\n  constructor(readonly inputs: AccordionGroupInputs) {\n    this.wrap = inputs.wrap;\n    this.orientation = inputs.orientation;\n    this.textDirection = inputs.textDirection;\n    this.activeItem = inputs.activeItem;\n    this.disabled = inputs.disabled;\n    this.multiExpandable = inputs.multiExpandable;\n    this.items = inputs.items;\n    this.expandedIds = inputs.expandedIds;\n    this.softDisabled = inputs.softDisabled;\n    this.focusManager = new ListFocus({\n      ...inputs,\n      focusMode,\n    });\n    this.navigation = new ListNavigation({\n      ...inputs,\n      focusMode,\n      focusManager: this.focusManager,\n    });\n    this.expansionManager = new ListExpansion({\n      ...inputs,\n    });\n  }\n}\n\n/** Inputs for the AccordionTriggerPattern. */\nexport type AccordionTriggerInputs = Omit<ListNavigationItem & ListFocusItem, 'index'> &\n  Omit<ExpansionItem, 'expansionId' | 'expandable'> & {\n    /** A local unique identifier for the trigger. */\n    value: SignalLike<string>;\n\n    /** The parent accordion group that controls this trigger. */\n    accordionGroup: SignalLike<AccordionGroupPattern>;\n\n    /** The accordion panel controlled by this trigger. */\n    accordionPanel: SignalLike<AccordionPanelPattern | undefined>;\n  };\n\nexport interface AccordionTriggerPattern extends AccordionTriggerInputs {}\n/** A pattern controls the expansion state of an accordion. */\nexport class AccordionTriggerPattern {\n  /** Whether this tab has expandable content. */\n  expandable: SignalLike<boolean>;\n\n  /** The unique identifier used by the expansion behavior. */\n  expansionId: SignalLike<string>;\n\n  /** Whether an accordion is expanded. */\n  expanded: SignalLike<boolean>;\n\n  /** Controls the expansion state for the trigger. */\n  expansionControl: ExpansionControl;\n\n  /** Whether the trigger is active. */\n  active = computed(() => this.inputs.accordionGroup().activeItem() === this);\n\n  /** Id of the accordion panel controlled by the trigger. */\n  controls = computed(() => this.inputs.accordionPanel()?.id());\n\n  /** The tab index of the trigger. */\n  tabIndex = computed(() => (this.inputs.accordionGroup().focusManager.isFocusable(this) ? 0 : -1));\n\n  /** Whether the trigger is disabled. Disabling an accordion group disables all the triggers. */\n  disabled = computed(() => this.inputs.disabled() || this.inputs.accordionGroup().disabled());\n\n  /** The index of the trigger within its accordion group. */\n  index = computed(() => this.inputs.accordionGroup().items().indexOf(this));\n\n  constructor(readonly inputs: AccordionTriggerInputs) {\n    this.id = inputs.id;\n    this.element = inputs.element;\n    this.value = inputs.value;\n    this.expansionControl = new ExpansionControl({\n      ...inputs,\n      expansionId: inputs.value,\n      expandable: () => true,\n      expansionManager: inputs.accordionGroup().expansionManager,\n    });\n    this.expandable = this.expansionControl.isExpandable;\n    this.expansionId = this.expansionControl.expansionId;\n    this.expanded = this.expansionControl.isExpanded;\n  }\n\n  /** The key used to navigate to the previous accordion trigger. */\n  prevKey = computed(() => {\n    if (this.inputs.accordionGroup().orientation() === 'vertical') {\n      return 'ArrowUp';\n    }\n    return this.inputs.accordionGroup().textDirection() === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n  });\n\n  /** The key used to navigate to the next accordion trigger. */\n  nextKey = computed(() => {\n    if (this.inputs.accordionGroup().orientation() === 'vertical') {\n      return 'ArrowDown';\n    }\n    return this.inputs.accordionGroup().textDirection() === 'rtl' ? 'ArrowLeft' : 'ArrowRight';\n  });\n\n  /** The keydown event manager for the accordion trigger. */\n  keydown = computed(() => {\n    return new KeyboardEventManager()\n      .on(this.prevKey, () => this.inputs.accordionGroup().navigation.prev())\n      .on(this.nextKey, () => this.inputs.accordionGroup().navigation.next())\n      .on('Home', () => this.inputs.accordionGroup().navigation.first())\n      .on('End', () => this.inputs.accordionGroup().navigation.last())\n      .on(' ', () => this.expansionControl.toggle())\n      .on('Enter', () => this.expansionControl.toggle());\n  });\n\n  /** The pointerdown event manager for the accordion trigger. */\n  pointerdown = computed(() => {\n    return new PointerEventManager().on(e => {\n      const item = this._getItem(e);\n\n      if (item) {\n        this.inputs.accordionGroup().navigation.goto(item);\n        this.expansionControl.toggle();\n      }\n    });\n  });\n\n  /** Handles keydown events on the trigger, delegating to the group if not disabled. */\n  onKeydown(event: KeyboardEvent): void {\n    this.keydown().handle(event);\n  }\n\n  /** Handles pointerdown events on the trigger, delegating to the group if not disabled. */\n  onPointerdown(event: PointerEvent): void {\n    this.pointerdown().handle(event);\n  }\n\n  /** Handles focus events on the trigger. This ensures the tabbing changes the active index. */\n  onFocus(event: FocusEvent): void {\n    const item = this._getItem(event);\n\n    if (item && this.inputs.accordionGroup().focusManager.isFocusable(item)) {\n      this.inputs.accordionGroup().focusManager.focus(item);\n    }\n  }\n\n  private _getItem(e: Event) {\n    if (!(e.target instanceof HTMLElement)) {\n      return;\n    }\n\n    const element = e.target.closest('[role=\"button\"]');\n    return this.inputs\n      .accordionGroup()\n      .items()\n      .find(i => i.element() === element);\n  }\n}\n\n/** Represents the required inputs for the AccordionPanelPattern. */\nexport interface AccordionPanelInputs {\n  /** A global unique identifier for the panel. */\n  id: SignalLike<string>;\n\n  /** A local unique identifier for the panel, matching its trigger's value. */\n  value: SignalLike<string>;\n\n  /** The parent accordion trigger that controls this panel. */\n  accordionTrigger: SignalLike<AccordionTriggerPattern | undefined>;\n}\n\nexport interface AccordionPanelPattern extends AccordionPanelInputs {}\n/** Represents an accordion panel. */\nexport class AccordionPanelPattern {\n  /** Whether the accordion panel is hidden. True if the associated trigger is not expanded. */\n  hidden: SignalLike<boolean>;\n\n  constructor(readonly inputs: AccordionPanelInputs) {\n    this.id = inputs.id;\n    this.value = inputs.value;\n    this.accordionTrigger = inputs.accordionTrigger;\n    this.hidden = computed(() => inputs.accordionTrigger()?.expanded() === false);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../behaviors/signal-like/signal-like';\nimport {List, ListInputs, ListItem} from '../behaviors/list/list';\nimport {ExpansionItem, ExpansionControl, ListExpansion} from '../behaviors/expansion/expansion';\nimport {KeyboardEventManager, PointerEventManager, Modifier} from '../behaviors/event-manager';\n\n/** Represents the required inputs for a tree item. */\nexport interface TreeItemInputs<V> extends Omit<ListItem<V>, 'index'> {\n  /** The parent item. */\n  parent: SignalLike<TreeItemPattern<V> | TreePattern<V>>;\n\n  /** Whether this item has children. Children can be lazily loaded. */\n  hasChildren: SignalLike<boolean>;\n\n  /** The children items. */\n  children: SignalLike<TreeItemPattern<V>[]>;\n\n  /** The tree pattern this item belongs to. */\n  tree: SignalLike<TreePattern<V>>;\n}\n\n/**\n * Represents an item in a Tree.\n */\nexport class TreeItemPattern<V> implements ListItem<V>, ExpansionItem {\n  /** A unique identifier for this item. */\n  readonly id: SignalLike<string>;\n\n  /** The value of this item. */\n  readonly value: SignalLike<V>;\n\n  /** A reference to the item element. */\n  readonly element: SignalLike<HTMLElement | undefined>;\n\n  /** Whether the item is disabled. */\n  readonly disabled: SignalLike<boolean>;\n\n  /** The text used by the typeahead search. */\n  readonly searchTerm: SignalLike<string>;\n\n  /** The tree pattern this item belongs to. */\n  readonly tree: SignalLike<TreePattern<V>>;\n\n  /** The parent item. */\n  readonly parent: SignalLike<TreeItemPattern<V> | TreePattern<V>>;\n\n  /** The children items. */\n  readonly children: SignalLike<TreeItemPattern<V>[]>;\n\n  /** The position of this item among its siblings. */\n  readonly index = computed(() => this.tree().visibleItems().indexOf(this));\n\n  /** The unique identifier used by the expansion behavior. */\n  readonly expansionId: SignalLike<string>;\n\n  /** Controls expansion for child items. */\n  readonly expansionManager: ListExpansion;\n\n  /** Controls expansion for this item. */\n  readonly expansion: ExpansionControl;\n\n  /** Whether the item is expandable. It's expandable if children item exist. */\n  readonly expandable: SignalLike<boolean>;\n\n  /** Whether the item is selectable. */\n  readonly selectable: SignalLike<boolean>;\n\n  /** The level of the current item in a tree. */\n  readonly level: SignalLike<number> = computed(() => this.parent().level() + 1);\n\n  /** Whether this item is currently expanded. */\n  readonly expanded = computed(() => this.expansion.isExpanded());\n\n  /** Whether this item is visible. */\n  readonly visible: SignalLike<boolean> = computed(\n    () => this.parent().expanded() && this.parent().visible(),\n  );\n\n  /** The number of items under the same parent at the same level. */\n  readonly setsize = computed(() => this.parent().children().length);\n\n  /** The position of this item among its siblings (1-based). */\n  readonly posinset = computed(() => this.parent().children().indexOf(this) + 1);\n\n  /** Whether the item is active. */\n  readonly active = computed(() => this.tree().activeItem() === this);\n\n  /** The tab index of the item. */\n  readonly tabIndex = computed(() => this.tree().listBehavior.getItemTabindex(this));\n\n  /** Whether the item is selected. */\n  readonly selected: SignalLike<boolean | undefined> = computed(() => {\n    if (this.tree().nav()) {\n      return undefined;\n    }\n    if (!this.selectable()) {\n      return undefined;\n    }\n    return this.tree().value().includes(this.value());\n  });\n\n  /** The current type of this item. */\n  readonly current: SignalLike<string | undefined> = computed(() => {\n    if (!this.tree().nav()) {\n      return undefined;\n    }\n    if (!this.selectable()) {\n      return undefined;\n    }\n    return this.tree().value().includes(this.value()) ? this.tree().currentType() : undefined;\n  });\n\n  constructor(readonly inputs: TreeItemInputs<V>) {\n    this.id = inputs.id;\n    this.value = inputs.value;\n    this.element = inputs.element;\n    this.disabled = inputs.disabled;\n    this.searchTerm = inputs.searchTerm;\n    this.expansionId = inputs.id;\n    this.tree = inputs.tree;\n    this.parent = inputs.parent;\n    this.children = inputs.children;\n    this.expandable = inputs.hasChildren;\n    this.selectable = inputs.selectable;\n    this.expansion = new ExpansionControl({\n      ...inputs,\n      expandable: this.expandable,\n      expansionId: this.expansionId,\n      expansionManager: this.parent().expansionManager,\n    });\n    this.expansionManager = new ListExpansion({\n      ...inputs,\n      multiExpandable: () => true,\n      // TODO(ok7sai): allow pre-expanded tree items.\n      expandedIds: signal([]),\n      items: this.children,\n      disabled: computed(() => this.tree()?.disabled() ?? false),\n    });\n  }\n}\n\n/** The selection operations that the tree can perform. */\ninterface SelectOptions {\n  toggle?: boolean;\n  selectOne?: boolean;\n  selectRange?: boolean;\n  anchor?: boolean;\n}\n\n/** Represents the required inputs for a tree. */\nexport interface TreeInputs<V> extends Omit<ListInputs<TreeItemPattern<V>, V>, 'items'> {\n  /** A unique identifier for the tree. */\n  id: SignalLike<string>;\n\n  /** All items in the tree, in document order (DFS-like, a flattened list). */\n  allItems: SignalLike<TreeItemPattern<V>[]>;\n\n  /** Whether the tree is in navigation mode. */\n  nav: SignalLike<boolean>;\n\n  /** The aria-current type. */\n  currentType: SignalLike<'page' | 'step' | 'location' | 'date' | 'time' | 'true' | 'false'>;\n}\n\nexport interface TreePattern<V> extends TreeInputs<V> {}\n/** Controls the state and interactions of a tree view. */\nexport class TreePattern<V> {\n  /** The list behavior for the tree. */\n  readonly listBehavior: List<TreeItemPattern<V>, V>;\n\n  /** Controls expansion for direct children of the tree root (top-level items). */\n  readonly expansionManager: ListExpansion;\n\n  /** The root level is 0. */\n  readonly level = () => 0;\n\n  /** The root is always expanded. */\n  readonly expanded = () => true;\n\n  /** The roow is always visible. */\n  readonly visible = () => true;\n\n  /** The tab index of the tree. */\n  readonly tabIndex: SignalLike<-1 | 0> = computed(() => this.listBehavior.tabIndex());\n\n  /** The id of the current active item. */\n  readonly activeDescendant = computed(() => this.listBehavior.activeDescendant());\n\n  /** The direct children of the root (top-level tree items). */\n  readonly children = computed(() =>\n    this.inputs.allItems().filter(item => item.level() === this.level() + 1),\n  );\n\n  /** All currently visible tree items. An item is visible if their parent is expanded. */\n  readonly visibleItems = computed(() => this.inputs.allItems().filter(item => item.visible()));\n\n  /** Whether the tree selection follows focus. */\n  readonly followFocus = computed(() => this.inputs.selectionMode() === 'follow');\n\n  /** The key for navigating to the previous item. */\n  readonly prevKey = computed(() => {\n    if (this.inputs.orientation() === 'vertical') {\n      return 'ArrowUp';\n    }\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n  });\n\n  /** The key for navigating to the next item. */\n  readonly nextKey = computed(() => {\n    if (this.inputs.orientation() === 'vertical') {\n      return 'ArrowDown';\n    }\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowLeft' : 'ArrowRight';\n  });\n\n  /** The key for collapsing an item or moving to its parent. */\n  readonly collapseKey = computed(() => {\n    if (this.inputs.orientation() === 'horizontal') {\n      return 'ArrowUp';\n    }\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowRight' : 'ArrowLeft';\n  });\n\n  /** The key for expanding an item or moving to its first child. */\n  readonly expandKey = computed(() => {\n    if (this.inputs.orientation() === 'horizontal') {\n      return 'ArrowDown';\n    }\n    return this.inputs.textDirection() === 'rtl' ? 'ArrowLeft' : 'ArrowRight';\n  });\n\n  /** Represents the space key. Does nothing when the user is actively using typeahead. */\n  readonly dynamicSpaceKey = computed(() => (this.listBehavior.isTyping() ? '' : ' '));\n\n  /** Regular expression to match characters for typeahead. */\n  readonly typeaheadRegexp = /^.$/;\n\n  /** The keydown event manager for the tree. */\n  readonly keydown = computed(() => {\n    const manager = new KeyboardEventManager();\n    const list = this.listBehavior;\n\n    manager\n      .on(this.prevKey, () => list.prev({selectOne: this.followFocus()}))\n      .on(this.nextKey, () => list.next({selectOne: this.followFocus()}))\n      .on('Home', () => list.first({selectOne: this.followFocus()}))\n      .on('End', () => list.last({selectOne: this.followFocus()}))\n      .on(this.typeaheadRegexp, e => list.search(e.key, {selectOne: this.followFocus()}))\n      .on(this.expandKey, () => this.expand({selectOne: this.followFocus()}))\n      .on(this.collapseKey, () => this.collapse({selectOne: this.followFocus()}))\n      .on(Modifier.Shift, '*', () => this.expandSiblings());\n\n    if (this.inputs.multi()) {\n      manager\n        // TODO: Tracking the anchor by index can break if the\n        // tree is expanded or collapsed causing the index to change.\n        .on(Modifier.Any, 'Shift', () => list.anchor(this.listBehavior.activeIndex()))\n        .on(Modifier.Shift, this.prevKey, () => list.prev({selectRange: true}))\n        .on(Modifier.Shift, this.nextKey, () => list.next({selectRange: true}))\n        .on([Modifier.Ctrl | Modifier.Shift, Modifier.Meta | Modifier.Shift], 'Home', () =>\n          list.first({selectRange: true, anchor: false}),\n        )\n        .on([Modifier.Ctrl | Modifier.Shift, Modifier.Meta | Modifier.Shift], 'End', () =>\n          list.last({selectRange: true, anchor: false}),\n        )\n        .on(Modifier.Shift, 'Enter', () => list.updateSelection({selectRange: true, anchor: false}))\n        .on(Modifier.Shift, this.dynamicSpaceKey, () =>\n          list.updateSelection({selectRange: true, anchor: false}),\n        );\n    }\n\n    if (!this.followFocus() && this.inputs.multi()) {\n      manager\n        .on(this.dynamicSpaceKey, () => list.toggle())\n        .on('Enter', () => list.toggle(), {preventDefault: !this.nav()})\n        .on([Modifier.Ctrl, Modifier.Meta], 'A', () => list.toggleAll());\n    }\n\n    if (!this.followFocus() && !this.inputs.multi()) {\n      manager.on(this.dynamicSpaceKey, () => list.selectOne());\n      manager.on('Enter', () => list.selectOne(), {preventDefault: !this.nav()});\n    }\n\n    if (this.inputs.multi() && this.followFocus()) {\n      manager\n        .on([Modifier.Ctrl, Modifier.Meta], this.prevKey, () => list.prev())\n        .on([Modifier.Ctrl, Modifier.Meta], this.nextKey, () => list.next())\n        .on([Modifier.Ctrl, Modifier.Meta], this.expandKey, () => this.expand())\n        .on([Modifier.Ctrl, Modifier.Meta], this.collapseKey, () => this.collapse())\n        .on([Modifier.Ctrl, Modifier.Meta], ' ', () => list.toggle())\n        .on([Modifier.Ctrl, Modifier.Meta], 'Enter', () => list.toggle())\n        .on([Modifier.Ctrl, Modifier.Meta], 'Home', () => list.first())\n        .on([Modifier.Ctrl, Modifier.Meta], 'End', () => list.last())\n        .on([Modifier.Ctrl, Modifier.Meta], 'A', () => {\n          list.toggleAll();\n          list.select(); // Ensure the currect item remains selected.\n        });\n    }\n\n    return manager;\n  });\n\n  /** The pointerdown event manager for the tree. */\n  pointerdown = computed(() => {\n    const manager = new PointerEventManager();\n\n    if (this.multi()) {\n      manager.on(Modifier.Shift, e => this.goto(e, {selectRange: true}));\n    }\n\n    if (!this.multi()) {\n      return manager.on(e => this.goto(e, {selectOne: true}));\n    }\n\n    if (this.multi() && this.followFocus()) {\n      return manager\n        .on(e => this.goto(e, {selectOne: true}))\n        .on(Modifier.Ctrl, e => this.goto(e, {toggle: true}));\n    }\n\n    if (this.multi() && !this.followFocus()) {\n      return manager.on(e => this.goto(e, {toggle: true}));\n    }\n\n    return manager;\n  });\n\n  /** A unique identifier for the tree. */\n  id: SignalLike<string>;\n\n  /** Whether the tree is in navigation mode. */\n  nav: SignalLike<boolean>;\n\n  /** The aria-current type. */\n  currentType: SignalLike<'page' | 'step' | 'location' | 'date' | 'time' | 'true' | 'false'>;\n\n  /** All items in the tree, in document order (DFS-like, a flattened list). */\n  allItems: SignalLike<TreeItemPattern<V>[]>;\n\n  /** Whether the tree is disabled. */\n  disabled: SignalLike<boolean>;\n\n  /** The currently active item in the tree. */\n  activeItem: WritableSignalLike<TreeItemPattern<V> | undefined> = signal(undefined);\n\n  /** Whether disabled items should be focusable. */\n  softDisabled: SignalLike<boolean>;\n\n  /** Whether the focus should wrap when navigating past the first or last item. */\n  wrap: SignalLike<boolean>;\n\n  /** The orientation of the tree. */\n  orientation: SignalLike<'vertical' | 'horizontal'>;\n\n  /** The text direction of the tree. */\n  textDirection: SignalLike<'ltr' | 'rtl'>;\n\n  /** Whether multiple items can be selected at the same time. */\n  multi: SignalLike<boolean>;\n\n  /** The selection mode of the tree. */\n  selectionMode: SignalLike<'follow' | 'explicit'>;\n\n  /** The delay in milliseconds to wait before clearing the typeahead buffer. */\n  typeaheadDelay: SignalLike<number>;\n\n  /** The current value of the tree (the selected items). */\n  value: WritableSignalLike<V[]>;\n\n  constructor(readonly inputs: TreeInputs<V>) {\n    this.id = inputs.id;\n    this.nav = inputs.nav;\n    this.currentType = inputs.currentType;\n    this.allItems = inputs.allItems;\n    this.focusMode = inputs.focusMode;\n    this.disabled = inputs.disabled;\n    this.activeItem = inputs.activeItem;\n    this.softDisabled = inputs.softDisabled;\n    this.wrap = inputs.wrap;\n    this.orientation = inputs.orientation;\n    this.textDirection = inputs.textDirection;\n    this.multi = computed(() => (this.nav() ? false : this.inputs.multi()));\n    this.selectionMode = inputs.selectionMode;\n    this.typeaheadDelay = inputs.typeaheadDelay;\n    this.value = inputs.value;\n\n    this.listBehavior = new List({\n      ...inputs,\n      items: this.visibleItems,\n      multi: this.multi,\n    });\n\n    this.expansionManager = new ListExpansion({\n      multiExpandable: () => true,\n      // TODO(ok7sai): allow pre-expanded tree items.\n      expandedIds: signal([]),\n      items: this.children,\n      disabled: this.disabled,\n    });\n  }\n\n  /**\n   * Sets the tree to it's default initial state.\n   *\n   * Sets the active index of the tree to the first focusable selected tree item if one exists.\n   * Otherwise, sets focus to the first focusable tree item.\n   */\n  setDefaultState() {\n    let firstItem: TreeItemPattern<V> | undefined;\n\n    for (const item of this.allItems()) {\n      if (!item.visible()) continue;\n      if (!this.listBehavior.isFocusable(item)) continue;\n\n      if (firstItem === undefined) {\n        firstItem = item;\n      }\n\n      if (item.selected()) {\n        this.activeItem.set(item);\n        return;\n      }\n    }\n\n    if (firstItem !== undefined) {\n      this.activeItem.set(firstItem);\n    }\n  }\n\n  /** Handles keydown events on the tree. */\n  onKeydown(event: KeyboardEvent) {\n    if (!this.disabled()) {\n      this.keydown().handle(event);\n    }\n  }\n\n  /** Handles pointerdown events on the tree. */\n  onPointerdown(event: PointerEvent) {\n    if (!this.disabled()) {\n      this.pointerdown().handle(event);\n    }\n  }\n\n  /** Navigates to the given tree item in the tree. */\n  goto(e: PointerEvent, opts?: SelectOptions) {\n    const item = this._getItem(e);\n    if (!item) return;\n\n    this.listBehavior.goto(item, opts);\n    this.toggleExpansion(item);\n  }\n\n  /** Toggles to expand or collapse a tree item. */\n  toggleExpansion(item?: TreeItemPattern<V>) {\n    item ??= this.activeItem();\n    if (!item || !this.listBehavior.isFocusable(item)) return;\n\n    if (!item.expandable()) return;\n    if (item.expanded()) {\n      this.collapse();\n    } else {\n      item.expansion.open();\n    }\n  }\n\n  /** Expands a tree item. */\n  expand(opts?: SelectOptions) {\n    const item = this.activeItem();\n    if (!item || !this.listBehavior.isFocusable(item)) return;\n\n    if (item.expandable() && !item.expanded()) {\n      item.expansion.open();\n    } else if (\n      item.expanded() &&\n      item.children().some(item => this.listBehavior.isFocusable(item))\n    ) {\n      this.listBehavior.next(opts);\n    }\n  }\n\n  /** Expands all sibling tree items including itself. */\n  expandSiblings(item?: TreeItemPattern<V>) {\n    item ??= this.activeItem();\n    const siblings = item?.parent()?.children();\n    siblings?.forEach(item => item.expansion.open());\n  }\n\n  /** Collapses a tree item. */\n  collapse(opts?: SelectOptions) {\n    const item = this.activeItem();\n    if (!item || !this.listBehavior.isFocusable(item)) return;\n\n    if (item.expandable() && item.expanded()) {\n      item.expansion.close();\n    } else if (item.parent() && item.parent() !== this) {\n      const parentItem = item.parent();\n      if (parentItem instanceof TreeItemPattern && this.listBehavior.isFocusable(parentItem)) {\n        this.listBehavior.goto(parentItem, opts);\n      }\n    }\n  }\n\n  /** Retrieves the TreeItemPattern associated with a DOM event, if any. */\n  protected _getItem(event: Event): TreeItemPattern<V> | undefined {\n    if (!(event.target instanceof HTMLElement)) {\n      return;\n    }\n    const element = event.target.closest('[role=\"treeitem\"]');\n    return this.inputs.allItems().find(i => i.element() === element);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {TreeInputs, TreePattern, TreeItemPattern} from './tree';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport {ComboboxPattern, ComboboxTreeControls} from '../combobox/combobox';\n\nexport type ComboboxTreeInputs<V> = TreeInputs<V> & {\n  /** The combobox controlling the tree. */\n  combobox: SignalLike<ComboboxPattern<TreeItemPattern<V>, V> | undefined>;\n};\n\nexport class ComboboxTreePattern<V>\n  extends TreePattern<V>\n  implements ComboboxTreeControls<TreeItemPattern<V>, V>\n{\n  /** Whether the currently focused item is collapsible. */\n  isItemCollapsible = () => this.inputs.activeItem()?.parent() instanceof TreeItemPattern;\n\n  /** The ARIA role for the tree. */\n  role = () => 'tree' as const;\n\n  /* The id of the active (focused) item in the tree. */\n  activeId = computed(() => this.listBehavior.activeDescendant());\n\n  /** The list of items in the tree. */\n  items = computed(() => this.inputs.allItems());\n\n  /** The tab index for the tree. Always -1 because the combobox handles focus. */\n  override tabIndex: SignalLike<-1 | 0> = () => -1;\n\n  constructor(override readonly inputs: ComboboxTreeInputs<V>) {\n    if (inputs.combobox()) {\n      inputs.multi = () => false;\n      inputs.focusMode = () => 'activedescendant';\n      inputs.element = inputs.combobox()!.inputs.inputEl;\n    }\n\n    super(inputs);\n  }\n\n  /** Noop. The combobox handles keydown events. */\n  override onKeydown(_: KeyboardEvent): void {}\n\n  /** Noop. The combobox handles pointerdown events. */\n  override onPointerdown(_: PointerEvent): void {}\n\n  /** Noop. The combobox controls the open state. */\n  override setDefaultState(): void {}\n\n  /** Navigates to the specified item in the tree. */\n  focus = (item: TreeItemPattern<V>) => this.listBehavior.goto(item);\n\n  /** Navigates to the next focusable item in the tree. */\n  next = () => this.listBehavior.next();\n\n  /** Navigates to the previous focusable item in the tree. */\n  prev = () => this.listBehavior.prev();\n\n  /** Navigates to the last focusable item in the tree. */\n  last = () => this.listBehavior.last();\n\n  /** Navigates to the first focusable item in the tree. */\n  first = () => this.listBehavior.first();\n\n  /** Unfocuses the currently focused item in the tree. */\n  unfocus = () => this.listBehavior.unfocus();\n\n  // TODO: handle non-selectable parent nodes.\n  /** Selects the specified item in the tree or the current active item if not provided. */\n  select = (item?: TreeItemPattern<V>) => this.listBehavior.select(item);\n\n  /** Toggles the selection state of the given item in the tree or the current active item if not provided. */\n  toggle = (item?: TreeItemPattern<V>) => this.listBehavior.toggle(item);\n\n  /** Clears the selection in the tree. */\n  clearSelection = () => this.listBehavior.deselectAll();\n\n  /** Retrieves the TreeItemPattern associated with a pointer event. */\n  getItem = (e: PointerEvent) => this._getItem(e);\n\n  /** Retrieves the currently selected items in the tree */\n  getSelectedItems = () => this.inputs.allItems().filter(item => item.selected());\n\n  /** Sets the value of the combobox tree. */\n  setValue = (value: V | undefined) => this.inputs.value.set(value ? [value] : []);\n\n  /** Expands the currently focused item if it is expandable. */\n  expandItem = () => this.expand();\n\n  /** Collapses the currently focused item if it is expandable. */\n  collapseItem = () => this.collapse();\n\n  /** Whether the specified item or the currently active item is expandable. */\n  isItemExpandable(item: TreeItemPattern<V> | undefined = this.inputs.activeItem()) {\n    return item ? item.expandable() : false;\n  }\n\n  /** Expands all of the tree items. */\n  expandAll = () => this.items().forEach(item => item.expansion.open());\n\n  /** Collapses all of the tree items. */\n  collapseAll = () => this.items().forEach(item => item.expansion.close());\n\n  /** Whether the currently active item is selectable. */\n  isItemSelectable = (item: TreeItemPattern<V> | undefined = this.inputs.activeItem()) => {\n    return item ? item.selectable() : false;\n  };\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  afterRenderEffect,\n  Directive,\n  inject,\n  TemplateRef,\n  signal,\n  ViewContainerRef,\n  model,\n  EmbeddedViewRef,\n  OnDestroy,\n} from '@angular/core';\n\n/**\n * A container directive controls the visibility of its content.\n */\n@Directive()\nexport class DeferredContentAware {\n  readonly contentVisible = signal(false);\n  readonly preserveContent = model(false);\n}\n\n/**\n * DeferredContent loads/unloads the content based on the visibility.\n * The visibilty signal is sent from a parent directive implements\n * DeferredContentAware.\n *\n * Use this directive as a host directive. For example:\n *\n * ```ts\n *   @Directive({\n *     selector: 'ng-template[AccordionContent]',\n *     hostDirectives: [DeferredContent],\n *   })\n *   class AccordionContent {}\n * ```\n */\n@Directive()\nexport class DeferredContent implements OnDestroy {\n  private readonly _deferredContentAware = inject(DeferredContentAware, {optional: true});\n  private readonly _templateRef = inject(TemplateRef);\n  private readonly _viewContainerRef = inject(ViewContainerRef);\n  private _currentViewRef: EmbeddedViewRef<unknown> | null = null;\n  private _isRendered = false;\n\n  readonly deferredContentAware = signal(this._deferredContentAware);\n\n  constructor() {\n    afterRenderEffect(() => {\n      if (this.deferredContentAware()?.contentVisible()) {\n        if (!this._isRendered) {\n          this._destroyContent();\n          this._currentViewRef = this._viewContainerRef.createEmbeddedView(this._templateRef);\n          this._isRendered = true;\n        }\n      } else if (!this.deferredContentAware()?.preserveContent()) {\n        this._destroyContent();\n        this._isRendered = false;\n      }\n    });\n  }\n\n  ngOnDestroy(): void {\n    this._destroyContent();\n  }\n\n  private _destroyContent() {\n    const ref = this._currentViewRef;\n\n    if (ref && !ref.destroyed) {\n      ref.destroy();\n      this._currentViewRef = null;\n    }\n  }\n}\n"],"names":["expanded","signal","computed","inputs","popupControls","activeId","undefined","id","autocomplete","filterMode","keydown","on","open","first","last","close","reset","readonly","manager","selected","KeyboardEventManager","next","prev","commit","multi","role","select","treeControls","isItemSelectable","isItemExpandable","isItemCollapsible","collapseKey","collapseItem","expandKey","expandItem","getItem","e","item","toggleExpansion","focus","inputEl","disabled","pointerup","handle","event","inputValue","set","value","isDeleting","InputEvent","inputType","match","getSelectedItems","selectedItems","searchTerm","clearSelection","highlight","onFocusIn","isFocused","onFocusOut","relatedTarget","HTMLElement","find","i","items","firstMatch","length","prevActiveItem","indexOf","activeItem","isListDisabled","every","getActiveDescendant","focusMode","focusManager","opts","_advance","peekNext","_peek","peekPrev","peekLast","goto","peekFirst","isFocusable","filter","includes","constructor","anchor","selectable","deselectAll","index","findIndex","update","values","concat","deselect","toggleOne","selectAll","beginRangeSelection","v","selectOne","isTyping","_query","_startIndex","search","char","activeIndex","q","toLowerCase","_getItem","List","activeDescendant","tabIndex","focusBehavior","getListTabIndex","selectionBehavior","ListSelection","typeaheadBehavior","ListTypeahead","navigationBehavior","ListNavigation","wrap","_wrap","getItemTabindex","getItemTabIndex","_navigate","unfocus","_anchorIndex","listBehavior","orientation","selectionMode","prevKey","textDirection","nextKey","typeaheadRegexp","key","followFocus","Modifier","Any","Shift","selectRange","Ctrl","Meta","updateSelection","dynamicSpaceKey","toggle","toggleAll","PointerEventManager","validate","listbox","active","combobox","onKeydown","_","onPointerdown","setDefaultState","isVisible","parent","hasBeenFocused","shouldFocus","root","MenuBarPattern","MenuPattern","MenuTriggerPattern","grandparent","closeAll","_expandKey","expand","_collapseKey","collapse","trigger","onMouseOver","element","contains","target","submenu","focusElement","onMouseOut","parentEl","refocus","MenuItemPattern","siblings","submit","isMenu","isMenuBar","isMenuTrigger","onSelect","_nextKey","_previousKey","prevItem","expansionId","expansionManager","ListExpansion","expandedIds","isExpandable","ids","labelledBy","TabPattern","tablist","expandable","expansion","isExpanded","controls","tabpanel","ExpansionControl","TabPanelPattern","hidden","tab","labelManager","join","LabelControl","defaultLabelledBy","TabListPattern","_prevKey","_altPrevKey","_altNextKey","_keydown","_groupNext","currGroup","group","nextGroup","_groupPrev","forEach","softDisabled","AccordionGroupPattern","multiExpandable","ListFocus","navigation","AccordionTriggerPattern","accordionPanel","accordionGroup","expansionControl","TreeItemPattern","tree","visibleItems","level","visible","setsize","children","posinset","nav","currentType","hasChildren","TreePattern","allItems","list","expandSiblings","preventDefault","typeaheadDelay","contentVisible","ngDevMode","debugName","afterRenderEffect","deferredContentAware","_isRendered","_destroyContent","_currentViewRef","_viewContainerRef","createEmbeddedView","_templateRef","preserveContent"],"mappings":"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"}