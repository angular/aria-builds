{"version":3,"file":"_widget-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/event-manager/event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/event-manager/keyboard-event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/event-manager/pointer-event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-data.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-focus.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-navigation.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-selection.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/grid.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/cell.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/widget.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * An event that supports modifier keys.\n *\n * Matches the native KeyboardEvent, MouseEvent, and TouchEvent.\n */\nexport interface EventWithModifiers extends Event {\n  ctrlKey: boolean;\n  shiftKey: boolean;\n  altKey: boolean;\n  metaKey: boolean;\n}\n\n/**\n * Options that are applicable to all event handlers.\n *\n * This library has not yet had a need for stopPropagationImmediate.\n */\nexport interface EventHandlerOptions {\n  stopPropagation: boolean;\n  preventDefault: boolean;\n}\n\n/** A basic event handler. */\nexport type EventHandler<T extends Event> = (event: T) => void;\n\n/** A function that determines whether an event is to be handled. */\nexport type EventMatcher<T extends Event> = (event: T) => boolean;\n\n/** A config that specifies how to handle a particular event. */\nexport interface EventHandlerConfig<T extends Event> extends EventHandlerOptions {\n  matcher: EventMatcher<T>;\n  handler: EventHandler<T>;\n}\n\n/** Bit flag representation of the possible modifier keys that can be present on an event. */\nexport enum Modifier {\n  None = 0,\n  Ctrl = 0b1,\n  Shift = 0b10,\n  Alt = 0b100,\n  Meta = 0b1000,\n  Any = 'Any',\n}\n\nexport type ModifierInputs = Modifier | Modifier[];\n\n/**\n * Abstract base class for all event managers.\n *\n * Event managers are designed to normalize how event handlers are authored and create a safety net\n * for common event handling gotchas like remembering to call preventDefault or stopPropagation.\n */\nexport abstract class EventManager<T extends Event> {\n  protected configs: EventHandlerConfig<T>[] = [];\n  abstract options: EventHandlerOptions;\n\n  /** Runs the handlers that match with the given event. */\n  handle(event: T): void {\n    for (const config of this.configs) {\n      if (config.matcher(event)) {\n        config.handler(event);\n\n        if (config.preventDefault) {\n          event.preventDefault();\n        }\n\n        if (config.stopPropagation) {\n          event.stopPropagation();\n        }\n      }\n    }\n  }\n\n  /** Configures the event manager to handle specific events. (See subclasses for more). */\n  abstract on(...args: [...unknown[]]): this;\n}\n\n/** Gets bit flag representation of the modifier keys present on the given event. */\nexport function getModifiers(event: EventWithModifiers): number {\n  return (\n    (+event.ctrlKey && Modifier.Ctrl) |\n    (+event.shiftKey && Modifier.Shift) |\n    (+event.altKey && Modifier.Alt) |\n    (+event.metaKey && Modifier.Meta)\n  );\n}\n\n/**\n * Checks if the given event has modifiers that are an exact match for any of the given modifier\n * flag combinations.\n */\nexport function hasModifiers(event: EventWithModifiers, modifiers: ModifierInputs): boolean {\n  const eventModifiers = getModifiers(event);\n  const modifiersList = Array.isArray(modifiers) ? modifiers : [modifiers];\n\n  if (modifiersList.includes(Modifier.Any)) {\n    return true;\n  }\n\n  return modifiersList.some(modifiers => eventModifiers === modifiers);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SignalLike} from '../signal-like/signal-like';\nimport {\n  EventHandler,\n  EventHandlerOptions,\n  EventManager,\n  hasModifiers,\n  ModifierInputs,\n  Modifier,\n} from './event-manager';\n\n/**\n * Used to represent a keycode.\n *\n * This is used to match whether an events keycode should be handled. The ability to match using a\n * string, SignalLike, or Regexp gives us more flexibility when authoring event handlers.\n */\ntype KeyCode = string | SignalLike<string> | RegExp;\n\n/**\n * An event manager that is specialized for handling keyboard events. By default this manager stops\n * propagation and prevents default on all events it handles.\n */\nexport class KeyboardEventManager<T extends KeyboardEvent> extends EventManager<T> {\n  options: EventHandlerOptions = {\n    preventDefault: true,\n    stopPropagation: true,\n  };\n\n  /** Configures this event manager to handle events with a specific key and no modifiers. */\n  on(key: KeyCode, handler: EventHandler<T>, options?: Partial<EventHandlerOptions>): this;\n\n  /**  Configures this event manager to handle events with a specific modifer and key combination. */\n  on(\n    modifiers: ModifierInputs,\n    key: KeyCode,\n    handler: EventHandler<T>,\n    options?: Partial<EventHandlerOptions>,\n  ): this;\n\n  on(...args: any[]) {\n    const {modifiers, key, handler, options} = this._normalizeInputs(...args);\n\n    this.configs.push({\n      handler: handler,\n      matcher: event => this._isMatch(event, key, modifiers),\n      ...this.options,\n      ...options,\n    });\n\n    return this;\n  }\n\n  private _normalizeInputs(...args: any[]) {\n    const withModifiers = Array.isArray(args[0]) || args[0] in Modifier;\n    const modifiers = withModifiers ? args[0] : Modifier.None;\n    const key = withModifiers ? args[1] : args[0];\n    const handler = withModifiers ? args[2] : args[1];\n    const options = withModifiers ? args[3] : args[2];\n\n    return {\n      key: key as KeyCode,\n      handler: handler as EventHandler<T>,\n      modifiers: modifiers as ModifierInputs,\n      options: (options ?? {}) as Partial<EventHandlerOptions>,\n    };\n  }\n\n  private _isMatch(event: T, key: KeyCode, modifiers: ModifierInputs) {\n    if (!hasModifiers(event, modifiers)) {\n      return false;\n    }\n\n    if (key instanceof RegExp) {\n      return key.test(event.key);\n    }\n\n    const keyStr = typeof key === 'string' ? key : key();\n    return keyStr.toLowerCase() === event.key.toLowerCase();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  EventHandler,\n  EventHandlerOptions,\n  EventManager,\n  hasModifiers,\n  ModifierInputs,\n  Modifier,\n} from './event-manager';\n\n/**\n * The different mouse buttons that may appear on a pointer event.\n */\nexport enum MouseButton {\n  Main = 0,\n  Auxiliary = 1,\n  Secondary = 2,\n}\n\n/** An event manager that is specialized for handling pointer events. */\nexport class PointerEventManager<T extends PointerEvent> extends EventManager<T> {\n  options: EventHandlerOptions = {\n    preventDefault: false,\n    stopPropagation: false,\n  };\n\n  /**\n   * Configures this event manager to handle events with a specific modifer and mouse button\n   * combination.\n   */\n  on(button: MouseButton, modifiers: ModifierInputs, handler: EventHandler<T>): this;\n\n  /**\n   * Configures this event manager to handle events with a specific mouse button and no modifiers.\n   */\n  on(modifiers: ModifierInputs, handler: EventHandler<T>): this;\n\n  /**\n   * Configures this event manager to handle events with the main mouse button and no modifiers.\n   *\n   * @param handler The handler function\n   * @param options Options for whether to stop propagation or prevent default.\n   */\n  on(handler: EventHandler<T>): this;\n\n  on(...args: any[]) {\n    const {button, handler, modifiers} = this._normalizeInputs(...args);\n\n    this.configs.push({\n      handler,\n      matcher: event => this._isMatch(event, button, modifiers),\n      ...this.options,\n    });\n    return this;\n  }\n\n  private _normalizeInputs(...args: any[]) {\n    if (args.length === 3) {\n      return {\n        button: args[0] as MouseButton,\n        modifiers: args[1] as ModifierInputs,\n        handler: args[2] as EventHandler<T>,\n      };\n    }\n\n    if (args.length === 2) {\n      return {\n        button: MouseButton.Main,\n        modifiers: args[0] as ModifierInputs,\n        handler: args[1] as EventHandler<T>,\n      };\n    }\n\n    return {\n      button: MouseButton.Main,\n      modifiers: Modifier.None,\n      handler: args[0] as EventHandler<T>,\n    };\n  }\n\n  _isMatch(event: PointerEvent, button: MouseButton, modifiers: ModifierInputs) {\n    return button === (event.button ?? 0) && hasModifiers(event, modifiers);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\n\n/** Represents coordinates in a grid. */\nexport interface RowCol {\n  /** The row index. */\n  row: number;\n\n  /** The column index. */\n  col: number;\n}\n\n/** A string representation of grid coordinates. */\ntype CoordString = `${RowCol['row']}:${RowCol['col']}`;\n\n/** The base interface for a cell in a grid. */\nexport interface BaseGridCell {\n  /** The number of rows the cell should span. */\n  rowSpan: SignalLike<number>;\n\n  /** The number of columns the cell should span. */\n  colSpan: SignalLike<number>;\n}\n\n/** Represents the required inputs for GridData. */\nexport interface GridDataInputs<T extends BaseGridCell> {\n  /** The two-dimensional array of cells that represents the grid. */\n  cells: SignalLike<T[][]>;\n}\n\n/** Controls internal coordinates for a grid of items. */\nexport class GridData<T extends BaseGridCell> {\n  /** The two-dimensional array of cells that represents the grid. */\n  readonly cells: SignalLike<T[][]>;\n\n  /** The maximum number of rows in the grid, accounting for row spans. */\n  readonly maxRowCount = computed<number>(() => Math.max(...this._rowCountByCol().values(), 0));\n\n  /** The maximum number of columns in the grid, accounting for column spans. */\n  readonly maxColCount = computed<number>(() => Math.max(...this._colCountsByRow().values(), 0));\n\n  /** A map from a cell to its primary and spanned coordinates. */\n  private readonly _coordsMap = computed<Map<T, {coords: RowCol; spanCoords: RowCol[]}>>(() => {\n    const coordsMap = new Map();\n    const visitedCoords = new Set();\n\n    for (let rowIndex = 0; rowIndex < this.cells().length; rowIndex++) {\n      let colIndex = 0;\n      const row = this.cells()[rowIndex];\n\n      for (const cell of row) {\n        // Skip past cells that are already taken.\n        while (visitedCoords.has(`${rowIndex}:${colIndex}`)) {\n          colIndex++;\n        }\n\n        const rowspan = cell.rowSpan();\n        const colspan = cell.colSpan();\n        const spanCoords: RowCol[] = [];\n\n        for (let rowOffset = 0; rowOffset < rowspan; rowOffset++) {\n          const row = rowIndex + rowOffset;\n          for (let colOffset = 0; colOffset < colspan; colOffset++) {\n            const col = colIndex + colOffset;\n            visitedCoords.add(`${row}:${col}`);\n            spanCoords.push({row, col});\n          }\n        }\n        coordsMap.set(cell, {coords: spanCoords[0], spanCoords});\n\n        colIndex += colspan;\n      }\n    }\n\n    return coordsMap;\n  });\n\n  /** A map from a coordinate string to the cell at that coordinate. */\n  private readonly _cellMap = computed<Map<CoordString, T>>(() => {\n    const cellMap = new Map();\n    for (const [cell, {spanCoords}] of this._coordsMap().entries()) {\n      for (const {row, col} of spanCoords) {\n        cellMap.set(`${row}:${col}`, cell);\n      }\n    }\n    return cellMap;\n  });\n\n  /** A map from a row index to the number of columns in that row. */\n  private readonly _colCountsByRow = computed<Map<number, number>>(() => {\n    const colCountByRow = new Map();\n    for (const [_, {spanCoords}] of this._coordsMap().entries()) {\n      for (const {row, col} of spanCoords) {\n        const colCount = colCountByRow.get(row);\n        const newColCount = col + 1;\n        if (colCount === undefined || colCount < newColCount) {\n          colCountByRow.set(row, newColCount);\n        }\n      }\n    }\n    return colCountByRow;\n  });\n\n  /** A map from a column index to the number of rows in that column. */\n  private readonly _rowCountByCol = computed<Map<number, number>>(() => {\n    const rowCountByCol = new Map();\n    for (const [_, {spanCoords}] of this._coordsMap().entries()) {\n      for (const {row, col} of spanCoords) {\n        const rowCount = rowCountByCol.get(col);\n        const newRowCount = row + 1;\n        if (rowCount === undefined || rowCount < newRowCount) {\n          rowCountByCol.set(col, newRowCount);\n        }\n      }\n    }\n    return rowCountByCol;\n  });\n\n  constructor(readonly inputs: GridDataInputs<T>) {\n    this.cells = this.inputs.cells;\n  }\n\n  /** Gets the cell at the given coordinates. */\n  getCell(rowCol: RowCol): T | undefined {\n    return this._cellMap().get(`${rowCol.row}:${rowCol.col}`);\n  }\n\n  /** Gets the primary coordinates of the given cell. */\n  getCoords(cell: T): RowCol | undefined {\n    return this._coordsMap().get(cell)?.coords;\n  }\n\n  /** Gets all coordinates that the given cell spans. */\n  getAllCoords(cell: T): RowCol[] | undefined {\n    return this._coordsMap().get(cell)?.spanCoords;\n  }\n\n  /** Gets the number of rows in the given column. */\n  getRowCount(col: number): number | undefined {\n    return this._rowCountByCol().get(col);\n  }\n\n  /** Gets the number of columns in the given row. */\n  getColCount(row: number): number | undefined {\n    return this._colCountsByRow().get(row);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\nimport type {GridData, BaseGridCell, RowCol} from './grid-data';\n\n/** Represents an cell in a grid, such as a grid cell, that may receive focus. */\nexport interface GridFocusCell extends BaseGridCell {\n  /** A unique identifier for the cell. */\n  id: SignalLike<string>;\n\n  /** The html element that should receive focus. */\n  element: SignalLike<HTMLElement>;\n\n  /** Whether a cell is disabled. */\n  disabled: SignalLike<boolean>;\n}\n\n/** Represents the required inputs for a grid that contains focusable cells. */\nexport interface GridFocusInputs {\n  /** The focus strategy used by the grid. */\n  focusMode: SignalLike<'roving' | 'activedescendant'>;\n\n  /** Whether the grid is disabled. */\n  disabled: SignalLike<boolean>;\n\n  /** Whether disabled cells in the grid should be focusable. */\n  softDisabled: SignalLike<boolean>;\n}\n\n/** Dependencies for the `GridFocus` class. */\ninterface GridFocusDeps<T extends GridFocusCell> {\n  /** The `GridData` instance that this focus manager operates on. */\n  grid: GridData<T>;\n}\n\n/** Controls focus for a 2D grid of cells. */\nexport class GridFocus<T extends GridFocusCell> {\n  /** The current active cell. */\n  readonly activeCell = signal<T | undefined>(undefined);\n\n  /** The current active cell coordinates. */\n  readonly activeCoords = signal<RowCol>({row: -1, col: -1});\n\n  /** Whether the grid active state is empty (no active cell or coordinates). */\n  readonly stateEmpty = computed(\n    () =>\n      this.activeCell() === undefined ||\n      (this.activeCoords().row === -1 && this.activeCoords().col === -1),\n  );\n\n  /**\n   * Whether the grid focus state is stale.\n   *\n   * A stale state means the active cell or coordinates are no longer valid based on the\n   * current grid data, for example if the underlying cells have changed.\n   * A stale state should be re-initialized.\n   */\n  readonly stateStale = computed(() => {\n    if (this.stateEmpty()) {\n      return true;\n    }\n\n    const activeCell = this.activeCell();\n    const activeCellCoords = this.inputs.grid.getCoords(activeCell!);\n    const activeCoords = this.activeCoords();\n    const activeCoordsCell = this.inputs.grid.getCell(activeCoords);\n\n    const activeCellNotValid = activeCellCoords === undefined;\n    const activeCellMismatch = activeCell !== activeCoordsCell;\n    return activeCellNotValid || activeCellMismatch;\n  });\n\n  /** The id of the current active cell, for ARIA activedescendant. */\n  readonly activeDescendant = computed<string | undefined>(() => {\n    if (this.gridDisabled() || this.inputs.focusMode() === 'roving') {\n      return undefined;\n    }\n    const currentActiveCell = this.activeCell();\n    return currentActiveCell ? currentActiveCell.id() : undefined;\n  });\n\n  /** Whether the grid is in a disabled state. */\n  readonly gridDisabled = computed<boolean>(() => {\n    if (this.inputs.disabled()) {\n      return true;\n    }\n    const gridCells = this.inputs.grid.cells();\n    return gridCells.length === 0 || gridCells.every(row => row.every(cell => cell.disabled()));\n  });\n\n  /** The tabindex for the grid container. */\n  readonly gridTabIndex = computed<-1 | 0>(() => {\n    if (this.gridDisabled()) {\n      return 0;\n    }\n    return this.inputs.focusMode() === 'activedescendant' ? 0 : -1;\n  });\n\n  constructor(readonly inputs: GridFocusInputs & GridFocusDeps<T>) {}\n\n  /** Returns the tabindex for the given grid cell cell. */\n  getCellTabindex(cell: T): -1 | 0 {\n    if (this.gridDisabled()) {\n      return -1;\n    }\n    if (this.inputs.focusMode() === 'activedescendant') {\n      return -1;\n    }\n    return this.activeCell() === cell ? 0 : -1;\n  }\n\n  /** Returns true if the given cell can be navigated to. */\n  isFocusable(cell: T): boolean {\n    return !cell.disabled() || this.inputs.softDisabled();\n  }\n\n  /** Focuses the given cell. */\n  focusCell(cell: T): boolean {\n    if (this.gridDisabled()) {\n      return false;\n    }\n\n    if (!this.isFocusable(cell)) {\n      return false;\n    }\n\n    if (this.inputs.grid.getCoords(cell) === undefined) {\n      return false;\n    }\n\n    this.activeCoords.set(this.inputs.grid.getCoords(cell)!);\n    this.activeCell.set(cell);\n\n    return true;\n  }\n\n  /** Moves focus to the cell at the given coordinates if it's part of a focusable cell. */\n  focusCoordinates(coords: RowCol): boolean {\n    if (this.gridDisabled()) {\n      return false;\n    }\n\n    const cell = this.inputs.grid.getCell(coords);\n\n    if (!cell || !this.isFocusable(cell)) {\n      return false;\n    }\n\n    if (this.inputs.grid.getCell(coords) === undefined) {\n      return false;\n    }\n\n    this.activeCoords.set(coords);\n    this.activeCell.set(this.inputs.grid.getCell(coords));\n\n    return true;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\nimport {GridFocus, GridFocusCell, GridFocusInputs} from './grid-focus';\nimport {GridData, RowCol} from './grid-data';\n\n/** A utility type that ensures an object has exactly one key from a given set. */\ntype ExactlyOneKey<T, K extends keyof T = keyof T> = {\n  [P in K]: Record<P, T[P]> & Partial<Record<Exclude<K, P>, never>>;\n}[K];\n\n/** Represents a directional change in the grid, either by row or by column. */\ntype Delta = ExactlyOneKey<{row: -1 | 1; col: -1 | 1}>;\n\n/** Constants for the four cardinal directions. */\nexport const direction: Record<'Up' | 'Down' | 'Left' | 'Right', Delta> = {\n  Up: {row: -1},\n  Down: {row: 1},\n  Left: {col: -1},\n  Right: {col: 1},\n} as const;\n\n/** The wrapping behavior for keyboard navigation. */\nexport type WrapStrategy = 'continuous' | 'loop' | 'nowrap';\n\n/** Represents an item in a collection, such as a listbox option, than can be navigated to. */\nexport interface GridNavigationCell extends GridFocusCell {}\n\n/** Represents the required inputs for a collection that has navigable items. */\nexport interface GridNavigationInputs extends GridFocusInputs {\n  /** The wrapping behavior for keyboard navigation along the row axis. */\n  rowWrap: SignalLike<WrapStrategy>;\n\n  /** The wrapping behavior for keyboard navigation along the column axis. */\n  colWrap: SignalLike<WrapStrategy>;\n}\n\n/** Dependencies for the `GridNavigation` class. */\ninterface GridNavigationDeps<T extends GridNavigationCell> {\n  /** The `GridData` instance that this navigation manager operates on. */\n  grid: GridData<T>;\n\n  /** The `GridFocus` instance that this navigation manager uses to manage focus. */\n  gridFocus: GridFocus<T>;\n}\n\n/** Controls navigation for a grid of items. */\nexport class GridNavigation<T extends GridNavigationCell> {\n  /** The maximum number of steps to take when searching for the next cell. */\n  private _maxSteps = computed<number>(\n    () => this.inputs.grid.maxRowCount() * this.inputs.grid.maxColCount(),\n  );\n\n  constructor(readonly inputs: GridNavigationInputs & GridNavigationDeps<T>) {}\n\n  /** Navigates to the given item. */\n  gotoCell(cell: T): boolean {\n    return this.inputs.gridFocus.focusCell(cell);\n  }\n\n  /** Navigates to the given coordinates. */\n  gotoCoords(coords: RowCol): boolean {\n    return this.inputs.gridFocus.focusCoordinates(coords);\n  }\n\n  /**\n   * Gets the coordinates of the next focusable cell in a given direction, without changing focus.\n   */\n  peek(direction: Delta, fromCoords: RowCol, wrap?: WrapStrategy): RowCol | undefined {\n    wrap = wrap ?? (direction.row !== undefined ? this.inputs.rowWrap() : this.inputs.colWrap());\n    return this._peekDirectional(direction, fromCoords, wrap);\n  }\n\n  /**\n   * Navigates to the next focusable cell in a given direction.\n   */\n  advance(direction: Delta): boolean {\n    const nextCoords = this.peek(direction, this.inputs.gridFocus.activeCoords());\n    return !!nextCoords && this.gotoCoords(nextCoords);\n  }\n\n  /**\n   * Gets the coordinates of the first focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  peekFirst(row?: number): RowCol | undefined {\n    const fromCoords = {\n      row: row ?? 0,\n      col: -1,\n    };\n    return row === undefined\n      ? this._peekDirectional(direction.Right, fromCoords, 'continuous')\n      : this._peekDirectional(direction.Right, fromCoords, 'nowrap');\n  }\n\n  /**\n   * Navigates to the first focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  first(row?: number): boolean {\n    const nextCoords = this.peekFirst(row);\n    return !!nextCoords && this.gotoCoords(nextCoords);\n  }\n\n  /**\n   * Gets the coordinates of the last focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  peekLast(row?: number): RowCol | undefined {\n    const fromCoords = {\n      row: row ?? this.inputs.grid.maxRowCount() - 1,\n      col: this.inputs.grid.maxColCount(),\n    };\n    return row === undefined\n      ? this._peekDirectional(direction.Left, fromCoords, 'continuous')\n      : this._peekDirectional(direction.Left, fromCoords, 'nowrap');\n  }\n\n  /**\n   * Navigates to the last focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  last(row?: number): boolean {\n    const nextCoords = this.peekLast(row);\n    return !!nextCoords && this.gotoCoords(nextCoords);\n  }\n\n  /**\n   * Finds the next focusable cell in a given direction based on the wrapping behavior.\n   */\n  private _peekDirectional(\n    delta: Delta,\n    fromCoords: RowCol,\n    wrap: 'continuous' | 'loop' | 'nowrap',\n  ): RowCol | undefined {\n    const fromCell = this.inputs.grid.getCell(fromCoords);\n    const maxRowCount = this.inputs.grid.maxRowCount();\n    const maxColCount = this.inputs.grid.maxColCount();\n    const rowDelta = delta.row ?? 0;\n    const colDelta = delta.col ?? 0;\n    let nextCoords = {...fromCoords};\n\n    for (let step = 0; step < this._maxSteps(); step++) {\n      const isWrapping =\n        nextCoords.col + colDelta < 0 ||\n        nextCoords.col + colDelta >= maxColCount ||\n        nextCoords.row + rowDelta < 0 ||\n        nextCoords.row + rowDelta >= maxRowCount;\n\n      if (wrap === 'nowrap' && isWrapping) return;\n\n      if (wrap === 'continuous') {\n        const generalDelta = delta.row ?? delta.col;\n        const rowStep = isWrapping ? generalDelta : rowDelta;\n        const colStep = isWrapping ? generalDelta : colDelta;\n\n        nextCoords = {\n          row: (nextCoords.row + rowStep + maxRowCount) % maxRowCount,\n          col: (nextCoords.col + colStep + maxColCount) % maxColCount,\n        };\n      }\n\n      if (wrap === 'loop') {\n        nextCoords = {\n          row: (nextCoords.row + rowDelta + maxRowCount) % maxRowCount,\n          col: (nextCoords.col + colDelta + maxColCount) % maxColCount,\n        };\n      }\n\n      if (wrap === 'nowrap') {\n        nextCoords = {\n          row: nextCoords.row + rowDelta,\n          col: nextCoords.col + colDelta,\n        };\n      }\n\n      // Back to original coordinates.\n      if (nextCoords.row === fromCoords.row && nextCoords.col === fromCoords.col) {\n        return undefined;\n      }\n\n      const nextCell = this.inputs.grid.getCell(nextCoords);\n      if (\n        nextCell !== undefined &&\n        nextCell !== fromCell &&\n        this.inputs.gridFocus.isFocusable(nextCell)\n      ) {\n        return nextCoords;\n      }\n    }\n\n    return undefined;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SignalLike, WritableSignalLike} from '../signal-like/signal-like';\nimport {GridFocus, GridFocusCell, GridFocusInputs} from './grid-focus';\nimport {GridData, RowCol} from './grid-data';\n\n/** Represents a cell in a grid that can be selected. */\nexport interface GridSelectionCell extends GridFocusCell {\n  /** Whether the cell is selected. */\n  selected: WritableSignalLike<boolean>;\n\n  /** Whether the cell is selectable. */\n  selectable: SignalLike<boolean>;\n}\n\n/** Represents the required inputs for a grid that has selectable cells. */\nexport interface GridSelectionInputs extends GridFocusInputs {}\n\n/** Dependencies for the `GridSelection` class. */\ninterface GridSelectionDeps<T extends GridSelectionCell> {\n  /** The `GridData` instance that this selection manager operates on. */\n  grid: GridData<T>;\n\n  /** The `GridFocus` instance that this selection manager uses to manage focus. */\n  gridFocus: GridFocus<T>;\n}\n\n/** Controls selection for a grid of items. */\nexport class GridSelection<T extends GridSelectionCell> {\n  constructor(readonly inputs: GridSelectionInputs & GridSelectionDeps<T>) {}\n\n  /** Selects one or more cells in a given range. */\n  select(fromCoords: RowCol, toCoords?: RowCol): void {\n    for (const cell of this._validCells(fromCoords, toCoords ?? fromCoords)) {\n      cell.selected.set(true);\n    }\n  }\n\n  /** Deselects one or more cells in a given range. */\n  deselect(fromCoords: RowCol, toCoords?: RowCol): void {\n    for (const cell of this._validCells(fromCoords, toCoords ?? fromCoords)) {\n      cell.selected.set(false);\n    }\n  }\n\n  /** Toggles the selection state of one or more cells in a given range. */\n  toggle(fromCoords: RowCol, toCoords?: RowCol): void {\n    for (const cell of this._validCells(fromCoords, toCoords ?? fromCoords)) {\n      cell.selected.update(state => !state);\n    }\n  }\n\n  /** Selects all valid cells in the grid. */\n  selectAll(): void {\n    for (const cell of this._validCells(\n      {row: 0, col: 0},\n      {row: this.inputs.grid.maxRowCount(), col: this.inputs.grid.maxColCount()},\n    )) {\n      cell.selected.set(true);\n    }\n  }\n\n  /** Deselects all valid cells in the grid. */\n  deselectAll(): void {\n    for (const cell of this._validCells(\n      {row: 0, col: 0},\n      {row: this.inputs.grid.maxRowCount(), col: this.inputs.grid.maxColCount()},\n    )) {\n      cell.selected.set(false);\n    }\n  }\n\n  /** A generator that yields all valid (selectable and not disabled) cells within a given range. */\n  *_validCells(fromCoords: RowCol, toCoords: RowCol): Generator<T> {\n    const startRow = Math.min(fromCoords.row, toCoords.row);\n    const startCol = Math.min(fromCoords.col, toCoords.col);\n    const endRow = Math.max(fromCoords.row, toCoords.row);\n    const endCol = Math.max(fromCoords.col, toCoords.col);\n    const visited = new Set<T>();\n    for (let row = startRow; row < endRow + 1; row++) {\n      for (let col = startCol; col < endCol + 1; col++) {\n        const cell = this.inputs.grid.getCell({row, col});\n        if (cell === undefined) continue;\n        if (!cell.selectable()) continue;\n        if (cell.disabled()) continue;\n        if (visited.has(cell)) continue;\n        visited.add(cell);\n        yield cell;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, linkedSignal} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\nimport {GridData, BaseGridCell, GridDataInputs, RowCol} from './grid-data';\nimport {GridFocus, GridFocusCell, GridFocusInputs} from './grid-focus';\nimport {\n  direction,\n  GridNavigation,\n  GridNavigationCell,\n  GridNavigationInputs,\n} from './grid-navigation';\nimport {GridSelectionCell, GridSelectionInputs, GridSelection} from './grid-selection';\n\n/** A type that represents a cell in a grid, combining all cell-related interfaces. */\nexport type GridCell = BaseGridCell & GridFocusCell & GridNavigationCell & GridSelectionCell;\n\n/** Represents the required inputs for a grid. */\nexport interface GridInputs<T extends GridCell>\n  extends GridDataInputs<T>,\n    GridFocusInputs,\n    GridNavigationInputs,\n    GridSelectionInputs {\n  /** Whether selection is enabled for the grid. */\n  enableSelection: SignalLike<boolean>;\n}\n\n/** The main class that orchestrates the grid behaviors. */\nexport class Grid<T extends GridCell> {\n  /** The underlying data structure for the grid. */\n  readonly data: GridData<T>;\n\n  /** Controls focus for the grid. */\n  readonly focusBehavior: GridFocus<T>;\n\n  /** Controls navigation for the grid. */\n  readonly navigationBehavior: GridNavigation<T>;\n\n  /** Controls selection for the grid. */\n  readonly selectionBehavior: GridSelection<T>;\n\n  /** The anchor point for range selection, linked to the active coordinates. */\n  readonly selectionAnchor = linkedSignal<RowCol>(() => this.focusBehavior.activeCoords());\n\n  /** The `tabindex` for the grid container. */\n  readonly gridTabIndex = computed(() => this.focusBehavior.gridTabIndex());\n\n  /** Whether the grid is in a disabled state. */\n  readonly gridDisabled = computed(() => this.focusBehavior.gridDisabled());\n\n  /** The ID of the active descendant for ARIA `activedescendant` focus management. */\n  readonly activeDescendant = computed(() => this.focusBehavior.activeDescendant());\n\n  constructor(readonly inputs: GridInputs<T>) {\n    this.data = new GridData(inputs);\n    this.focusBehavior = new GridFocus({...inputs, grid: this.data});\n    this.navigationBehavior = new GridNavigation({\n      ...inputs,\n      grid: this.data,\n      gridFocus: this.focusBehavior,\n    });\n    this.selectionBehavior = new GridSelection({\n      ...inputs,\n      grid: this.data,\n      gridFocus: this.focusBehavior,\n    });\n  }\n\n  /** Gets the 1-based row index of a cell. */\n  rowIndex(cell: T): number | undefined {\n    const index = this.data.getCoords(cell)?.row;\n    return index !== undefined ? index + 1 : undefined;\n  }\n\n  /** Gets the 1-based column index of a cell. */\n  colIndex(cell: T): number | undefined {\n    const index = this.data.getCoords(cell)?.col;\n    return index !== undefined ? index + 1 : undefined;\n  }\n\n  /** Gets the `tabindex` for a given cell. */\n  cellTabIndex(cell: T): -1 | 0 {\n    return this.focusBehavior.getCellTabindex(cell);\n  }\n\n  /** Navigates to the cell above the currently active cell. */\n  up(): boolean {\n    return this.navigationBehavior.advance(direction.Up);\n  }\n\n  /** Extends the selection to the cell above the selection anchor. */\n  rangeSelectUp(): void {\n    const coords = this.navigationBehavior.peek(direction.Up, this.selectionAnchor());\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Navigates to the cell below the currently active cell. */\n  down(): boolean {\n    return this.navigationBehavior.advance(direction.Down);\n  }\n\n  /** Extends the selection to the cell below the selection anchor. */\n  rangeSelectDown(): void {\n    const coords = this.navigationBehavior.peek(direction.Down, this.selectionAnchor());\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Navigates to the cell to the left of the currently active cell. */\n  left(): boolean {\n    return this.navigationBehavior.advance(direction.Left);\n  }\n\n  /** Extends the selection to the cell to the left of the selection anchor. */\n  rangeSelectLeft(): void {\n    const coords = this.navigationBehavior.peek(direction.Left, this.selectionAnchor());\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Navigates to the cell to the right of the currently active cell. */\n  right(): boolean {\n    return this.navigationBehavior.advance(direction.Right);\n  }\n\n  /** Extends the selection to the cell to the right of the selection anchor. */\n  rangeSelectRight(): void {\n    const coords = this.navigationBehavior.peek(direction.Right, this.selectionAnchor());\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Navigates to the first focusable cell in the grid. */\n  first(): boolean {\n    return this.navigationBehavior.first();\n  }\n\n  /** Navigates to the first focusable cell in the current row. */\n  firstInRow(): boolean {\n    return this.navigationBehavior.first(this.focusBehavior.activeCoords().row);\n  }\n\n  /** Navigates to the last focusable cell in the grid. */\n  last(): boolean {\n    return this.navigationBehavior.last();\n  }\n\n  /** Navigates to the last focusable cell in the current row. */\n  lastInRow(): boolean {\n    return this.navigationBehavior.last(this.focusBehavior.activeCoords().row);\n  }\n\n  /** Selects all cells in the current row. */\n  selectRow(): void {\n    const row = this.focusBehavior.activeCoords().row;\n    this.selectionBehavior.deselectAll();\n    this.selectionBehavior.select({row, col: 0}, {row, col: this.data.maxColCount()});\n  }\n\n  /** Selects all cells in the current column. */\n  selectCol(): void {\n    const col = this.focusBehavior.activeCoords().col;\n    this.selectionBehavior.deselectAll();\n    this.selectionBehavior.select({row: 0, col}, {row: this.data.maxRowCount(), col});\n  }\n\n  /** Selects all selectable cells in the grid. */\n  selectAll(): void {\n    this.selectionBehavior.selectAll();\n  }\n\n  /** Navigates to and focuses the given cell. */\n  gotoCell(cell: T): boolean {\n    return this.navigationBehavior.gotoCell(cell);\n  }\n\n  /** Toggles the selection state of the given cell. */\n  toggleSelect(cell: T): void {\n    const coords = this.data.getCoords(cell);\n    if (coords === undefined) return;\n\n    this.selectionBehavior.toggle(coords);\n  }\n\n  /** Extends the selection from the anchor to the given cell. */\n  rangeSelect(cell: T): void {\n    const coords = this.data.getCoords(cell);\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Extends the selection to the given coordinates. */\n  private _rangeSelectCoords(coords: RowCol): void {\n    const activeCell = this.focusBehavior.activeCell();\n    const anchorCell = this.data.getCell(coords);\n    if (activeCell === undefined || anchorCell === undefined) {\n      return;\n    }\n\n    const allCoords = [\n      ...this.data.getAllCoords(activeCell)!,\n      ...this.data.getAllCoords(anchorCell)!,\n    ];\n    const allRows = allCoords.map(c => c.row);\n    const allCols = allCoords.map(c => c.col);\n    const fromCoords = {\n      row: Math.min(...allRows),\n      col: Math.min(...allCols),\n    };\n    const toCoords = {\n      row: Math.max(...allRows),\n      col: Math.max(...allCols),\n    };\n\n    this.selectionBehavior.deselectAll();\n    this.selectionBehavior.select(fromCoords, toCoords);\n    this.selectionAnchor.set(coords);\n  }\n\n  /** Resets the active state of the grid if it is empty or stale. */\n  resetState(): boolean {\n    if (this.focusBehavior.stateEmpty()) {\n      const firstFocusableCoords = this.navigationBehavior.peekFirst();\n      if (firstFocusableCoords === undefined) {\n        return false;\n      }\n\n      return this.focusBehavior.focusCoordinates(firstFocusableCoords);\n    }\n\n    if (this.focusBehavior.stateStale()) {\n      // Try focus on the same active cell after if a reordering happened.\n      if (this.focusBehavior.focusCell(this.focusBehavior.activeCell()!)) {\n        return true;\n      }\n\n      // If the active cell is no longer exist, focus on the coordinates instead.\n      if (this.focusBehavior.focusCoordinates(this.focusBehavior.activeCoords())) {\n        return true;\n      }\n\n      // If the cooridnates no longer valid, go back to the first available cell.\n      if (this.focusBehavior.focusCoordinates(this.navigationBehavior.peekFirst()!)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport {KeyboardEventManager, PointerEventManager, Modifier} from '../behaviors/event-manager';\nimport {Grid, GridInputs as GridBehaviorInputs} from '../behaviors/grid';\nimport type {GridRowPattern} from './row';\nimport type {GridCellPattern} from './cell';\n\n/** Represents the required inputs for the grid pattern. */\nexport interface GridInputs extends Omit<GridBehaviorInputs<GridCellPattern>, 'cells'> {\n  /** The html element of the grid. */\n  element: SignalLike<HTMLElement>;\n\n  /** The rows that make up the grid. */\n  rows: SignalLike<GridRowPattern[]>;\n\n  /** The direction that text is read based on the users locale. */\n  textDirection: SignalLike<'rtl' | 'ltr'>;\n\n  /** A function that returns the grid cell associated with a given element. */\n  getCell: (e: Element) => GridCellPattern | undefined;\n}\n\n/** The UI pattern for a grid, handling keyboard navigation, focus, and selection. */\nexport class GridPattern {\n  /** The underlying grid behavior that this pattern is built on. */\n  readonly gridBehavior: Grid<GridCellPattern>;\n\n  /** The cells in the grid. */\n  readonly cells = computed(() => this.gridBehavior.data.cells());\n\n  /** The tab index for the grid. */\n  readonly tabIndex = computed(() => this.gridBehavior.gridTabIndex());\n\n  /** Whether the grid is disabled. */\n  readonly disabled = computed(() => this.gridBehavior.gridDisabled());\n\n  /** The ID of the currently active descendant cell. */\n  readonly activeDescendant = computed(() => this.gridBehavior.activeDescendant());\n\n  /** The currently active cell. */\n  readonly activeCell = computed(() => this.gridBehavior.focusBehavior.activeCell());\n\n  /** Whether to pause grid navigation. */\n  readonly pauseNavigation = computed(() =>\n    this.gridBehavior.data\n      .cells()\n      .flat()\n      .reduce((res, c) => res || c.widgetActivated(), false),\n  );\n\n  /** Whether the focus is in the grid. */\n  readonly isFocused = signal(false);\n\n  /** Whether the user is currently dragging to select a range of cells. */\n  readonly dragging = signal(false);\n\n  /** The key for navigating to the previous column. */\n  readonly prevColKey = computed(() =>\n    this.inputs.textDirection() === 'rtl' ? 'ArrowRight' : 'ArrowLeft',\n  );\n\n  /** The key for navigating to the next column. */\n  readonly nextColKey = computed(() =>\n    this.inputs.textDirection() === 'rtl' ? 'ArrowLeft' : 'ArrowRight',\n  );\n\n  /** The keydown event manager for the grid. */\n  readonly keydown = computed(() => {\n    const manager = new KeyboardEventManager();\n\n    if (this.pauseNavigation()) {\n      return manager;\n    }\n\n    manager\n      .on('ArrowUp', () => this.gridBehavior.up())\n      .on('ArrowDown', () => this.gridBehavior.down())\n      .on(this.prevColKey(), () => this.gridBehavior.left())\n      .on(this.nextColKey(), () => this.gridBehavior.right())\n      .on('Home', () => this.gridBehavior.firstInRow())\n      .on('End', () => this.gridBehavior.lastInRow())\n      .on([Modifier.Ctrl], 'Home', () => this.gridBehavior.first())\n      .on([Modifier.Ctrl], 'End', () => this.gridBehavior.last());\n\n    if (this.inputs.enableSelection()) {\n      manager\n        .on(Modifier.Shift, 'ArrowUp', () => this.gridBehavior.rangeSelectUp())\n        .on(Modifier.Shift, 'ArrowDown', () => this.gridBehavior.rangeSelectDown())\n        .on(Modifier.Shift, 'ArrowLeft', () => this.gridBehavior.rangeSelectLeft())\n        .on(Modifier.Shift, 'ArrowRight', () => this.gridBehavior.rangeSelectRight())\n        .on([Modifier.Ctrl, Modifier.Meta], 'A', () => this.gridBehavior.selectAll())\n        .on([Modifier.Shift], ' ', () => this.gridBehavior.selectRow())\n        .on([Modifier.Ctrl, Modifier.Meta], ' ', () => this.gridBehavior.selectCol());\n    }\n\n    return manager;\n  });\n\n  /** The pointerdown event manager for the grid. */\n  readonly pointerdown = computed(() => {\n    const manager = new PointerEventManager();\n\n    manager.on(e => {\n      const cell = this.inputs.getCell(e.target as Element);\n      if (!cell) return;\n\n      this.gridBehavior.gotoCell(cell);\n\n      if (this.inputs.enableSelection()) {\n        this.dragging.set(true);\n      }\n    });\n\n    if (this.inputs.enableSelection()) {\n      manager\n        .on([Modifier.Ctrl, Modifier.Meta], e => {\n          const cell = this.inputs.getCell(e.target as Element);\n          if (!cell) return;\n\n          this.gridBehavior.toggleSelect(cell);\n        })\n        .on(Modifier.Shift, e => {\n          const cell = this.inputs.getCell(e.target as Element);\n          if (!cell) return;\n\n          this.gridBehavior.rangeSelect(cell);\n          this.dragging.set(true);\n        });\n    }\n\n    return manager;\n  });\n\n  /** The pointerup event manager for the grid. */\n  readonly pointerup = computed(() => {\n    const manager = new PointerEventManager();\n\n    if (this.inputs.enableSelection()) {\n      manager.on([Modifier.Shift, Modifier.None], () => {\n        this.dragging.set(false);\n      });\n    }\n\n    return manager;\n  });\n\n  constructor(readonly inputs: GridInputs) {\n    this.gridBehavior = new Grid({\n      ...inputs,\n      cells: computed(() => this.inputs.rows().map(row => row.inputs.cells())),\n    });\n  }\n\n  /** Handles keydown events on the grid. */\n  onKeydown(event: KeyboardEvent) {\n    if (!this.disabled()) {\n      this.keydown().handle(event);\n    }\n  }\n\n  /** Handles pointerdown events on the grid. */\n  onPointerdown(event: PointerEvent) {\n    if (!this.disabled()) {\n      this.pointerdown().handle(event);\n    }\n  }\n\n  /** Handles pointermove events on the grid. */\n  onPointermove(event: PointerEvent) {\n    if (this.disabled()) return;\n    if (!this.inputs.enableSelection()) return;\n    if (!this.dragging()) return;\n\n    const cell = this.inputs.getCell(event.target as Element);\n    if (!cell) return;\n\n    this.gridBehavior.rangeSelect(cell);\n  }\n\n  /** Handles pointerup events on the grid. */\n  onPointerup(event: PointerEvent) {\n    if (!this.disabled()) {\n      this.pointerup().handle(event);\n    }\n  }\n\n  /** Handles focusin events on the grid. */\n  onFocusIn() {\n    this.isFocused.set(true);\n  }\n\n  /** Indicates maybe the losing focus is caused by row/cell deletion. */\n  private readonly _maybeDeletion = signal(false);\n\n  /** Handles focusout events on the grid. */\n  onFocusOut(event: FocusEvent) {\n    const parentEl = this.inputs.element();\n    const targetEl = event.relatedTarget as Node | null;\n\n    // If a `relatedTarget` is null, then it can be caused by either\n    // - Clicking on a non-focusable element, or\n    // - The focused element is removed from the page.\n    if (targetEl === null) {\n      this._maybeDeletion.set(true);\n    }\n\n    if (parentEl.contains(targetEl)) return;\n    this.isFocused.set(false);\n  }\n\n  /** Indicates the losing focus is certainly caused by row/cell deletion. */\n  private readonly _deletion = signal(false);\n\n  /** Resets the active state of the grid if it is empty or stale. */\n  resetStateEffect(): void {\n    const hasReset = this.gridBehavior.resetState();\n\n    // If the active state has been reset right after a focusout event, then\n    // we know it's caused by a row/cell deletion.\n    if (hasReset && this._maybeDeletion()) {\n      this._deletion.set(true);\n    }\n\n    if (this._maybeDeletion()) {\n      this._maybeDeletion.set(false);\n    }\n  }\n\n  /** Focuses on the active cell element. */\n  focusEffect(): void {\n    const activeCell = this.activeCell();\n    const hasFocus = this.isFocused();\n    const deletion = this._deletion();\n    const isRoving = this.inputs.focusMode() === 'roving';\n    if (activeCell !== undefined && isRoving && (hasFocus || deletion)) {\n      activeCell.element().focus();\n\n      if (deletion) {\n        this._deletion.set(false);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../behaviors/signal-like/signal-like';\nimport {GridCell} from '../behaviors/grid';\nimport type {GridPattern} from './grid';\nimport type {GridRowPattern} from './row';\nimport type {GridCellWidgetPattern} from './widget';\n\n/** The inputs for the `GridCellPattern`. */\nexport interface GridCellInputs extends GridCell {\n  /** The `GridPattern` that this cell belongs to. */\n  grid: SignalLike<GridPattern>;\n\n  /** The `GridRowPattern` that this cell belongs to. */\n  row: SignalLike<GridRowPattern>;\n\n  /** The widget pattern contained within this cell, if any. */\n  widget: SignalLike<GridCellWidgetPattern | undefined>;\n\n  /** The index of this cell's row within the grid. */\n  rowIndex: SignalLike<number | undefined>;\n\n  /** The index of this cell's column within the grid. */\n  colIndex: SignalLike<number | undefined>;\n}\n\n/** The UI pattern for a grid cell. */\nexport class GridCellPattern implements GridCell {\n  /** A unique identifier for the cell. */\n  readonly id: SignalLike<string>;\n\n  /** Whether a cell is disabled. */\n  readonly disabled: SignalLike<boolean>;\n\n  /** Whether the cell is selected. */\n  readonly selected: WritableSignalLike<boolean>;\n\n  /** Whether the cell is selectable. */\n  readonly selectable: SignalLike<boolean>;\n\n  /** The number of rows the cell should span. */\n  readonly rowSpan: SignalLike<number>;\n\n  /** The number of columns the cell should span. */\n  readonly colSpan: SignalLike<number>;\n\n  /** The `aria-selected` attribute for the cell. */\n  readonly ariaSelected = computed<boolean | undefined>(() =>\n    this.inputs.grid().inputs.enableSelection() && this.selectable() ? this.selected() : undefined,\n  );\n\n  /** The `aria-rowindex` attribute for the cell. */\n  readonly ariaRowIndex = computed(\n    () =>\n      this.inputs.row().rowIndex() ??\n      this.inputs.rowIndex() ??\n      this.inputs.grid().gridBehavior.rowIndex(this),\n  );\n\n  /** The `aria-colindex` attribute for the cell. */\n  readonly ariaColIndex = computed(\n    () => this.inputs.colIndex() ?? this.inputs.grid().gridBehavior.colIndex(this),\n  );\n\n  /** The html element that should receive focus. */\n  readonly element: SignalLike<HTMLElement> = computed(\n    () => this.inputs.widget()?.element() ?? this.inputs.element(),\n  );\n\n  /** Whether the cell is active. */\n  readonly active = computed(() => this.inputs.grid().activeCell() === this);\n\n  /** The internal tab index calculation for the cell. */\n  private readonly _tabIndex: SignalLike<-1 | 0> = computed(() =>\n    this.inputs.grid().gridBehavior.cellTabIndex(this),\n  );\n\n  /** The `tabindex` for the cell. If the cell contains a widget, the cell's tabindex is -1. */\n  readonly tabIndex: SignalLike<-1 | 0> = computed(() =>\n    this.inputs.widget() !== undefined ? -1 : this._tabIndex(),\n  );\n\n  /** Whether the widget within the cell is activated. */\n  readonly widgetActivated: SignalLike<boolean> = computed(\n    () => this.inputs.widget()?.inputs.activate() ?? false,\n  );\n\n  constructor(readonly inputs: GridCellInputs) {\n    this.id = inputs.id;\n    this.disabled = inputs.disabled;\n    this.rowSpan = inputs.rowSpan;\n    this.colSpan = inputs.colSpan;\n    this.selected = inputs.selected;\n    this.selectable = inputs.selectable;\n  }\n\n  /** Gets the `tabindex` for the widget within the cell. */\n  widgetTabIndex(): -1 | 0 {\n    return this._tabIndex();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../behaviors/signal-like/signal-like';\nimport type {GridCellPattern} from './cell';\n\n/** The inputs for the `GridCellWidgetPattern`. */\nexport interface GridCellWidgetInputs {\n  /** The `GridCellPattern` that this widget belongs to. */\n  cell: SignalLike<GridCellPattern>;\n\n  /** The html element that should receive focus. */\n  element: SignalLike<HTMLElement>;\n\n  /**\n   * Whether the widget is activated, which pauses grid navigation to allow interaction\n   * with the widget.\n   */\n  activate: WritableSignalLike<boolean>;\n}\n\n/** The UI pattern for a widget inside a grid cell. */\nexport class GridCellWidgetPattern {\n  /** The html element that should receive focus. */\n  readonly element: SignalLike<HTMLElement>;\n\n  /** The `tabindex` for the widget. */\n  readonly tabIndex: SignalLike<-1 | 0> = computed(() => this.inputs.cell().widgetTabIndex());\n\n  /** Whether the widget is in an active state (i.e. its containing cell is active). */\n  readonly active: SignalLike<boolean> = computed(() => this.inputs.cell().active());\n\n  constructor(readonly inputs: GridCellWidgetInputs) {\n    this.element = inputs.element;\n  }\n}\n"],"names":["Modifier","EventManager","options","preventDefault","modifiers","key","handler","_normalizeInputs","args","configs","push","matcher","event","_isMatch","MouseButton","PointerEventManager","stopPropagation","on","button","computed","Math","max","_rowCountByCol","values","_colCountsByRow","_coordsMap","coordsMap","Map","rowIndex","cells","length","row","visitedCoords","has","colIndex","rowspan","cell","rowSpan","rowOffset","col","colOffset","add","spanCoords","set","coords","cellMap","colCount","colCountByRow","get","newColCount","signal","activeCell","undefined","stateStale","activeCoordsCell","inputs","grid","getCell","activeCoords","activeCellNotValid","activeCellCoords","activeCellMismatch","gridDisabled","focusMode","currentActiveCell","disabled","gridCells","every","constructor","getCellTabindex","Right","GridNavigation","gridFocus","focusCell","wrap","direction","rowWrap","colWrap","_peekDirectional","fromCoords","advance","nextCoords","peek","gotoCoords","peekFirst","peekLast","Left","fromCell","maxRowCount","select","toCoords","_validCells","selected","deselect","toggle","update","state","maxColCount","Grid","data","navigationBehavior","focusBehavior","gridTabIndex","activeDescendant","GridData","selectionBehavior","GridSelection","index","getCoords","Up","rangeSelectUp","Down","rangeSelectDown","_rangeSelectCoords","rangeSelectLeft","rangeSelectRight","first","firstInRow","last","selectRow","deselectAll","selectAll","gotoCell","rangeSelect","gridBehavior","pauseNavigation","flat","reduce","res","c","widgetActivated","isFocused","dragging","textDirection","keydown","manager","KeyboardEventManager","up","down","prevColKey","left","nextColKey","lastInRow","Ctrl","enableSelection","Shift","Meta","selectCol","e","target","None","rows","map","onKeydown","handle","onPointerup","pointerup","colSpan","selectable","ariaRowIndex","widgetTabIndex"],"mappings":"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"}