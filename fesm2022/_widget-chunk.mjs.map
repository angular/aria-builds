{"version":3,"file":"_widget-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/event-manager/event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/event-manager/keyboard-event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/event-manager/pointer-event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-data.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-focus.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-navigation.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-selection.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/grid.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/cell.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/widget.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * An event that supports modifier keys.\n *\n * Matches the native KeyboardEvent, MouseEvent, and TouchEvent.\n */\nexport interface EventWithModifiers extends Event {\n  ctrlKey: boolean;\n  shiftKey: boolean;\n  altKey: boolean;\n  metaKey: boolean;\n}\n\n/**\n * Options that are applicable to all event handlers.\n *\n * This library has not yet had a need for stopPropagationImmediate.\n */\nexport interface EventHandlerOptions {\n  stopPropagation: boolean;\n  preventDefault: boolean;\n}\n\n/** A basic event handler. */\nexport type EventHandler<T extends Event> = (event: T) => void;\n\n/** A function that determines whether an event is to be handled. */\nexport type EventMatcher<T extends Event> = (event: T) => boolean;\n\n/** A config that specifies how to handle a particular event. */\nexport interface EventHandlerConfig<T extends Event> extends EventHandlerOptions {\n  matcher: EventMatcher<T>;\n  handler: EventHandler<T>;\n}\n\n/** Bit flag representation of the possible modifier keys that can be present on an event. */\nexport enum Modifier {\n  None = 0,\n  Ctrl = 0b1,\n  Shift = 0b10,\n  Alt = 0b100,\n  Meta = 0b1000,\n  Any = 'Any',\n}\n\nexport type ModifierInputs = Modifier | Modifier[];\n\n/**\n * Abstract base class for all event managers.\n *\n * Event managers are designed to normalize how event handlers are authored and create a safety net\n * for common event handling gotchas like remembering to call preventDefault or stopPropagation.\n */\nexport abstract class EventManager<T extends Event> {\n  protected configs: EventHandlerConfig<T>[] = [];\n  abstract options: EventHandlerOptions;\n\n  /** Runs the handlers that match with the given event. */\n  handle(event: T): void {\n    for (const config of this.configs) {\n      if (config.matcher(event)) {\n        config.handler(event);\n\n        if (config.preventDefault) {\n          event.preventDefault();\n        }\n\n        if (config.stopPropagation) {\n          event.stopPropagation();\n        }\n      }\n    }\n  }\n\n  /** Configures the event manager to handle specific events. (See subclasses for more). */\n  abstract on(...args: [...unknown[]]): this;\n}\n\n/** Gets bit flag representation of the modifier keys present on the given event. */\nexport function getModifiers(event: EventWithModifiers): number {\n  return (\n    (+event.ctrlKey && Modifier.Ctrl) |\n    (+event.shiftKey && Modifier.Shift) |\n    (+event.altKey && Modifier.Alt) |\n    (+event.metaKey && Modifier.Meta)\n  );\n}\n\n/**\n * Checks if the given event has modifiers that are an exact match for any of the given modifier\n * flag combinations.\n */\nexport function hasModifiers(event: EventWithModifiers, modifiers: ModifierInputs): boolean {\n  const eventModifiers = getModifiers(event);\n  const modifiersList = Array.isArray(modifiers) ? modifiers : [modifiers];\n\n  if (modifiersList.includes(Modifier.Any)) {\n    return true;\n  }\n\n  return modifiersList.some(modifiers => eventModifiers === modifiers);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SignalLike} from '../signal-like/signal-like';\nimport {\n  EventHandler,\n  EventHandlerOptions,\n  EventManager,\n  hasModifiers,\n  ModifierInputs,\n  Modifier,\n} from './event-manager';\n\n/**\n * Used to represent a keycode.\n *\n * This is used to match whether an events keycode should be handled. The ability to match using a\n * string, SignalLike, or Regexp gives us more flexibility when authoring event handlers.\n */\ntype KeyCode = string | SignalLike<string> | RegExp;\n\n/**\n * An event manager that is specialized for handling keyboard events. By default this manager stops\n * propagation and prevents default on all events it handles.\n */\nexport class KeyboardEventManager<T extends KeyboardEvent> extends EventManager<T> {\n  options: EventHandlerOptions = {\n    preventDefault: true,\n    stopPropagation: true,\n  };\n\n  /** Configures this event manager to handle events with a specific key and no modifiers. */\n  on(key: KeyCode, handler: EventHandler<T>, options?: Partial<EventHandlerOptions>): this;\n\n  /**  Configures this event manager to handle events with a specific modifer and key combination. */\n  on(\n    modifiers: ModifierInputs,\n    key: KeyCode,\n    handler: EventHandler<T>,\n    options?: Partial<EventHandlerOptions>,\n  ): this;\n\n  on(...args: any[]) {\n    const {modifiers, key, handler, options} = this._normalizeInputs(...args);\n\n    this.configs.push({\n      handler: handler,\n      matcher: event => this._isMatch(event, key, modifiers),\n      ...this.options,\n      ...options,\n    });\n\n    return this;\n  }\n\n  private _normalizeInputs(...args: any[]) {\n    const withModifiers = Array.isArray(args[0]) || args[0] in Modifier;\n    const modifiers = withModifiers ? args[0] : Modifier.None;\n    const key = withModifiers ? args[1] : args[0];\n    const handler = withModifiers ? args[2] : args[1];\n    const options = withModifiers ? args[3] : args[2];\n\n    return {\n      key: key as KeyCode,\n      handler: handler as EventHandler<T>,\n      modifiers: modifiers as ModifierInputs,\n      options: (options ?? {}) as Partial<EventHandlerOptions>,\n    };\n  }\n\n  private _isMatch(event: T, key: KeyCode, modifiers: ModifierInputs) {\n    if (!hasModifiers(event, modifiers)) {\n      return false;\n    }\n\n    if (key instanceof RegExp) {\n      return key.test(event.key);\n    }\n\n    const keyStr = typeof key === 'string' ? key : key();\n    return keyStr.toLowerCase() === event.key.toLowerCase();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  EventHandler,\n  EventHandlerOptions,\n  EventManager,\n  hasModifiers,\n  ModifierInputs,\n  Modifier,\n} from './event-manager';\n\n/**\n * The different mouse buttons that may appear on a pointer event.\n */\nexport enum MouseButton {\n  Main = 0,\n  Auxiliary = 1,\n  Secondary = 2,\n}\n\n/** An event manager that is specialized for handling pointer events. */\nexport class PointerEventManager<T extends PointerEvent> extends EventManager<T> {\n  options: EventHandlerOptions = {\n    preventDefault: false,\n    stopPropagation: false,\n  };\n\n  /**\n   * Configures this event manager to handle events with a specific modifer and mouse button\n   * combination.\n   */\n  on(button: MouseButton, modifiers: ModifierInputs, handler: EventHandler<T>): this;\n\n  /**\n   * Configures this event manager to handle events with a specific mouse button and no modifiers.\n   */\n  on(modifiers: ModifierInputs, handler: EventHandler<T>): this;\n\n  /**\n   * Configures this event manager to handle events with the main mouse button and no modifiers.\n   *\n   * @param handler The handler function\n   * @param options Options for whether to stop propagation or prevent default.\n   */\n  on(handler: EventHandler<T>): this;\n\n  on(...args: any[]) {\n    const {button, handler, modifiers} = this._normalizeInputs(...args);\n\n    this.configs.push({\n      handler,\n      matcher: event => this._isMatch(event, button, modifiers),\n      ...this.options,\n    });\n    return this;\n  }\n\n  private _normalizeInputs(...args: any[]) {\n    if (args.length === 3) {\n      return {\n        button: args[0] as MouseButton,\n        modifiers: args[1] as ModifierInputs,\n        handler: args[2] as EventHandler<T>,\n      };\n    }\n\n    if (args.length === 2) {\n      return {\n        button: MouseButton.Main,\n        modifiers: args[0] as ModifierInputs,\n        handler: args[1] as EventHandler<T>,\n      };\n    }\n\n    return {\n      button: MouseButton.Main,\n      modifiers: Modifier.None,\n      handler: args[0] as EventHandler<T>,\n    };\n  }\n\n  _isMatch(event: PointerEvent, button: MouseButton, modifiers: ModifierInputs) {\n    return button === (event.button ?? 0) && hasModifiers(event, modifiers);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\n\n/** Represents coordinates in a grid. */\nexport interface RowCol {\n  /** The row index. */\n  row: number;\n\n  /** The column index. */\n  col: number;\n}\n\n/** A string representation of grid coordinates. */\ntype CoordString = `${RowCol['row']}:${RowCol['col']}`;\n\n/** The base interface for a cell in a grid. */\nexport interface BaseGridCell {\n  /** The number of rows the cell should span. */\n  rowSpan: SignalLike<number>;\n\n  /** The number of columns the cell should span. */\n  colSpan: SignalLike<number>;\n}\n\n/** Represents the required inputs for GridData. */\nexport interface GridDataInputs<T extends BaseGridCell> {\n  /** The two-dimensional array of cells that represents the grid. */\n  cells: SignalLike<T[][]>;\n}\n\n/** Controls internal coordinates for a grid of items. */\nexport class GridData<T extends BaseGridCell> {\n  /** The two-dimensional array of cells that represents the grid. */\n  readonly cells: SignalLike<T[][]>;\n\n  /** The maximum number of rows in the grid, accounting for row spans. */\n  readonly maxRowCount = computed<number>(() => Math.max(...this._rowCountByCol().values(), 0));\n\n  /** The maximum number of columns in the grid, accounting for column spans. */\n  readonly maxColCount = computed<number>(() => Math.max(...this._colCountsByRow().values(), 0));\n\n  /** A map from a cell to its primary and spanned coordinates. */\n  private readonly _coordsMap = computed<Map<T, {coords: RowCol; spanCoords: RowCol[]}>>(() => {\n    const coordsMap = new Map();\n    const visitedCoords = new Set();\n\n    for (let rowIndex = 0; rowIndex < this.cells().length; rowIndex++) {\n      let colIndex = 0;\n      const row = this.cells()[rowIndex];\n\n      for (const cell of row) {\n        // Skip past cells that are already taken.\n        while (visitedCoords.has(`${rowIndex}:${colIndex}`)) {\n          colIndex++;\n        }\n\n        const rowspan = cell.rowSpan();\n        const colspan = cell.colSpan();\n        const spanCoords: RowCol[] = [];\n\n        for (let rowOffset = 0; rowOffset < rowspan; rowOffset++) {\n          const row = rowIndex + rowOffset;\n          for (let colOffset = 0; colOffset < colspan; colOffset++) {\n            const col = colIndex + colOffset;\n            visitedCoords.add(`${row}:${col}`);\n            spanCoords.push({row, col});\n          }\n        }\n        coordsMap.set(cell, {coords: spanCoords[0], spanCoords});\n\n        colIndex += colspan;\n      }\n    }\n\n    return coordsMap;\n  });\n\n  /** A map from a coordinate string to the cell at that coordinate. */\n  private readonly _cellMap = computed<Map<CoordString, T>>(() => {\n    const cellMap = new Map();\n    for (const [cell, {spanCoords}] of this._coordsMap().entries()) {\n      for (const {row, col} of spanCoords) {\n        cellMap.set(`${row}:${col}`, cell);\n      }\n    }\n    return cellMap;\n  });\n\n  /** A map from a row index to the number of columns in that row. */\n  private readonly _colCountsByRow = computed<Map<number, number>>(() => {\n    const colCountByRow = new Map();\n    for (const [_, {spanCoords}] of this._coordsMap().entries()) {\n      for (const {row, col} of spanCoords) {\n        const colCount = colCountByRow.get(row);\n        const newColCount = col + 1;\n        if (colCount === undefined || colCount < newColCount) {\n          colCountByRow.set(row, newColCount);\n        }\n      }\n    }\n    return colCountByRow;\n  });\n\n  /** A map from a column index to the number of rows in that column. */\n  private readonly _rowCountByCol = computed<Map<number, number>>(() => {\n    const rowCountByCol = new Map();\n    for (const [_, {spanCoords}] of this._coordsMap().entries()) {\n      for (const {row, col} of spanCoords) {\n        const rowCount = rowCountByCol.get(col);\n        const newRowCount = row + 1;\n        if (rowCount === undefined || rowCount < newRowCount) {\n          rowCountByCol.set(col, newRowCount);\n        }\n      }\n    }\n    return rowCountByCol;\n  });\n\n  constructor(readonly inputs: GridDataInputs<T>) {\n    this.cells = this.inputs.cells;\n  }\n\n  /** Gets the cell at the given coordinates. */\n  getCell(rowCol: RowCol): T | undefined {\n    return this._cellMap().get(`${rowCol.row}:${rowCol.col}`);\n  }\n\n  /** Gets the primary coordinates of the given cell. */\n  getCoords(cell: T): RowCol | undefined {\n    return this._coordsMap().get(cell)?.coords;\n  }\n\n  /** Gets all coordinates that the given cell spans. */\n  getAllCoords(cell: T): RowCol[] | undefined {\n    return this._coordsMap().get(cell)?.spanCoords;\n  }\n\n  /** Gets the number of rows in the given column. */\n  getRowCount(col: number): number | undefined {\n    return this._rowCountByCol().get(col);\n  }\n\n  /** Gets the number of columns in the given row. */\n  getColCount(row: number): number | undefined {\n    return this._colCountsByRow().get(row);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\nimport type {GridData, BaseGridCell, RowCol} from './grid-data';\n\n/** Represents an cell in a grid, such as a grid cell, that may receive focus. */\nexport interface GridFocusCell extends BaseGridCell {\n  /** A unique identifier for the cell. */\n  id: SignalLike<string>;\n\n  /** The html element that should receive focus. */\n  element: SignalLike<HTMLElement>;\n\n  /** Whether a cell is disabled. */\n  disabled: SignalLike<boolean>;\n}\n\n/** Represents the required inputs for a grid that contains focusable cells. */\nexport interface GridFocusInputs {\n  /** The focus strategy used by the grid. */\n  focusMode: SignalLike<'roving' | 'activedescendant'>;\n\n  /** Whether the grid is disabled. */\n  disabled: SignalLike<boolean>;\n\n  /** Whether disabled cells in the grid should be focusable. */\n  softDisabled: SignalLike<boolean>;\n}\n\n/** Dependencies for the `GridFocus` class. */\ninterface GridFocusDeps<T extends GridFocusCell> {\n  /** The `GridData` instance that this focus manager operates on. */\n  grid: GridData<T>;\n}\n\n/** Controls focus for a 2D grid of cells. */\nexport class GridFocus<T extends GridFocusCell> {\n  /** The current active cell. */\n  readonly activeCell = signal<T | undefined>(undefined);\n\n  /** The current active cell coordinates. */\n  readonly activeCoords = signal<RowCol>({row: -1, col: -1});\n\n  /** Whether the grid active state is empty (no active cell or coordinates). */\n  readonly stateEmpty = computed(\n    () =>\n      this.activeCell() === undefined ||\n      (this.activeCoords().row === -1 && this.activeCoords().col === -1),\n  );\n\n  /**\n   * Whether the grid focus state is stale.\n   *\n   * A stale state means the active cell or coordinates are no longer valid based on the\n   * current grid data, for example if the underlying cells have changed.\n   * A stale state should be re-initialized.\n   */\n  readonly stateStale = computed(() => {\n    if (this.stateEmpty()) {\n      return true;\n    }\n\n    const activeCell = this.activeCell();\n    const activeCellCoords = this.inputs.grid.getCoords(activeCell!);\n    const activeCoords = this.activeCoords();\n    const activeCoordsCell = this.inputs.grid.getCell(activeCoords);\n\n    const activeCellNotValid = activeCellCoords === undefined;\n    const activeCellMismatch = activeCell !== activeCoordsCell;\n    return activeCellNotValid || activeCellMismatch;\n  });\n\n  /** The id of the current active cell, for ARIA activedescendant. */\n  readonly activeDescendant = computed<string | undefined>(() => {\n    if (this.gridDisabled() || this.inputs.focusMode() === 'roving') {\n      return undefined;\n    }\n    const currentActiveCell = this.activeCell();\n    return currentActiveCell ? currentActiveCell.id() : undefined;\n  });\n\n  /** Whether the grid is in a disabled state. */\n  readonly gridDisabled = computed<boolean>(() => {\n    if (this.inputs.disabled()) {\n      return true;\n    }\n    const gridCells = this.inputs.grid.cells();\n    return gridCells.length === 0 || gridCells.every(row => row.every(cell => cell.disabled()));\n  });\n\n  /** The tab index for the grid container. */\n  readonly gridTabIndex = computed<-1 | 0>(() => {\n    if (this.gridDisabled()) {\n      return 0;\n    }\n    return this.inputs.focusMode() === 'activedescendant' ? 0 : -1;\n  });\n\n  constructor(readonly inputs: GridFocusInputs & GridFocusDeps<T>) {}\n\n  /** Returns the tab index for the given grid cell cell. */\n  getCellTabIndex(cell: T): -1 | 0 {\n    if (this.gridDisabled()) {\n      return -1;\n    }\n    if (this.inputs.focusMode() === 'activedescendant') {\n      return -1;\n    }\n    return this.activeCell() === cell ? 0 : -1;\n  }\n\n  /** Returns true if the given cell can be navigated to. */\n  isFocusable(cell: T): boolean {\n    return !cell.disabled() || this.inputs.softDisabled();\n  }\n\n  /** Focuses the given cell. */\n  focusCell(cell: T): boolean {\n    if (this.gridDisabled()) {\n      return false;\n    }\n\n    if (!this.isFocusable(cell)) {\n      return false;\n    }\n\n    if (this.inputs.grid.getCoords(cell) === undefined) {\n      return false;\n    }\n\n    this.activeCoords.set(this.inputs.grid.getCoords(cell)!);\n    this.activeCell.set(cell);\n\n    return true;\n  }\n\n  /** Moves focus to the cell at the given coordinates if it's part of a focusable cell. */\n  focusCoordinates(coords: RowCol): boolean {\n    if (this.gridDisabled() && !this.inputs.softDisabled()) {\n      return false;\n    }\n\n    const cell = this.inputs.grid.getCell(coords);\n\n    if (!cell || !this.isFocusable(cell)) {\n      return false;\n    }\n\n    if (this.inputs.grid.getCell(coords) === undefined) {\n      return false;\n    }\n\n    this.activeCoords.set(coords);\n    this.activeCell.set(this.inputs.grid.getCell(coords));\n\n    return true;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\nimport {GridFocus, GridFocusCell, GridFocusInputs} from './grid-focus';\nimport {GridData, RowCol} from './grid-data';\n\n/** A utility type that ensures an object has exactly one key from a given set. */\ntype ExactlyOneKey<T, K extends keyof T = keyof T> = {\n  [P in K]: Record<P, T[P]> & Partial<Record<Exclude<K, P>, never>>;\n}[K];\n\n/** Represents a directional change in the grid, either by row or by column. */\ntype Delta = ExactlyOneKey<{row: -1 | 1; col: -1 | 1}>;\n\n/** Constants for the four cardinal directions. */\nexport const direction: Record<'Up' | 'Down' | 'Left' | 'Right', Delta> = {\n  Up: {row: -1},\n  Down: {row: 1},\n  Left: {col: -1},\n  Right: {col: 1},\n} as const;\n\n/** The wrapping behavior for keyboard navigation. */\nexport type WrapStrategy = 'continuous' | 'loop' | 'nowrap';\n\n/** Represents an item in a collection, such as a listbox option, than can be navigated to. */\nexport interface GridNavigationCell extends GridFocusCell {}\n\n/** Represents the required inputs for a collection that has navigable items. */\nexport interface GridNavigationInputs extends GridFocusInputs {\n  /** The wrapping behavior for keyboard navigation along the row axis. */\n  rowWrap: SignalLike<WrapStrategy>;\n\n  /** The wrapping behavior for keyboard navigation along the column axis. */\n  colWrap: SignalLike<WrapStrategy>;\n}\n\n/** Dependencies for the `GridNavigation` class. */\ninterface GridNavigationDeps<T extends GridNavigationCell> {\n  /** The `GridData` instance that this navigation manager operates on. */\n  grid: GridData<T>;\n\n  /** The `GridFocus` instance that this navigation manager uses to manage focus. */\n  gridFocus: GridFocus<T>;\n}\n\n/** Controls navigation for a grid of items. */\nexport class GridNavigation<T extends GridNavigationCell> {\n  /** The maximum number of steps to take when searching for the next cell. */\n  private _maxSteps = computed<number>(\n    () => this.inputs.grid.maxRowCount() * this.inputs.grid.maxColCount(),\n  );\n\n  constructor(readonly inputs: GridNavigationInputs & GridNavigationDeps<T>) {}\n\n  /** Navigates to the given item. */\n  gotoCell(cell: T): boolean {\n    return this.inputs.gridFocus.focusCell(cell);\n  }\n\n  /** Navigates to the given coordinates. */\n  gotoCoords(coords: RowCol): boolean {\n    return this.inputs.gridFocus.focusCoordinates(coords);\n  }\n\n  /**\n   * Gets the coordinates of the next focusable cell in a given direction, without changing focus.\n   */\n  peek(\n    direction: Delta,\n    fromCoords: RowCol,\n    wrap?: WrapStrategy,\n    allowDisabled?: boolean,\n  ): RowCol | undefined {\n    wrap = wrap ?? (direction.row !== undefined ? this.inputs.rowWrap() : this.inputs.colWrap());\n    return this._peekDirectional(direction, fromCoords, wrap, allowDisabled);\n  }\n\n  /**\n   * Navigates to the next focusable cell in a given direction.\n   */\n  advance(direction: Delta): boolean {\n    const nextCoords = this.peek(direction, this.inputs.gridFocus.activeCoords());\n    return !!nextCoords && this.gotoCoords(nextCoords);\n  }\n\n  /**\n   * Gets the coordinates of the first focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  peekFirst(row?: number, allowDisabled?: boolean): RowCol | undefined {\n    const fromCoords = {\n      row: row ?? 0,\n      col: -1,\n    };\n    return row === undefined\n      ? this._peekDirectional(direction.Right, fromCoords, 'continuous', allowDisabled)\n      : this._peekDirectional(direction.Right, fromCoords, 'nowrap', allowDisabled);\n  }\n\n  /**\n   * Navigates to the first focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  first(row?: number): boolean {\n    const nextCoords = this.peekFirst(row);\n    return !!nextCoords && this.gotoCoords(nextCoords);\n  }\n\n  /**\n   * Gets the coordinates of the last focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  peekLast(row?: number, allowDisabled?: boolean): RowCol | undefined {\n    const fromCoords = {\n      row: row ?? this.inputs.grid.maxRowCount() - 1,\n      col: this.inputs.grid.maxColCount(),\n    };\n    return row === undefined\n      ? this._peekDirectional(direction.Left, fromCoords, 'continuous', allowDisabled)\n      : this._peekDirectional(direction.Left, fromCoords, 'nowrap', allowDisabled);\n  }\n\n  /**\n   * Navigates to the last focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  last(row?: number): boolean {\n    const nextCoords = this.peekLast(row);\n    return !!nextCoords && this.gotoCoords(nextCoords);\n  }\n\n  /**\n   * Finds the next focusable cell in a given direction based on the wrapping behavior.\n   */\n  private _peekDirectional(\n    delta: Delta,\n    fromCoords: RowCol,\n    wrap: 'continuous' | 'loop' | 'nowrap',\n    allowDisabled: boolean = false,\n  ): RowCol | undefined {\n    const fromCell = this.inputs.grid.getCell(fromCoords);\n    const maxRowCount = this.inputs.grid.maxRowCount();\n    const maxColCount = this.inputs.grid.maxColCount();\n    const rowDelta = delta.row ?? 0;\n    const colDelta = delta.col ?? 0;\n    let nextCoords = {...fromCoords};\n\n    for (let step = 0; step < this._maxSteps(); step++) {\n      const isWrapping =\n        nextCoords.col + colDelta < 0 ||\n        nextCoords.col + colDelta >= maxColCount ||\n        nextCoords.row + rowDelta < 0 ||\n        nextCoords.row + rowDelta >= maxRowCount;\n\n      if (wrap === 'nowrap' && isWrapping) return;\n\n      if (wrap === 'continuous') {\n        const generalDelta = delta.row ?? delta.col;\n        const rowStep = isWrapping ? generalDelta : rowDelta;\n        const colStep = isWrapping ? generalDelta : colDelta;\n\n        nextCoords = {\n          row: (nextCoords.row + rowStep + maxRowCount) % maxRowCount,\n          col: (nextCoords.col + colStep + maxColCount) % maxColCount,\n        };\n      }\n\n      if (wrap === 'loop') {\n        nextCoords = {\n          row: (nextCoords.row + rowDelta + maxRowCount) % maxRowCount,\n          col: (nextCoords.col + colDelta + maxColCount) % maxColCount,\n        };\n      }\n\n      if (wrap === 'nowrap') {\n        nextCoords = {\n          row: nextCoords.row + rowDelta,\n          col: nextCoords.col + colDelta,\n        };\n      }\n\n      // Back to original coordinates.\n      if (nextCoords.row === fromCoords.row && nextCoords.col === fromCoords.col) {\n        return undefined;\n      }\n\n      const nextCell = this.inputs.grid.getCell(nextCoords);\n      if (\n        nextCell !== undefined &&\n        nextCell !== fromCell &&\n        (allowDisabled || this.inputs.gridFocus.isFocusable(nextCell))\n      ) {\n        return nextCoords;\n      }\n    }\n\n    return undefined;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SignalLike, WritableSignalLike} from '../signal-like/signal-like';\nimport {GridFocus, GridFocusCell, GridFocusInputs} from './grid-focus';\nimport {GridData, RowCol} from './grid-data';\nimport {signal} from '@angular/core';\n\n/** Represents a cell in a grid that can be selected. */\nexport interface GridSelectionCell extends GridFocusCell {\n  /** Whether the cell is selected. */\n  selected: WritableSignalLike<boolean>;\n\n  /** Whether the cell is selectable. */\n  selectable: SignalLike<boolean>;\n}\n\n/** Represents the required inputs for a grid that has selectable cells. */\nexport interface GridSelectionInputs extends GridFocusInputs {}\n\n/** Dependencies for the `GridSelection` class. */\ninterface GridSelectionDeps<T extends GridSelectionCell> {\n  /** The `GridData` instance that this selection manager operates on. */\n  grid: GridData<T>;\n\n  /** The `GridFocus` instance that this selection manager uses to manage focus. */\n  gridFocus: GridFocus<T>;\n}\n\n/** Controls selection for a grid of items. */\nexport class GridSelection<T extends GridSelectionCell> {\n  /** The list of cells that were changed in the last selection operation. */\n  private readonly _undoList: WritableSignalLike<[T, boolean][]> = signal([]);\n\n  constructor(readonly inputs: GridSelectionInputs & GridSelectionDeps<T>) {}\n\n  /** Reverts the last selection change. */\n  undo(): void {\n    for (const [cell, oldState] of this._undoList()) {\n      cell.selected.set(oldState);\n    }\n    this._undoList.set([]);\n  }\n\n  /** Selects one or more cells in a given range. */\n  select(fromCoords: RowCol, toCoords?: RowCol): void {\n    this._updateState(fromCoords, toCoords ?? fromCoords, () => true);\n  }\n\n  /** Deselects one or more cells in a given range. */\n  deselect(fromCoords: RowCol, toCoords?: RowCol): void {\n    this._updateState(fromCoords, toCoords ?? fromCoords, () => false);\n  }\n\n  /** Toggles the selection state of one or more cells in a given range. */\n  toggle(fromCoords: RowCol, toCoords?: RowCol): void {\n    this._updateState(fromCoords, toCoords ?? fromCoords, oldState => !oldState);\n  }\n\n  /** Selects all valid cells in the grid. */\n  selectAll(): void {\n    this._updateState(\n      {row: 0, col: 0},\n      {row: this.inputs.grid.maxRowCount(), col: this.inputs.grid.maxColCount()},\n      () => true,\n    );\n  }\n\n  /** Deselects all valid cells in the grid. */\n  deselectAll(): void {\n    this._updateState(\n      {row: 0, col: 0},\n      {row: this.inputs.grid.maxRowCount(), col: this.inputs.grid.maxColCount()},\n      () => false,\n    );\n  }\n\n  /** Whether a cell is selctable. */\n  isSelectable(cell: T) {\n    return cell.selectable() && !cell.disabled();\n  }\n\n  /** A generator that yields all cells within a given range. */\n  *_validCells(fromCoords: RowCol, toCoords: RowCol): Generator<T> {\n    const startRow = Math.min(fromCoords.row, toCoords.row);\n    const startCol = Math.min(fromCoords.col, toCoords.col);\n    const endRow = Math.max(fromCoords.row, toCoords.row);\n    const endCol = Math.max(fromCoords.col, toCoords.col);\n    const visited = new Set<T>();\n    for (let row = startRow; row < endRow + 1; row++) {\n      for (let col = startCol; col < endCol + 1; col++) {\n        const cell = this.inputs.grid.getCell({row, col});\n        if (cell === undefined) continue;\n        if (!this.isSelectable(cell)) continue;\n        if (visited.has(cell)) continue;\n        visited.add(cell);\n        yield cell;\n      }\n    }\n  }\n\n  /**\n   * Updates the selection state of cells in a given range and preserves previous changes\n   * to a undo list.\n   */\n  private _updateState(\n    fromCoords: RowCol,\n    toCoords: RowCol,\n    stateFn: (oldState: boolean) => boolean,\n  ): void {\n    const undoList: [T, boolean][] = [];\n    for (const cell of this._validCells(fromCoords, toCoords)) {\n      const oldState = cell.selected();\n      undoList.push([cell, oldState]);\n      cell.selected.set(stateFn(oldState));\n    }\n    this._undoList.set(undoList);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, linkedSignal, signal} from '@angular/core';\nimport {GridData, BaseGridCell, GridDataInputs, RowCol} from './grid-data';\nimport {GridFocus, GridFocusCell, GridFocusInputs} from './grid-focus';\nimport {\n  direction,\n  GridNavigation,\n  GridNavigationCell,\n  GridNavigationInputs,\n} from './grid-navigation';\nimport {GridSelectionCell, GridSelectionInputs, GridSelection} from './grid-selection';\nimport {SignalLike} from '../signal-like/signal-like';\n\n/** The selection operations that can be performed after a navigation operation. */\nexport interface NavOptions {\n  /** Toggles the selection state of the active cell. */\n  toggle?: boolean;\n\n  /**\n   * Toggles the selection state of the active cell, and deselects all other cells if the\n   * active cell is selected. If the active cell is the only selected cell, it will be deselected.\n   */\n  toggleOne?: boolean;\n\n  /** Selects the active cell, preserving the selection state of other cells. */\n  select?: boolean;\n\n  /** Deselects all other cells and selects the active cell. */\n  selectOne?: boolean;\n\n  /**\n   * Moves the selection anchor to the active cell and updates the selection to include all\n   * cells between the anchor and the active cell.\n   */\n  anchor?: boolean;\n}\n\n/** A type that represents a cell in a grid, combining all cell-related interfaces. */\nexport type GridCell = BaseGridCell & GridFocusCell & GridNavigationCell & GridSelectionCell;\n\n/** Represents the required inputs for a grid. */\nexport type GridInputs<T extends GridCell> = GridDataInputs<T> &\n  GridFocusInputs &\n  GridNavigationInputs &\n  GridSelectionInputs;\n\n/** The main class that orchestrates the grid behaviors. */\nexport class Grid<T extends GridCell> {\n  /** The underlying data structure for the grid. */\n  readonly data: GridData<T>;\n\n  /** Controls focus for the grid. */\n  readonly focusBehavior: GridFocus<T>;\n\n  /** Controls navigation for the grid. */\n  readonly navigationBehavior: GridNavigation<T>;\n\n  /** Controls selection for the grid. */\n  readonly selectionBehavior: GridSelection<T>;\n\n  /** The anchor point for range selection, linked to the active coordinates. */\n  readonly selectionAnchor = linkedSignal<RowCol>(() => this.focusBehavior.activeCoords());\n\n  /** The cell at the selection anchor. */\n  readonly selectionAnchorCell = computed(() => this.data.getCell(this.selectionAnchor()));\n\n  /** Whether a range selection has settled. */\n  readonly selectionStabled = signal(true);\n\n  /** Whether all selectable cells are selected. */\n  readonly allSelected: SignalLike<boolean> = computed(() =>\n    this.data\n      .cells()\n      .flat()\n      .filter(c => this.selectionBehavior.isSelectable(c))\n      .every(c => c.selected()),\n  );\n\n  /** The tab index for the grid container. */\n  readonly gridTabIndex: SignalLike<-1 | 0> = () => this.focusBehavior.gridTabIndex();\n\n  /** Whether the grid is in a disabled state. */\n  readonly gridDisabled: SignalLike<boolean> = () => this.focusBehavior.gridDisabled();\n\n  /** The ID of the active descendant for ARIA `activedescendant` focus management. */\n  readonly activeDescendant: SignalLike<string | undefined> = () =>\n    this.focusBehavior.activeDescendant();\n\n  constructor(readonly inputs: GridInputs<T>) {\n    this.data = new GridData(inputs);\n    this.focusBehavior = new GridFocus({...inputs, grid: this.data});\n    this.navigationBehavior = new GridNavigation({\n      ...inputs,\n      grid: this.data,\n      gridFocus: this.focusBehavior,\n    });\n    this.selectionBehavior = new GridSelection({\n      ...inputs,\n      grid: this.data,\n      gridFocus: this.focusBehavior,\n    });\n  }\n\n  /** Gets the 1-based row index of a cell. */\n  rowIndex(cell: T): number | undefined {\n    const index = this.data.getCoords(cell)?.row;\n    return index !== undefined ? index + 1 : undefined;\n  }\n\n  /** Gets the 1-based column index of a cell. */\n  colIndex(cell: T): number | undefined {\n    const index = this.data.getCoords(cell)?.col;\n    return index !== undefined ? index + 1 : undefined;\n  }\n\n  /** Gets the tab index for a given cell. */\n  cellTabIndex(cell: T): -1 | 0 {\n    return this.focusBehavior.getCellTabIndex(cell);\n  }\n\n  /** Navigates to the cell above the currently active cell. */\n  up(opts: NavOptions = {}): boolean {\n    return this._navigateWithSelection(\n      () =>\n        opts.anchor\n          ? this._updateSelectionAnchor(() =>\n              this.navigationBehavior.peek(direction.Up, this.selectionAnchor(), 'nowrap', true),\n            )\n          : this.navigationBehavior.advance(direction.Up),\n      opts,\n    );\n  }\n\n  /** Navigates to the cell below the currently active cell. */\n  down(opts: NavOptions = {}): boolean {\n    return this._navigateWithSelection(\n      () =>\n        opts.anchor\n          ? this._updateSelectionAnchor(() =>\n              this.navigationBehavior.peek(direction.Down, this.selectionAnchor(), 'nowrap', true),\n            )\n          : this.navigationBehavior.advance(direction.Down),\n      opts,\n    );\n  }\n\n  /** Navigates to the cell to the left of the currently active cell. */\n  left(opts: NavOptions = {}): boolean {\n    return this._navigateWithSelection(\n      () =>\n        opts.anchor\n          ? this._updateSelectionAnchor(() =>\n              this.navigationBehavior.peek(direction.Left, this.selectionAnchor(), 'nowrap', true),\n            )\n          : this.navigationBehavior.advance(direction.Left),\n      opts,\n    );\n  }\n\n  /** Navigates to the cell to the right of the currently active cell. */\n  right(opts: NavOptions = {}): boolean {\n    return this._navigateWithSelection(\n      () =>\n        opts.anchor\n          ? this._updateSelectionAnchor(() =>\n              this.navigationBehavior.peek(direction.Right, this.selectionAnchor(), 'nowrap', true),\n            )\n          : this.navigationBehavior.advance(direction.Right),\n      opts,\n    );\n  }\n\n  /** Navigates to the first focusable cell in the grid. */\n  first(opts: NavOptions = {}): boolean {\n    return this._navigateWithSelection(\n      () =>\n        opts.anchor\n          ? this._updateSelectionAnchor(() => this.navigationBehavior.peekFirst(undefined, true))\n          : this.navigationBehavior.first(),\n      opts,\n    );\n  }\n\n  /** Navigates to the first focusable cell in the current row. */\n  firstInRow(opts: NavOptions = {}): boolean {\n    const row = this.focusBehavior.activeCoords().row;\n    return this._navigateWithSelection(\n      () =>\n        opts.anchor\n          ? this._updateSelectionAnchor(() => this.navigationBehavior.peekFirst(row, true))\n          : this.navigationBehavior.first(row),\n      opts,\n    );\n  }\n\n  /** Navigates to the last focusable cell in the grid. */\n  last(opts: NavOptions = {}): boolean {\n    return this._navigateWithSelection(\n      () =>\n        opts.anchor\n          ? this._updateSelectionAnchor(() => this.navigationBehavior.peekLast(undefined, true))\n          : this.navigationBehavior.last(),\n      opts,\n    );\n  }\n\n  /** Navigates to the last focusable cell in the current row. */\n  lastInRow(opts: NavOptions = {}): boolean {\n    const row = this.focusBehavior.activeCoords().row;\n    return this._navigateWithSelection(\n      () =>\n        opts.anchor\n          ? this._updateSelectionAnchor(() => this.navigationBehavior.peekLast(row, true))\n          : this.navigationBehavior.last(row),\n      opts,\n    );\n  }\n\n  /** Selects all cells in the current row. */\n  selectRow(): void {\n    const row = this.focusBehavior.activeCoords().row;\n    this.selectionBehavior.deselectAll();\n    this.selectionBehavior.select({row, col: 0}, {row, col: this.data.maxColCount()});\n  }\n\n  /** Selects all cells in the current column. */\n  selectCol(): void {\n    const col = this.focusBehavior.activeCoords().col;\n    this.selectionBehavior.deselectAll();\n    this.selectionBehavior.select({row: 0, col}, {row: this.data.maxRowCount(), col});\n  }\n\n  /** Selects the active cell. */\n  select(): void {\n    this.selectionBehavior.select(this.focusBehavior.activeCoords());\n  }\n\n  /** Deselects the active cell. */\n  deselect(): void {\n    this.selectionBehavior.deselect(this.focusBehavior.activeCoords());\n  }\n\n  /**\n   * Toggles the selection state of the coordinates of the given cell\n   * or the current active coordinates.\n   */\n  toggle(): void {\n    this.selectionBehavior.toggle(this.focusBehavior.activeCoords());\n  }\n\n  /** Toggles the selection state of the active cell, and deselects all other cells. */\n  toggleOne(): void {\n    const selected = !!this.focusBehavior.activeCell()?.selected();\n    if (selected) {\n      this.deselect();\n      return;\n    }\n\n    this.deselectAll();\n    this.select();\n  }\n\n  /** Selects all selectable cells in the grid. */\n  selectAll(): void {\n    this.selectionBehavior.selectAll();\n  }\n\n  /** Deselects all cells in the grid. */\n  deselectAll(): void {\n    this.selectionBehavior.deselectAll();\n  }\n\n  /** Navigates to and focuses the given cell. */\n  gotoCell(cell: T, opts: NavOptions = {}): boolean {\n    return this._navigateWithSelection(\n      () =>\n        opts.anchor\n          ? this._updateSelectionAnchor(() => this.data.getCoords(cell))\n          : this.navigationBehavior.gotoCell(cell),\n      opts,\n    );\n  }\n\n  /** Sets the default active state of the grid. */\n  setDefaultState(): boolean {\n    // Try to find a selected cell that's focusable.\n    const focusableSelectedCell: T | undefined = this.data\n      .cells()\n      .flat()\n      .filter(c => this.focusBehavior.isFocusable(c))\n      .find(c => c.selected());\n\n    if (focusableSelectedCell !== undefined) {\n      this.focusBehavior.focusCell(focusableSelectedCell);\n      return true;\n    }\n\n    // Otherwise find the first focusable cell.\n    const firstFocusableCoords = this.navigationBehavior.peekFirst();\n\n    if (firstFocusableCoords !== undefined) {\n      return this.focusBehavior.focusCoordinates(firstFocusableCoords);\n    }\n\n    return false;\n  }\n\n  /** Resets the active state of the grid if it is empty or stale. */\n  resetState(): boolean {\n    if (this.focusBehavior.stateEmpty()) {\n      return this.setDefaultState();\n    }\n\n    if (this.focusBehavior.stateStale()) {\n      // Try focus on the same active cell after if a reordering happened.\n      if (this.focusBehavior.focusCell(this.focusBehavior.activeCell()!)) {\n        return true;\n      }\n\n      // If the active cell is no longer exist, focus on the coordinates instead.\n      if (this.focusBehavior.focusCoordinates(this.focusBehavior.activeCoords())) {\n        return true;\n      }\n\n      // If the cooridnates no longer valid, go back to the first available cell.\n      if (this.focusBehavior.focusCoordinates(this.navigationBehavior.peekFirst()!)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /** Updates the selection anchor to the given coordinates. */\n  private _updateSelectionAnchor(peekFn: () => RowCol | undefined): boolean {\n    const coords = peekFn();\n    const success = coords !== undefined;\n    if (!success) return false;\n    this.selectionAnchor.set(coords);\n    return success;\n  }\n\n  /** Updates the selection to include all cells between the anchor and the active cell. */\n  private _updateRangeSelection(): void {\n    if (!this.selectionStabled()) {\n      this.selectionBehavior.undo();\n    }\n    this.selectionBehavior.select(\n      ...this._getSelectionCoords(this.focusBehavior.activeCoords(), this.selectionAnchor()),\n    );\n  }\n\n  /** Gets the start and end coordinates for a selection range. */\n  private _getSelectionCoords(startCoords: RowCol, endCoords: RowCol): [RowCol, RowCol] {\n    const startCell = this.data.getCell(startCoords)!;\n    const endCell = this.data.getCell(endCoords)!;\n    const allCoords = [...this.data.getAllCoords(startCell)!, ...this.data.getAllCoords(endCell)!];\n    const allRows = allCoords.map(c => c.row);\n    const allCols = allCoords.map(c => c.col);\n    const fromCoords = {\n      row: Math.min(...allRows),\n      col: Math.min(...allCols),\n    };\n    const toCoords = {\n      row: Math.max(...allRows),\n      col: Math.max(...allCols),\n    };\n\n    return [fromCoords, toCoords];\n  }\n\n  /** Executes a navigation operation and applies selection options. */\n  private _navigateWithSelection(op: () => boolean, opts: NavOptions = {}): boolean {\n    const success = op();\n    if (!success) return false;\n\n    if (opts.anchor) {\n      this._updateRangeSelection();\n      this.selectionStabled.set(false);\n      return success;\n    }\n\n    // Selection becomes stable after the active cell/coords moved.\n    this.selectionStabled.set(true);\n\n    if (opts.select) {\n      this.select();\n      return success;\n    }\n\n    if (opts.selectOne) {\n      this.deselectAll();\n      this.select();\n      return success;\n    }\n\n    if (opts.toggle) {\n      this.toggle();\n      return success;\n    }\n\n    if (opts.toggleOne) {\n      const selected = !!this.focusBehavior.activeCell()?.selected();\n      this.deselectAll();\n      if (!selected) {\n        this.select();\n      }\n      return success;\n    }\n\n    return success;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport {KeyboardEventManager, PointerEventManager, Modifier} from '../behaviors/event-manager';\nimport {NavOptions, Grid, GridInputs as GridBehaviorInputs} from '../behaviors/grid';\nimport type {GridRowPattern} from './row';\nimport type {GridCellPattern} from './cell';\n\n/** Represents the required inputs for the grid pattern. */\nexport interface GridInputs extends Omit<GridBehaviorInputs<GridCellPattern>, 'cells'> {\n  /** The html element of the grid. */\n  element: SignalLike<HTMLElement>;\n\n  /** The rows that make up the grid. */\n  rows: SignalLike<GridRowPattern[]>;\n\n  /** The direction that text is read based on the users locale. */\n  textDirection: SignalLike<'rtl' | 'ltr'>;\n\n  /** Whether selection is enabled for the grid. */\n  enableSelection: SignalLike<boolean>;\n\n  /** Whether multiple cell in the grid can be selected. */\n  multi: SignalLike<boolean>;\n\n  /** The selection strategy used by the grid. */\n  selectionMode: SignalLike<'follow' | 'explicit'>;\n\n  /** Whether enable range selection. */\n  enableRangeSelection: SignalLike<boolean>;\n\n  /** A function that returns the grid cell associated with a given element. */\n  getCell: (e: Element) => GridCellPattern | undefined;\n}\n\n/** The UI pattern for a grid, handling keyboard navigation, focus, and selection. */\nexport class GridPattern {\n  /** The underlying grid behavior that this pattern is built on. */\n  readonly gridBehavior: Grid<GridCellPattern>;\n\n  /** The cells in the grid. */\n  readonly cells = computed(() => this.gridBehavior.data.cells());\n\n  /** The tab index for the grid. */\n  readonly tabIndex = computed(() => this.gridBehavior.gridTabIndex());\n\n  /** Whether the grid is disabled. */\n  readonly disabled = computed(() => this.gridBehavior.gridDisabled());\n\n  /** The ID of the currently active descendant cell. */\n  readonly activeDescendant = computed(() => this.gridBehavior.activeDescendant());\n\n  /** The currently active cell. */\n  readonly activeCell = computed(() => this.gridBehavior.focusBehavior.activeCell());\n\n  /** The current selection anchor cell. */\n  readonly anchorCell: SignalLike<GridCellPattern | undefined> = computed(() =>\n    this.inputs.enableSelection() && this.inputs.multi()\n      ? this.gridBehavior.selectionAnchorCell()\n      : undefined,\n  );\n\n  /** Whether to pause grid navigation. */\n  readonly pauseNavigation = computed(() =>\n    this.gridBehavior.data\n      .cells()\n      .flat()\n      .reduce((res, c) => res || c.widgetActivated(), false),\n  );\n\n  /** Whether the focus is in the grid. */\n  readonly isFocused = signal(false);\n\n  /** Whether the grid has been focused once. */\n  readonly hasBeenFocused = signal(false);\n\n  /** Whether the user is currently dragging to select a range of cells. */\n  readonly dragging = signal(false);\n\n  /** The key for navigating to the previous column. */\n  readonly prevColKey = computed(() =>\n    this.inputs.textDirection() === 'rtl' ? 'ArrowRight' : 'ArrowLeft',\n  );\n\n  /** The key for navigating to the next column. */\n  readonly nextColKey = computed(() =>\n    this.inputs.textDirection() === 'rtl' ? 'ArrowLeft' : 'ArrowRight',\n  );\n\n  /** The keydown event manager for the grid. */\n  readonly keydown = computed(() => {\n    const manager = new KeyboardEventManager();\n\n    if (this.pauseNavigation()) {\n      return manager;\n    }\n\n    // Navigation handlers.\n    const opts: NavOptions = {\n      selectOne: this.inputs.enableSelection() && this.inputs.selectionMode() === 'follow',\n    };\n    manager\n      .on('ArrowUp', () => this.gridBehavior.up(opts))\n      .on('ArrowDown', () => this.gridBehavior.down(opts))\n      .on(this.prevColKey(), () => this.gridBehavior.left(opts))\n      .on(this.nextColKey(), () => this.gridBehavior.right(opts))\n      .on('Home', () => this.gridBehavior.firstInRow(opts))\n      .on('End', () => this.gridBehavior.lastInRow(opts))\n      .on([Modifier.Ctrl], 'Home', () => this.gridBehavior.first(opts))\n      .on([Modifier.Ctrl], 'End', () => this.gridBehavior.last(opts));\n\n    // Basic explicit selection handlers.\n    if (this.inputs.enableSelection() && this.inputs.selectionMode() === 'explicit') {\n      manager\n        .on('Enter', () =>\n          this.inputs.multi() ? this.gridBehavior.toggle() : this.gridBehavior.toggleOne(),\n        )\n        .on(' ', () =>\n          this.inputs.multi() ? this.gridBehavior.toggle() : this.gridBehavior.toggleOne(),\n        );\n    }\n\n    // Range selection handlers.\n    if (this.inputs.enableSelection() && this.inputs.enableRangeSelection()) {\n      manager\n        .on(Modifier.Shift, 'ArrowUp', () => this.gridBehavior.up({anchor: true}))\n        .on(Modifier.Shift, 'ArrowDown', () => this.gridBehavior.down({anchor: true}))\n        .on(Modifier.Shift, this.prevColKey(), () => this.gridBehavior.left({anchor: true}))\n        .on(Modifier.Shift, this.nextColKey(), () => this.gridBehavior.right({anchor: true}))\n        .on(Modifier.Shift, 'Home', () => this.gridBehavior.firstInRow({anchor: true}))\n        .on(Modifier.Shift, 'End', () => this.gridBehavior.lastInRow({anchor: true}))\n        .on([Modifier.Ctrl | Modifier.Shift], 'Home', () => this.gridBehavior.first({anchor: true}))\n        .on([Modifier.Ctrl | Modifier.Shift], 'End', () => this.gridBehavior.last({anchor: true}))\n        .on([Modifier.Ctrl, Modifier.Meta], 'A', () => {\n          if (this.gridBehavior.allSelected()) {\n            this.gridBehavior.deselectAll();\n          } else {\n            this.gridBehavior.selectAll();\n          }\n        })\n        .on([Modifier.Shift], ' ', () => this.gridBehavior.selectRow())\n        .on([Modifier.Ctrl, Modifier.Meta], ' ', () => this.gridBehavior.selectCol());\n    }\n\n    return manager;\n  });\n\n  /** The pointerdown event manager for the grid. */\n  readonly pointerdown = computed(() => {\n    const manager = new PointerEventManager();\n\n    // Navigation without selection.\n    if (!this.inputs.enableSelection()) {\n      manager.on(e => {\n        const cell = this.inputs.getCell(e.target as Element);\n        if (!cell || !this.gridBehavior.focusBehavior.isFocusable(cell)) return;\n\n        this.gridBehavior.gotoCell(cell);\n      });\n    }\n\n    // Navigation with selection.\n    if (this.inputs.enableSelection()) {\n      manager.on(e => {\n        const cell = this.inputs.getCell(e.target as Element);\n        if (!cell || !this.gridBehavior.focusBehavior.isFocusable(cell)) return;\n\n        this.gridBehavior.gotoCell(cell, {\n          selectOne: this.inputs.selectionMode() === 'follow',\n          toggleOne: this.inputs.selectionMode() === 'explicit' && !this.inputs.multi(),\n          toggle: this.inputs.selectionMode() === 'explicit' && this.inputs.multi(),\n        });\n\n        if (this.inputs.multi() && this.inputs.enableRangeSelection()) {\n          this.dragging.set(true);\n        }\n      });\n\n      // Selection with modifier keys.\n      if (this.inputs.multi()) {\n        manager.on([Modifier.Ctrl, Modifier.Meta], e => {\n          const cell = this.inputs.getCell(e.target as Element);\n          if (!cell || !this.gridBehavior.focusBehavior.isFocusable(cell)) return;\n\n          this.gridBehavior.gotoCell(cell, {toggle: true});\n\n          if (this.inputs.enableRangeSelection()) {\n            this.dragging.set(true);\n          }\n        });\n\n        if (this.inputs.enableRangeSelection()) {\n          manager.on(Modifier.Shift, e => {\n            const cell = this.inputs.getCell(e.target as Element);\n            if (!cell) return;\n\n            this.gridBehavior.gotoCell(cell, {anchor: true});\n            this.dragging.set(true);\n          });\n        }\n      }\n    }\n\n    return manager;\n  });\n\n  /** The pointerup event manager for the grid. */\n  readonly pointerup = computed(() => {\n    const manager = new PointerEventManager();\n\n    if (this.inputs.enableSelection() && this.inputs.enableRangeSelection()) {\n      manager.on([Modifier.Shift, Modifier.Ctrl, Modifier.Meta, Modifier.None], () => {\n        this.dragging.set(false);\n      });\n    }\n\n    return manager;\n  });\n\n  /** Indicates maybe the losing focus is caused by row/cell deletion. */\n  private readonly _maybeDeletion = signal(false);\n\n  /** Indicates the losing focus is certainly caused by row/cell deletion. */\n  private readonly _deletion = signal(false);\n\n  constructor(readonly inputs: GridInputs) {\n    this.gridBehavior = new Grid({\n      ...inputs,\n      cells: computed(() => this.inputs.rows().map(row => row.inputs.cells())),\n    });\n  }\n\n  /** Handles keydown events on the grid. */\n  onKeydown(event: KeyboardEvent) {\n    if (!this.disabled()) {\n      this.keydown().handle(event);\n    }\n  }\n\n  /** Handles pointerdown events on the grid. */\n  onPointerdown(event: PointerEvent) {\n    if (!this.disabled()) {\n      this.pointerdown().handle(event);\n    }\n  }\n\n  /** Handles pointermove events on the grid. */\n  onPointermove(event: PointerEvent) {\n    if (this.disabled()) return;\n    if (!this.inputs.enableSelection()) return;\n    if (!this.inputs.enableRangeSelection()) return;\n    if (!this.dragging()) return;\n\n    const cell = this.inputs.getCell(event.target as Element);\n    if (!cell) return;\n\n    this.gridBehavior.gotoCell(cell, {anchor: true});\n  }\n\n  /** Handles pointerup events on the grid. */\n  onPointerup(event: PointerEvent) {\n    if (!this.disabled()) {\n      this.pointerup().handle(event);\n    }\n  }\n\n  /** Handles focusin events on the grid. */\n  onFocusIn() {\n    this.isFocused.set(true);\n    this.hasBeenFocused.set(true);\n  }\n\n  /** Handles focusout events on the grid. */\n  onFocusOut(event: FocusEvent) {\n    const parentEl = this.inputs.element();\n    const targetEl = event.relatedTarget as Node | null;\n\n    // If a `relatedTarget` is null, then it can be caused by either\n    // - Clicking on a non-focusable element, or\n    // - The focused element is removed from the page.\n    if (targetEl === null) {\n      this._maybeDeletion.set(true);\n    }\n\n    if (parentEl.contains(targetEl)) return;\n    this.isFocused.set(false);\n  }\n\n  /** Sets the default active state of the grid before receiving focus the first time. */\n  setDefaultStateEffect(): void {\n    if (this.hasBeenFocused()) return;\n\n    this.gridBehavior.setDefaultState();\n  }\n\n  /** Resets the active state of the grid if it is empty or stale. */\n  resetStateEffect(): void {\n    const hasReset = this.gridBehavior.resetState();\n\n    // If the active state has been reset right after a focusout event, then\n    // we know it's caused by a row/cell deletion.\n    if (hasReset && this._maybeDeletion()) {\n      this._deletion.set(true);\n    }\n    // Reset maybe deletion state.\n    this._maybeDeletion.set(false);\n  }\n\n  /** Focuses on the active cell element. */\n  focusEffect(): void {\n    const activeCell = this.activeCell();\n    const hasFocus = this.isFocused();\n    const deletion = this._deletion();\n    const isRoving = this.inputs.focusMode() === 'roving';\n    if (activeCell !== undefined && isRoving && (hasFocus || deletion)) {\n      activeCell.element().focus();\n\n      if (deletion) {\n        this._deletion.set(false);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../behaviors/signal-like/signal-like';\nimport {GridCell} from '../behaviors/grid';\nimport type {GridPattern} from './grid';\nimport type {GridRowPattern} from './row';\nimport type {GridCellWidgetPattern} from './widget';\n\n/** The inputs for the `GridCellPattern`. */\nexport interface GridCellInputs extends GridCell {\n  /** The `GridPattern` that this cell belongs to. */\n  grid: SignalLike<GridPattern>;\n\n  /** The `GridRowPattern` that this cell belongs to. */\n  row: SignalLike<GridRowPattern>;\n\n  /** The widget pattern contained within this cell, if any. */\n  widget: SignalLike<GridCellWidgetPattern | undefined>;\n\n  /** The index of this cell's row within the grid. */\n  rowIndex: SignalLike<number | undefined>;\n\n  /** The index of this cell's column within the grid. */\n  colIndex: SignalLike<number | undefined>;\n}\n\n/** The UI pattern for a grid cell. */\nexport class GridCellPattern implements GridCell {\n  /** A unique identifier for the cell. */\n  readonly id: SignalLike<string>;\n\n  /** Whether a cell is disabled. */\n  readonly disabled: SignalLike<boolean>;\n\n  /** Whether the cell is selected. */\n  readonly selected: WritableSignalLike<boolean>;\n\n  /** Whether the cell is selectable. */\n  readonly selectable: SignalLike<boolean>;\n\n  /** The number of rows the cell should span. */\n  readonly rowSpan: SignalLike<number>;\n\n  /** The number of columns the cell should span. */\n  readonly colSpan: SignalLike<number>;\n\n  /** The `aria-selected` attribute for the cell. */\n  readonly ariaSelected = computed<boolean | undefined>(() =>\n    this.inputs.grid().inputs.enableSelection() && this.selectable() ? this.selected() : undefined,\n  );\n\n  /** The `aria-rowindex` attribute for the cell. */\n  readonly ariaRowIndex = computed(\n    () =>\n      this.inputs.row().rowIndex() ??\n      this.inputs.rowIndex() ??\n      this.inputs.grid().gridBehavior.rowIndex(this),\n  );\n\n  /** The `aria-colindex` attribute for the cell. */\n  readonly ariaColIndex = computed(\n    () => this.inputs.colIndex() ?? this.inputs.grid().gridBehavior.colIndex(this),\n  );\n\n  /** The html element that should receive focus. */\n  readonly element: SignalLike<HTMLElement> = computed(\n    () => this.inputs.widget()?.element() ?? this.inputs.element(),\n  );\n\n  /** Whether the cell is active. */\n  readonly active = computed(() => this.inputs.grid().activeCell() === this);\n\n  /** Whether the cell is a selection anchor. */\n  readonly anchor: SignalLike<true | undefined> = computed(() =>\n    this.inputs.grid().anchorCell() === this ? true : undefined,\n  );\n\n  /** The internal tab index calculation for the cell. */\n  private readonly _tabIndex: SignalLike<-1 | 0> = computed(() =>\n    this.inputs.grid().gridBehavior.cellTabIndex(this),\n  );\n\n  /** The tab index for the cell. If the cell contains a widget, the cell's tab index is -1. */\n  readonly tabIndex: SignalLike<-1 | 0> = computed(() =>\n    this.inputs.widget() !== undefined ? -1 : this._tabIndex(),\n  );\n\n  /** Whether the widget within the cell is activated. */\n  readonly widgetActivated: SignalLike<boolean> = computed(\n    () => this.inputs.widget()?.inputs.activate() ?? false,\n  );\n\n  constructor(readonly inputs: GridCellInputs) {\n    this.id = inputs.id;\n    this.disabled = inputs.disabled;\n    this.rowSpan = inputs.rowSpan;\n    this.colSpan = inputs.colSpan;\n    this.selected = inputs.selected;\n    this.selectable = inputs.selectable;\n  }\n\n  /** Gets the tab index for the widget within the cell. */\n  widgetTabIndex(): -1 | 0 {\n    return this._tabIndex();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../behaviors/signal-like/signal-like';\nimport type {GridCellPattern} from './cell';\n\n/** The inputs for the `GridCellWidgetPattern`. */\nexport interface GridCellWidgetInputs {\n  /** The `GridCellPattern` that this widget belongs to. */\n  cell: SignalLike<GridCellPattern>;\n\n  /** The html element that should receive focus. */\n  element: SignalLike<HTMLElement>;\n\n  /**\n   * Whether the widget is activated, which pauses grid navigation to allow interaction\n   * with the widget.\n   */\n  activate: WritableSignalLike<boolean>;\n}\n\n/** The UI pattern for a widget inside a grid cell. */\nexport class GridCellWidgetPattern {\n  /** The html element that should receive focus. */\n  readonly element: SignalLike<HTMLElement>;\n\n  /** The `tab index` for the widget. */\n  readonly tabIndex: SignalLike<-1 | 0> = computed(() => this.inputs.cell().widgetTabIndex());\n\n  /** Whether the widget is in an active state (i.e. its containing cell is active). */\n  readonly active: SignalLike<boolean> = computed(() => this.inputs.cell().active());\n\n  constructor(readonly inputs: GridCellWidgetInputs) {\n    this.element = inputs.element;\n  }\n}\n"],"names":["Modifier","EventManager","options","preventDefault","modifiers","key","handler","_normalizeInputs","args","configs","push","matcher","event","_isMatch","MouseButton","PointerEventManager","stopPropagation","on","button","computed","Math","max","_rowCountByCol","values","_colCountsByRow","_coordsMap","coordsMap","Map","rowIndex","cells","length","row","visitedCoords","has","colIndex","rowspan","cell","rowSpan","rowOffset","col","colOffset","add","spanCoords","set","coords","cellMap","colCount","colCountByRow","get","newColCount","signal","activeCell","undefined","stateStale","activeCoordsCell","inputs","grid","getCell","activeCoords","activeCellNotValid","activeCellCoords","activeCellMismatch","gridDisabled","focusMode","currentActiveCell","disabled","gridCells","every","constructor","getCellTabIndex","Right","GridNavigation","gridFocus","focusCell","wrap","direction","rowWrap","colWrap","_peekDirectional","fromCoords","allowDisabled","advance","nextCoords","gotoCoords","peekFirst","peekLast","maxRowCount","Left","undo","selected","oldState","_undoList","select","toCoords","_updateState","deselect","selectAll","maxColCount","deselectAll","isSelectable","Grid","focusBehavior","selectionBehavior","allSelected","data","filter","c","activeDescendant","GridData","navigationBehavior","GridSelection","getCoords","index","_updateSelectionAnchor","peek","Up","selectionAnchor","opts","down","_navigateWithSelection","anchor","Down","first","last","lastInRow","selectRow","selectCol","toggle","gotoCell","gridBehavior","gridTabIndex","anchorCell","enableSelection","multi","pauseNavigation","reduce","res","textDirection","nextColKey","KeyboardEventManager","manager","selectOne","selectionMode","up","prevColKey","left","right","firstInRow","Ctrl","toggleOne","enableRangeSelection","Shift","Meta","e","isFocusable","target","dragging","None","rows","map","onKeydown","keydown","handle","colSpan","selectable","ariaRowIndex","widgetTabIndex"],"mappings":"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"}