{"version":3,"file":"_widget-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/event-manager/event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/event-manager/keyboard-event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/event-manager/pointer-event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-data.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-focus.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-navigation.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-selection.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/grid.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/cell.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/widget.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * An event that supports modifier keys.\n *\n * Matches the native KeyboardEvent, MouseEvent, and TouchEvent.\n */\nexport interface EventWithModifiers extends Event {\n  ctrlKey: boolean;\n  shiftKey: boolean;\n  altKey: boolean;\n  metaKey: boolean;\n}\n\n/**\n * Options that are applicable to all event handlers.\n *\n * This library has not yet had a need for stopPropagationImmediate.\n */\nexport interface EventHandlerOptions {\n  stopPropagation: boolean;\n  preventDefault: boolean;\n}\n\n/** A basic event handler. */\nexport type EventHandler<T extends Event> = (event: T) => void;\n\n/** A function that determines whether an event is to be handled. */\nexport type EventMatcher<T extends Event> = (event: T) => boolean;\n\n/** A config that specifies how to handle a particular event. */\nexport interface EventHandlerConfig<T extends Event> extends EventHandlerOptions {\n  matcher: EventMatcher<T>;\n  handler: EventHandler<T>;\n}\n\n/** Bit flag representation of the possible modifier keys that can be present on an event. */\nexport enum Modifier {\n  None = 0,\n  Ctrl = 0b1,\n  Shift = 0b10,\n  Alt = 0b100,\n  Meta = 0b1000,\n  Any = 'Any',\n}\n\nexport type ModifierInputs = Modifier | Modifier[];\n\n/**\n * Abstract base class for all event managers.\n *\n * Event managers are designed to normalize how event handlers are authored and create a safety net\n * for common event handling gotchas like remembering to call preventDefault or stopPropagation.\n */\nexport abstract class EventManager<T extends Event> {\n  protected configs: EventHandlerConfig<T>[] = [];\n  abstract options: EventHandlerOptions;\n\n  /** Runs the handlers that match with the given event. */\n  handle(event: T): void {\n    for (const config of this.configs) {\n      if (config.matcher(event)) {\n        config.handler(event);\n\n        if (config.preventDefault) {\n          event.preventDefault();\n        }\n\n        if (config.stopPropagation) {\n          event.stopPropagation();\n        }\n      }\n    }\n  }\n\n  /** Configures the event manager to handle specific events. (See subclasses for more). */\n  abstract on(...args: [...unknown[]]): this;\n}\n\n/** Gets bit flag representation of the modifier keys present on the given event. */\nexport function getModifiers(event: EventWithModifiers): number {\n  return (\n    (+event.ctrlKey && Modifier.Ctrl) |\n    (+event.shiftKey && Modifier.Shift) |\n    (+event.altKey && Modifier.Alt) |\n    (+event.metaKey && Modifier.Meta)\n  );\n}\n\n/**\n * Checks if the given event has modifiers that are an exact match for any of the given modifier\n * flag combinations.\n */\nexport function hasModifiers(event: EventWithModifiers, modifiers: ModifierInputs): boolean {\n  const eventModifiers = getModifiers(event);\n  const modifiersList = Array.isArray(modifiers) ? modifiers : [modifiers];\n\n  if (modifiersList.includes(Modifier.Any)) {\n    return true;\n  }\n\n  return modifiersList.some(modifiers => eventModifiers === modifiers);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SignalLike} from '../signal-like/signal-like';\nimport {\n  EventHandler,\n  EventHandlerOptions,\n  EventManager,\n  hasModifiers,\n  ModifierInputs,\n  Modifier,\n} from './event-manager';\n\n/**\n * Used to represent a keycode.\n *\n * This is used to match whether an events keycode should be handled. The ability to match using a\n * string, SignalLike, or Regexp gives us more flexibility when authoring event handlers.\n */\ntype KeyCode = string | SignalLike<string> | RegExp;\n\n/**\n * An event manager that is specialized for handling keyboard events. By default this manager stops\n * propagation and prevents default on all events it handles.\n */\nexport class KeyboardEventManager<T extends KeyboardEvent> extends EventManager<T> {\n  options: EventHandlerOptions = {\n    preventDefault: true,\n    stopPropagation: true,\n  };\n\n  /** Configures this event manager to handle events with a specific key and no modifiers. */\n  on(key: KeyCode, handler: EventHandler<T>): this;\n\n  /**  Configures this event manager to handle events with a specific modifer and key combination. */\n  on(modifiers: ModifierInputs, key: KeyCode, handler: EventHandler<T>): this;\n\n  on(...args: any[]) {\n    const {modifiers, key, handler} = this._normalizeInputs(...args);\n\n    this.configs.push({\n      handler: handler,\n      matcher: event => this._isMatch(event, key, modifiers),\n      ...this.options,\n    });\n\n    return this;\n  }\n\n  private _normalizeInputs(...args: any[]) {\n    const key = args.length === 3 ? args[1] : args[0];\n    const handler = args.length === 3 ? args[2] : args[1];\n    const modifiers = args.length === 3 ? args[0] : Modifier.None;\n\n    return {\n      key: key as KeyCode,\n      handler: handler as EventHandler<T>,\n      modifiers: modifiers as ModifierInputs,\n    };\n  }\n\n  private _isMatch(event: T, key: KeyCode, modifiers: ModifierInputs) {\n    if (!hasModifiers(event, modifiers)) {\n      return false;\n    }\n\n    if (key instanceof RegExp) {\n      return key.test(event.key);\n    }\n\n    const keyStr = typeof key === 'string' ? key : key();\n    return keyStr.toLowerCase() === event.key.toLowerCase();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  EventHandler,\n  EventHandlerOptions,\n  EventManager,\n  hasModifiers,\n  ModifierInputs,\n  Modifier,\n} from './event-manager';\n\n/**\n * The different mouse buttons that may appear on a pointer event.\n */\nexport enum MouseButton {\n  Main = 0,\n  Auxiliary = 1,\n  Secondary = 2,\n}\n\n/** An event manager that is specialized for handling pointer events. */\nexport class PointerEventManager<T extends PointerEvent> extends EventManager<T> {\n  options: EventHandlerOptions = {\n    preventDefault: false,\n    stopPropagation: false,\n  };\n\n  /**\n   * Configures this event manager to handle events with a specific modifer and mouse button\n   * combination.\n   */\n  on(button: MouseButton, modifiers: ModifierInputs, handler: EventHandler<T>): this;\n\n  /**\n   * Configures this event manager to handle events with a specific mouse button and no modifiers.\n   */\n  on(modifiers: ModifierInputs, handler: EventHandler<T>): this;\n\n  /**\n   * Configures this event manager to handle events with the main mouse button and no modifiers.\n   *\n   * @param handler The handler function\n   * @param options Options for whether to stop propagation or prevent default.\n   */\n  on(handler: EventHandler<T>): this;\n\n  on(...args: any[]) {\n    const {button, handler, modifiers} = this._normalizeInputs(...args);\n\n    this.configs.push({\n      handler,\n      matcher: event => this._isMatch(event, button, modifiers),\n      ...this.options,\n    });\n    return this;\n  }\n\n  private _normalizeInputs(...args: any[]) {\n    if (args.length === 3) {\n      return {\n        button: args[0] as MouseButton,\n        modifiers: args[1] as ModifierInputs,\n        handler: args[2] as EventHandler<T>,\n      };\n    }\n\n    if (args.length === 2) {\n      return {\n        button: MouseButton.Main,\n        modifiers: args[0] as ModifierInputs,\n        handler: args[1] as EventHandler<T>,\n      };\n    }\n\n    return {\n      button: MouseButton.Main,\n      modifiers: Modifier.None,\n      handler: args[0] as EventHandler<T>,\n    };\n  }\n\n  _isMatch(event: PointerEvent, button: MouseButton, modifiers: ModifierInputs) {\n    return button === (event.button ?? 0) && hasModifiers(event, modifiers);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\n\n/** Represents coordinates in a grid. */\nexport interface RowCol {\n  /** The row index. */\n  row: number;\n\n  /** The column index. */\n  col: number;\n}\n\n/** A string representation of grid coordinates. */\ntype CoordString = `${RowCol['row']}:${RowCol['col']}`;\n\n/** The base interface for a cell in a grid. */\nexport interface BaseGridCell {\n  /** The number of rows the cell should span. */\n  rowSpan: SignalLike<number>;\n\n  /** The number of columns the cell should span. */\n  colSpan: SignalLike<number>;\n}\n\n/** Represents the required inputs for GridData. */\nexport interface GridDataInputs<T extends BaseGridCell> {\n  /** The two-dimensional array of cells that represents the grid. */\n  cells: SignalLike<T[][]>;\n}\n\n/** Controls internal coordinates for a grid of items. */\nexport class GridData<T extends BaseGridCell> {\n  /** The two-dimensional array of cells that represents the grid. */\n  readonly cells: SignalLike<T[][]>;\n\n  /** The number of rows in the grid. */\n  readonly rowCount = computed<number>(() => this.cells().length);\n\n  /** The maximum number of rows in the grid, accounting for row spans. */\n  readonly maxRowCount = computed<number>(() => Math.max(...this._rowCountByCol().values(), 0));\n\n  /** The maximum number of columns in the grid, accounting for column spans. */\n  readonly maxColCount = computed<number>(() => Math.max(...this._colCountsByRow().values(), 0));\n\n  /** A map from a cell to its primary and spanned coordinates. */\n  private readonly _coordsMap = computed<Map<T, {coords: RowCol; spanCoords: RowCol[]}>>(() => {\n    const coordsMap = new Map();\n    const visitedCoords = new Set();\n\n    for (let rowIndex = 0; rowIndex < this.cells().length; rowIndex++) {\n      let colIndex = 0;\n      const row = this.cells()[rowIndex];\n\n      for (const cell of row) {\n        // Skip past cells that are already taken.\n        while (visitedCoords.has(`${rowIndex}:${colIndex}`)) {\n          colIndex++;\n        }\n\n        const rowspan = cell.rowSpan();\n        const colspan = cell.colSpan();\n        const spanCoords: RowCol[] = [];\n\n        for (let rowOffset = 0; rowOffset < rowspan; rowOffset++) {\n          const row = rowIndex + rowOffset;\n          for (let colOffset = 0; colOffset < colspan; colOffset++) {\n            const col = colIndex + colOffset;\n            visitedCoords.add(`${row}:${col}`);\n            spanCoords.push({row, col});\n          }\n        }\n        coordsMap.set(cell, {coords: spanCoords[0], spanCoords});\n\n        colIndex += colspan;\n      }\n    }\n\n    return coordsMap;\n  });\n\n  /** A map from a coordinate string to the cell at that coordinate. */\n  private readonly _cellMap = computed<Map<CoordString, T>>(() => {\n    const cellMap = new Map();\n    for (const [cell, {spanCoords}] of this._coordsMap().entries()) {\n      for (const {row, col} of spanCoords) {\n        cellMap.set(`${row}:${col}`, cell);\n      }\n    }\n    return cellMap;\n  });\n\n  /** A map from a row index to the number of columns in that row. */\n  private readonly _colCountsByRow = computed<Map<number, number>>(() => {\n    const colCountByRow = new Map();\n    for (const [_, {spanCoords}] of this._coordsMap().entries()) {\n      for (const {row, col} of spanCoords) {\n        const colCount = colCountByRow.get(row);\n        const newColCount = col + 1;\n        if (colCount === undefined || colCount < newColCount) {\n          colCountByRow.set(row, newColCount);\n        }\n      }\n    }\n    return colCountByRow;\n  });\n\n  /** A map from a column index to the number of rows in that column. */\n  private readonly _rowCountByCol = computed<Map<number, number>>(() => {\n    const rowCountByCol = new Map();\n    for (const [_, {spanCoords}] of this._coordsMap().entries()) {\n      for (const {row, col} of spanCoords) {\n        const rowCount = rowCountByCol.get(col);\n        const newRowCount = row + 1;\n        if (rowCount === undefined || rowCount < newRowCount) {\n          rowCountByCol.set(col, newRowCount);\n        }\n      }\n    }\n    return rowCountByCol;\n  });\n\n  constructor(readonly inputs: GridDataInputs<T>) {\n    this.cells = this.inputs.cells;\n  }\n\n  /** Gets the cell at the given coordinates. */\n  getCell(rowCol: RowCol): T | undefined {\n    return this._cellMap().get(`${rowCol.row}:${rowCol.col}`);\n  }\n\n  /** Gets the primary coordinates of the given cell. */\n  getCoords(cell: T): RowCol | undefined {\n    return this._coordsMap().get(cell)?.coords;\n  }\n\n  /** Gets all coordinates that the given cell spans. */\n  getAllCoords(cell: T): RowCol[] | undefined {\n    return this._coordsMap().get(cell)?.spanCoords;\n  }\n\n  /** Gets the number of rows in the given column. */\n  getRowCount(col: number): number | undefined {\n    return this._rowCountByCol().get(col);\n  }\n\n  /** Gets the number of columns in the given row. */\n  getColCount(row: number): number | undefined {\n    return this._colCountsByRow().get(row);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\nimport type {GridData, BaseGridCell, RowCol} from './grid-data';\n\n/** Represents an cell in a grid, such as a grid cell, that may receive focus. */\nexport interface GridFocusCell extends BaseGridCell {\n  /** A unique identifier for the cell. */\n  id: SignalLike<string>;\n\n  /** The html element that should receive focus. */\n  element: SignalLike<HTMLElement>;\n\n  /** Whether a cell is disabled. */\n  disabled: SignalLike<boolean>;\n}\n\n/** Represents the required inputs for a grid that contains focusable cells. */\nexport interface GridFocusInputs {\n  /** The focus strategy used by the grid. */\n  focusMode: SignalLike<'roving' | 'activedescendant'>;\n\n  /** Whether the grid is disabled. */\n  disabled: SignalLike<boolean>;\n\n  /** Whether disabled cells in the grid should be skipped when navigating. */\n  skipDisabled: SignalLike<boolean>;\n}\n\n/** Dependencies for the `GridFocus` class. */\ninterface GridFocusDeps<T extends GridFocusCell> {\n  /** The `GridData` instance that this focus manager operates on. */\n  grid: GridData<T>;\n}\n\n/** Controls focus for a 2D grid of cells. */\nexport class GridFocus<T extends GridFocusCell> {\n  /** The current active cell. */\n  readonly activeCell = signal<T | undefined>(undefined);\n\n  /** The current active cell coordinates. */\n  readonly activeCoords = signal<RowCol>({row: -1, col: -1});\n\n  /** Whether the grid active state is empty (no active cell or coordinates). */\n  readonly stateEmpty = computed(\n    () =>\n      this.activeCell() === undefined ||\n      (this.activeCoords().row === -1 && this.activeCoords().col === -1),\n  );\n\n  /**\n   * Whether the grid focus state is stale.\n   *\n   * A stale state means the active cell or coordinates are no longer valid based on the\n   * current grid data, for example if the underlying cells have changed.\n   * A stale state should be re-initialized.\n   */\n  readonly stateStale = computed(() => {\n    if (this.stateEmpty()) {\n      return true;\n    }\n\n    const activeCell = this.activeCell();\n    const activeCellCoords = this.inputs.grid.getCoords(activeCell!);\n    const activeCoords = this.activeCoords();\n    const activeCoordsCell = this.inputs.grid.getCell(activeCoords);\n\n    const activeCellNotValid = activeCellCoords === undefined;\n    const activeCellMismatch = activeCell !== activeCoordsCell;\n    return activeCellNotValid || activeCellMismatch;\n  });\n\n  /** The id of the current active cell, for ARIA activedescendant. */\n  readonly activeDescendant = computed<string | undefined>(() => {\n    if (this.gridDisabled() || this.inputs.focusMode() === 'roving') {\n      return undefined;\n    }\n    const currentActiveCell = this.activeCell();\n    return currentActiveCell ? currentActiveCell.id() : undefined;\n  });\n\n  /** Whether the grid is in a disabled state. */\n  readonly gridDisabled = computed<boolean>(() => {\n    if (this.inputs.disabled()) {\n      return true;\n    }\n    const gridCells = this.inputs.grid.cells();\n    return gridCells.length === 0 || gridCells.every(row => row.every(cell => cell.disabled()));\n  });\n\n  /** The tabindex for the grid container. */\n  readonly gridTabIndex = computed<-1 | 0>(() => {\n    if (this.gridDisabled()) {\n      return 0;\n    }\n    return this.inputs.focusMode() === 'activedescendant' ? 0 : -1;\n  });\n\n  constructor(readonly inputs: GridFocusInputs & GridFocusDeps<T>) {}\n\n  /** Returns the tabindex for the given grid cell cell. */\n  getCellTabindex(cell: T): -1 | 0 {\n    if (this.gridDisabled()) {\n      return -1;\n    }\n    if (this.inputs.focusMode() === 'activedescendant') {\n      return -1;\n    }\n    return this.activeCell() === cell ? 0 : -1;\n  }\n\n  /** Returns true if the given cell can be navigated to. */\n  isFocusable(cell: T): boolean {\n    return !cell.disabled() || !this.inputs.skipDisabled();\n  }\n\n  /** Focuses the given cell. */\n  focusCell(cell: T): boolean {\n    if (this.gridDisabled()) {\n      return false;\n    }\n\n    if (!this.isFocusable(cell)) {\n      return false;\n    }\n\n    if (this.inputs.grid.getCoords(cell) === undefined) {\n      return false;\n    }\n\n    this.activeCoords.set(this.inputs.grid.getCoords(cell)!);\n    this.activeCell.set(cell);\n\n    return true;\n  }\n\n  /** Moves focus to the cell at the given coordinates if it's part of a focusable cell. */\n  focusCoordinates(coords: RowCol): boolean {\n    if (this.gridDisabled()) {\n      return false;\n    }\n\n    const cell = this.inputs.grid.getCell(coords);\n\n    if (!cell || !this.isFocusable(cell)) {\n      return false;\n    }\n\n    if (this.inputs.grid.getCell(coords) === undefined) {\n      return false;\n    }\n\n    this.activeCoords.set(coords);\n    this.activeCell.set(this.inputs.grid.getCell(coords));\n\n    return true;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\nimport {GridFocus, GridFocusCell, GridFocusInputs} from './grid-focus';\nimport {GridData, RowCol} from './grid-data';\n\n/** A utility type that ensures an object has exactly one key from a given set. */\ntype ExactlyOneKey<T, K extends keyof T = keyof T> = {\n  [P in K]: Record<P, T[P]> & Partial<Record<Exclude<K, P>, never>>;\n}[K];\n\n/** Represents a directional change in the grid, either by row or by column. */\ntype Delta = ExactlyOneKey<{row: -1 | 1; col: -1 | 1}>;\n\n/** Constants for the four cardinal directions. */\nexport const direction: Record<'Up' | 'Down' | 'Left' | 'Right', Delta> = {\n  Up: {row: -1},\n  Down: {row: 1},\n  Left: {col: -1},\n  Right: {col: 1},\n} as const;\n\n/** The wrapping behavior for keyboard navigation. */\nexport type WrapStrategy = 'continuous' | 'loop' | 'nowrap';\n\n/** Represents an item in a collection, such as a listbox option, than can be navigated to. */\nexport interface GridNavigationCell extends GridFocusCell {}\n\n/** Represents the required inputs for a collection that has navigable items. */\nexport interface GridNavigationInputs extends GridFocusInputs {\n  /** The wrapping behavior for keyboard navigation along the row axis. */\n  rowWrap: SignalLike<WrapStrategy>;\n\n  /** The wrapping behavior for keyboard navigation along the column axis. */\n  colWrap: SignalLike<WrapStrategy>;\n}\n\n/** Dependencies for the `GridNavigation` class. */\ninterface GridNavigationDeps<T extends GridNavigationCell> {\n  /** The `GridData` instance that this navigation manager operates on. */\n  grid: GridData<T>;\n\n  /** The `GridFocus` instance that this navigation manager uses to manage focus. */\n  gridFocus: GridFocus<T>;\n}\n\n/** Controls navigation for a grid of items. */\nexport class GridNavigation<T extends GridNavigationCell> {\n  /** The maximum number of steps to take when searching for the next cell. */\n  private _maxSteps = computed<number>(\n    () => this.inputs.grid.maxRowCount() * this.inputs.grid.maxColCount(),\n  );\n\n  constructor(readonly inputs: GridNavigationInputs & GridNavigationDeps<T>) {}\n\n  /** Navigates to the given item. */\n  gotoCell(cell: T): boolean {\n    return this.inputs.gridFocus.focusCell(cell);\n  }\n\n  /** Navigates to the given coordinates. */\n  gotoCoords(coords: RowCol): boolean {\n    return this.inputs.gridFocus.focusCoordinates(coords);\n  }\n\n  /**\n   * Gets the coordinates of the next focusable cell in a given direction, without changing focus.\n   */\n  peek(direction: Delta, fromCoords: RowCol, wrap?: WrapStrategy): RowCol | undefined {\n    wrap = wrap ?? (direction.row !== undefined ? this.inputs.rowWrap() : this.inputs.colWrap());\n    return this._peekDirectional(direction, fromCoords, wrap);\n  }\n\n  /**\n   * Navigates to the next focusable cell in a given direction.\n   */\n  advance(direction: Delta): boolean {\n    const nextCoords = this.peek(direction, this.inputs.gridFocus.activeCoords());\n    return !!nextCoords && this.gotoCoords(nextCoords);\n  }\n\n  /**\n   * Gets the coordinates of the first focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  peekFirst(row?: number): RowCol | undefined {\n    const fromCoords = {\n      row: row ?? 0,\n      col: -1,\n    };\n    return row === undefined\n      ? this._peekDirectional(direction.Right, fromCoords, 'continuous')\n      : this._peekDirectional(direction.Right, fromCoords, 'nowrap');\n  }\n\n  /**\n   * Navigates to the first focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  first(row?: number): boolean {\n    const nextCoords = this.peekFirst(row);\n    return !!nextCoords && this.gotoCoords(nextCoords);\n  }\n\n  /**\n   * Gets the coordinates of the last focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  peekLast(row?: number): RowCol | undefined {\n    const fromCoords = {\n      row: row ?? this.inputs.grid.maxRowCount() - 1,\n      col: this.inputs.grid.maxColCount(),\n    };\n    return row === undefined\n      ? this._peekDirectional(direction.Left, fromCoords, 'continuous')\n      : this._peekDirectional(direction.Left, fromCoords, 'nowrap');\n  }\n\n  /**\n   * Navigates to the last focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  last(row?: number): boolean {\n    const nextCoords = this.peekLast(row);\n    return !!nextCoords && this.gotoCoords(nextCoords);\n  }\n\n  /**\n   * Finds the next focusable cell in a given direction based on the wrapping behavior.\n   */\n  private _peekDirectional(\n    delta: Delta,\n    fromCoords: RowCol,\n    wrap: 'continuous' | 'loop' | 'nowrap',\n  ): RowCol | undefined {\n    const fromCell = this.inputs.grid.getCell(fromCoords);\n    const maxRowCount = this.inputs.grid.maxRowCount();\n    const maxColCount = this.inputs.grid.maxColCount();\n    const rowDelta = delta.row ?? 0;\n    const colDelta = delta.col ?? 0;\n    let nextCoords = {...fromCoords};\n\n    for (let step = 0; step < this._maxSteps(); step++) {\n      const isWrapping =\n        nextCoords.col + colDelta < 0 ||\n        nextCoords.col + colDelta >= maxColCount ||\n        nextCoords.row + rowDelta < 0 ||\n        nextCoords.row + rowDelta >= maxRowCount;\n\n      if (wrap === 'nowrap' && isWrapping) return;\n\n      if (wrap === 'continuous') {\n        const generalDelta = delta.row ?? delta.col;\n        const rowStep = isWrapping ? generalDelta : rowDelta;\n        const colStep = isWrapping ? generalDelta : colDelta;\n\n        nextCoords = {\n          row: (nextCoords.row + rowStep + maxRowCount) % maxRowCount,\n          col: (nextCoords.col + colStep + maxColCount) % maxColCount,\n        };\n      }\n\n      if (wrap === 'loop') {\n        nextCoords = {\n          row: (nextCoords.row + rowDelta + maxRowCount) % maxRowCount,\n          col: (nextCoords.col + colDelta + maxColCount) % maxColCount,\n        };\n      }\n\n      // Back to original coordinates.\n      if (nextCoords.row === fromCoords.row && nextCoords.col === fromCoords.col) {\n        return undefined;\n      }\n\n      const nextCell = this.inputs.grid.getCell(nextCoords);\n      if (\n        nextCell !== undefined &&\n        nextCell !== fromCell &&\n        this.inputs.gridFocus.isFocusable(nextCell)\n      ) {\n        return nextCoords;\n      }\n    }\n\n    return undefined;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SignalLike, WritableSignalLike} from '../signal-like/signal-like';\nimport {GridFocus, GridFocusCell, GridFocusInputs} from './grid-focus';\nimport {GridData, RowCol} from './grid-data';\n\n/** Represents a cell in a grid that can be selected. */\nexport interface GridSelectionCell extends GridFocusCell {\n  /** Whether the cell is selected. */\n  selected: WritableSignalLike<boolean>;\n\n  /** Whether the cell is selectable. */\n  selectable: SignalLike<boolean>;\n}\n\n/** Represents the required inputs for a grid that has selectable cells. */\nexport interface GridSelectionInputs extends GridFocusInputs {}\n\n/** Dependencies for the `GridSelection` class. */\ninterface GridSelectionDeps<T extends GridSelectionCell> {\n  /** The `GridData` instance that this selection manager operates on. */\n  grid: GridData<T>;\n\n  /** The `GridFocus` instance that this selection manager uses to manage focus. */\n  gridFocus: GridFocus<T>;\n}\n\n/** Controls selection for a grid of items. */\nexport class GridSelection<T extends GridSelectionCell> {\n  constructor(readonly inputs: GridSelectionInputs & GridSelectionDeps<T>) {}\n\n  /** Selects one or more cells in a given range. */\n  select(fromCoords: RowCol, toCoords?: RowCol): void {\n    for (const cell of this._validCells(fromCoords, toCoords ?? fromCoords)) {\n      cell.selected.set(true);\n    }\n  }\n\n  /** Deselects one or more cells in a given range. */\n  deselect(fromCoords: RowCol, toCoords?: RowCol): void {\n    for (const cell of this._validCells(fromCoords, toCoords ?? fromCoords)) {\n      cell.selected.set(false);\n    }\n  }\n\n  /** Toggles the selection state of one or more cells in a given range. */\n  toggle(fromCoords: RowCol, toCoords?: RowCol): void {\n    for (const cell of this._validCells(fromCoords, toCoords ?? fromCoords)) {\n      cell.selected.update(state => !state);\n    }\n  }\n\n  /** Selects all valid cells in the grid. */\n  selectAll(): void {\n    for (const cell of this._validCells(\n      {row: 0, col: 0},\n      {row: this.inputs.grid.maxRowCount(), col: this.inputs.grid.maxColCount()},\n    )) {\n      cell.selected.set(true);\n    }\n  }\n\n  /** Deselects all valid cells in the grid. */\n  deselectAll(): void {\n    for (const cell of this._validCells(\n      {row: 0, col: 0},\n      {row: this.inputs.grid.maxRowCount(), col: this.inputs.grid.maxColCount()},\n    )) {\n      cell.selected.set(false);\n    }\n  }\n\n  /** A generator that yields all valid (selectable and not disabled) cells within a given range. */\n  *_validCells(fromCoords: RowCol, toCoords: RowCol): Generator<T> {\n    const startRow = Math.min(fromCoords.row, toCoords.row);\n    const startCol = Math.min(fromCoords.col, toCoords.col);\n    const endRow = Math.max(fromCoords.row, toCoords.row);\n    const endCol = Math.max(fromCoords.col, toCoords.col);\n    const visited = new Set<T>();\n    for (let row = startRow; row < endRow + 1; row++) {\n      for (let col = startCol; col < endCol + 1; col++) {\n        const cell = this.inputs.grid.getCell({row, col});\n        if (cell === undefined) continue;\n        if (!cell.selectable()) continue;\n        if (cell.disabled()) continue;\n        if (visited.has(cell)) continue;\n        visited.add(cell);\n        yield cell;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, linkedSignal} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\nimport {GridData, BaseGridCell, GridDataInputs, RowCol} from './grid-data';\nimport {GridFocus, GridFocusCell, GridFocusInputs} from './grid-focus';\nimport {\n  direction,\n  GridNavigation,\n  GridNavigationCell,\n  GridNavigationInputs,\n} from './grid-navigation';\nimport {GridSelectionCell, GridSelectionInputs, GridSelection} from './grid-selection';\n\n/** A type that represents a cell in a grid, combining all cell-related interfaces. */\nexport type GridCell = BaseGridCell & GridFocusCell & GridNavigationCell & GridSelectionCell;\n\n/** Represents the required inputs for a grid. */\nexport interface GridInputs<T extends GridCell>\n  extends GridDataInputs<T>,\n    GridFocusInputs,\n    GridNavigationInputs,\n    GridSelectionInputs {\n  /** Whether selection is enabled for the grid. */\n  enableSelection: SignalLike<boolean>;\n}\n\n/** The main class that orchestrates the grid behaviors. */\nexport class Grid<T extends GridCell> {\n  /** The underlying data structure for the grid. */\n  readonly data: GridData<T>;\n\n  /** Controls focus for the grid. */\n  readonly focusBehavior: GridFocus<T>;\n\n  /** Controls navigation for the grid. */\n  readonly navigationBehavior: GridNavigation<T>;\n\n  /** Controls selection for the grid. */\n  readonly selectionBehavior: GridSelection<T>;\n\n  /** The anchor point for range selection, linked to the active coordinates. */\n  readonly selectionAnchor = linkedSignal<RowCol>(() => this.focusBehavior.activeCoords());\n\n  /** The `tabindex` for the grid container. */\n  readonly gridTabIndex = computed(() => this.focusBehavior.gridTabIndex());\n\n  /** Whether the grid is in a disabled state. */\n  readonly gridDisabled = computed(() => this.focusBehavior.gridDisabled());\n\n  /** The ID of the active descendant for ARIA `activedescendant` focus management. */\n  readonly activeDescendant = computed(() => this.focusBehavior.activeDescendant());\n\n  constructor(readonly inputs: GridInputs<T>) {\n    this.data = new GridData(inputs);\n    this.focusBehavior = new GridFocus({...inputs, grid: this.data});\n    this.navigationBehavior = new GridNavigation({\n      ...inputs,\n      grid: this.data,\n      gridFocus: this.focusBehavior,\n    });\n    this.selectionBehavior = new GridSelection({\n      ...inputs,\n      grid: this.data,\n      gridFocus: this.focusBehavior,\n    });\n  }\n\n  /** Gets the 1-based row index of a cell. */\n  rowIndex(cell: T): number | undefined {\n    const index = this.data.getCoords(cell)?.row;\n    return index !== undefined ? index + 1 : undefined;\n  }\n\n  /** Gets the 1-based column index of a cell. */\n  colIndex(cell: T): number | undefined {\n    const index = this.data.getCoords(cell)?.col;\n    return index !== undefined ? index + 1 : undefined;\n  }\n\n  /** Gets the `tabindex` for a given cell. */\n  cellTabIndex(cell: T): -1 | 0 {\n    return this.focusBehavior.getCellTabindex(cell);\n  }\n\n  /** Navigates to the cell above the currently active cell. */\n  up(): boolean {\n    return this.navigationBehavior.advance(direction.Up);\n  }\n\n  /** Extends the selection to the cell above the selection anchor. */\n  rangeSelectUp(): void {\n    const coords = this.navigationBehavior.peek(direction.Up, this.selectionAnchor());\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Navigates to the cell below the currently active cell. */\n  down(): boolean {\n    return this.navigationBehavior.advance(direction.Down);\n  }\n\n  /** Extends the selection to the cell below the selection anchor. */\n  rangeSelectDown(): void {\n    const coords = this.navigationBehavior.peek(direction.Down, this.selectionAnchor());\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Navigates to the cell to the left of the currently active cell. */\n  left(): boolean {\n    return this.navigationBehavior.advance(direction.Left);\n  }\n\n  /** Extends the selection to the cell to the left of the selection anchor. */\n  rangeSelectLeft(): void {\n    const coords = this.navigationBehavior.peek(direction.Left, this.selectionAnchor());\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Navigates to the cell to the right of the currently active cell. */\n  right(): boolean {\n    return this.navigationBehavior.advance(direction.Right);\n  }\n\n  /** Extends the selection to the cell to the right of the selection anchor. */\n  rangeSelectRight(): void {\n    const coords = this.navigationBehavior.peek(direction.Right, this.selectionAnchor());\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Navigates to the first focusable cell in the grid. */\n  first(): boolean {\n    return this.navigationBehavior.first();\n  }\n\n  /** Navigates to the first focusable cell in the current row. */\n  firstInRow(): boolean {\n    return this.navigationBehavior.first(this.focusBehavior.activeCoords().row);\n  }\n\n  /** Navigates to the last focusable cell in the grid. */\n  last(): boolean {\n    return this.navigationBehavior.last();\n  }\n\n  /** Navigates to the last focusable cell in the current row. */\n  lastInRow(): boolean {\n    return this.navigationBehavior.last(this.focusBehavior.activeCoords().row);\n  }\n\n  /** Selects all cells in the current row. */\n  selectRow(): void {\n    const row = this.focusBehavior.activeCoords().row;\n    this.selectionBehavior.deselectAll();\n    this.selectionBehavior.select({row, col: 0}, {row, col: this.data.maxColCount()});\n  }\n\n  /** Selects all cells in the current column. */\n  selectCol(): void {\n    const col = this.focusBehavior.activeCoords().col;\n    this.selectionBehavior.deselectAll();\n    this.selectionBehavior.select({row: 0, col}, {row: this.data.maxRowCount(), col});\n  }\n\n  /** Selects all selectable cells in the grid. */\n  selectAll(): void {\n    this.selectionBehavior.selectAll();\n  }\n\n  /** Navigates to and focuses the given cell. */\n  gotoCell(cell: T): boolean {\n    return this.navigationBehavior.gotoCell(cell);\n  }\n\n  /** Toggles the selection state of the given cell. */\n  toggleSelect(cell: T): void {\n    const coords = this.data.getCoords(cell);\n    if (coords === undefined) return;\n\n    this.selectionBehavior.toggle(coords);\n  }\n\n  /** Extends the selection from the anchor to the given cell. */\n  rangeSelect(cell: T): void {\n    const coords = this.data.getCoords(cell);\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Extends the selection to the given coordinates. */\n  private _rangeSelectCoords(coords: RowCol): void {\n    const activeCell = this.focusBehavior.activeCell();\n    const anchorCell = this.data.getCell(coords);\n    if (activeCell === undefined || anchorCell === undefined) {\n      return;\n    }\n\n    const allCoords = [\n      ...this.data.getAllCoords(activeCell)!,\n      ...this.data.getAllCoords(anchorCell)!,\n    ];\n    const allRows = allCoords.map(c => c.row);\n    const allCols = allCoords.map(c => c.col);\n    const fromCoords = {\n      row: Math.min(...allRows),\n      col: Math.min(...allCols),\n    };\n    const toCoords = {\n      row: Math.max(...allRows),\n      col: Math.max(...allCols),\n    };\n\n    this.selectionBehavior.deselectAll();\n    this.selectionBehavior.select(fromCoords, toCoords);\n    this.selectionAnchor.set(coords);\n  }\n\n  /** Resets the active state of the grid if it is empty or stale. */\n  resetState(): boolean {\n    if (this.focusBehavior.stateEmpty()) {\n      const firstFocusableCoords = this.navigationBehavior.peekFirst();\n      if (firstFocusableCoords === undefined) {\n        return false;\n      }\n\n      return this.focusBehavior.focusCoordinates(firstFocusableCoords);\n    }\n\n    if (this.focusBehavior.stateStale()) {\n      // Try focus on the same active cell after if a reordering happened.\n      if (this.focusBehavior.focusCell(this.focusBehavior.activeCell()!)) {\n        return true;\n      }\n\n      // If the active cell is no longer exist, focus on the coordinates instead.\n      if (this.focusBehavior.focusCoordinates(this.focusBehavior.activeCoords())) {\n        return true;\n      }\n\n      // If the cooridnates no longer valid, go back to the first available cell.\n      if (this.focusBehavior.focusCoordinates(this.navigationBehavior.peekFirst()!)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport {KeyboardEventManager, PointerEventManager, Modifier} from '../behaviors/event-manager';\nimport {Grid, GridInputs as GridBehaviorInputs} from '../behaviors/grid';\nimport type {GridRowPattern} from './row';\nimport type {GridCellPattern} from './cell';\n\n/** Represents the required inputs for the grid pattern. */\nexport interface GridInputs extends Omit<GridBehaviorInputs<GridCellPattern>, 'cells'> {\n  /** The html element of the grid. */\n  element: SignalLike<HTMLElement>;\n\n  /** The rows that make up the grid. */\n  rows: SignalLike<GridRowPattern[]>;\n\n  /** A function that returns the grid cell associated with a given element. */\n  getCell: (e: Element) => GridCellPattern | undefined;\n}\n\n/** The UI pattern for a grid, handling keyboard navigation, focus, and selection. */\nexport class GridPattern {\n  /** The underlying grid behavior that this pattern is built on. */\n  readonly gridBehavior: Grid<GridCellPattern>;\n\n  /** The cells in the grid. */\n  readonly cells = computed(() => this.gridBehavior.data.cells());\n\n  /** The tab index for the grid. */\n  readonly tabIndex = computed(() => this.gridBehavior.gridTabIndex());\n\n  /** Whether the grid is disabled. */\n  readonly disabled = computed(() => this.gridBehavior.gridDisabled());\n\n  /** The ID of the currently active descendant cell. */\n  readonly activeDescendant = computed(() => this.gridBehavior.activeDescendant());\n\n  /** The currently active cell. */\n  readonly activeCell = computed(() => this.gridBehavior.focusBehavior.activeCell());\n\n  /** Whether to pause grid navigation. */\n  readonly pauseNavigation = computed(() =>\n    this.gridBehavior.data\n      .cells()\n      .flat()\n      .reduce((res, c) => res || c.widgetActivated(), false),\n  );\n\n  /** Whether the focus is in the grid. */\n  readonly isFocused = signal(false);\n\n  /** Whether the user is currently dragging to select a range of cells. */\n  readonly dragging = signal(false);\n\n  /** The keydown event manager for the grid. */\n  readonly keydown = computed(() => {\n    const manager = new KeyboardEventManager();\n\n    if (this.pauseNavigation()) {\n      return manager;\n    }\n\n    manager\n      .on('ArrowUp', () => this.gridBehavior.up())\n      .on('ArrowDown', () => this.gridBehavior.down())\n      .on('ArrowLeft', () => this.gridBehavior.left())\n      .on('ArrowRight', () => this.gridBehavior.right())\n      .on('Home', () => this.gridBehavior.firstInRow())\n      .on('End', () => this.gridBehavior.lastInRow())\n      .on([Modifier.Ctrl], 'Home', () => this.gridBehavior.first())\n      .on([Modifier.Ctrl], 'End', () => this.gridBehavior.last());\n\n    if (this.inputs.enableSelection()) {\n      manager\n        .on(Modifier.Shift, 'ArrowUp', () => this.gridBehavior.rangeSelectUp())\n        .on(Modifier.Shift, 'ArrowDown', () => this.gridBehavior.rangeSelectDown())\n        .on(Modifier.Shift, 'ArrowLeft', () => this.gridBehavior.rangeSelectLeft())\n        .on(Modifier.Shift, 'ArrowRight', () => this.gridBehavior.rangeSelectRight())\n        .on([Modifier.Ctrl, Modifier.Meta], 'A', () => this.gridBehavior.selectAll())\n        .on([Modifier.Shift], ' ', () => this.gridBehavior.selectRow())\n        .on([Modifier.Ctrl, Modifier.Meta], ' ', () => this.gridBehavior.selectCol());\n    }\n\n    return manager;\n  });\n\n  /** The pointerdown event manager for the grid. */\n  readonly pointerdown = computed(() => {\n    const manager = new PointerEventManager();\n\n    manager.on(e => {\n      const cell = this.inputs.getCell(e.target as Element);\n      if (!cell) return;\n\n      this.gridBehavior.gotoCell(cell);\n\n      if (this.inputs.enableSelection()) {\n        this.dragging.set(true);\n      }\n    });\n\n    if (this.inputs.enableSelection()) {\n      manager\n        .on([Modifier.Ctrl, Modifier.Meta], e => {\n          const cell = this.inputs.getCell(e.target as Element);\n          if (!cell) return;\n\n          this.gridBehavior.toggleSelect(cell);\n        })\n        .on(Modifier.Shift, e => {\n          const cell = this.inputs.getCell(e.target as Element);\n          if (!cell) return;\n\n          this.gridBehavior.rangeSelect(cell);\n          this.dragging.set(true);\n        });\n    }\n\n    return manager;\n  });\n\n  /** The pointerup event manager for the grid. */\n  readonly pointerup = computed(() => {\n    const manager = new PointerEventManager();\n\n    if (this.inputs.enableSelection()) {\n      manager.on([Modifier.Shift, Modifier.None], () => {\n        this.dragging.set(false);\n      });\n    }\n\n    return manager;\n  });\n\n  constructor(readonly inputs: GridInputs) {\n    this.gridBehavior = new Grid({\n      ...inputs,\n      cells: computed(() => this.inputs.rows().map(row => row.inputs.cells())),\n    });\n  }\n\n  /** Handles keydown events on the grid. */\n  onKeydown(event: KeyboardEvent) {\n    if (!this.disabled()) {\n      this.keydown().handle(event);\n    }\n  }\n\n  /** Handles pointerdown events on the grid. */\n  onPointerdown(event: PointerEvent) {\n    if (!this.disabled()) {\n      this.pointerdown().handle(event);\n    }\n  }\n\n  /** Handles pointermove events on the grid. */\n  onPointermove(event: PointerEvent) {\n    if (this.disabled()) return;\n    if (!this.inputs.enableSelection()) return;\n    if (!this.dragging()) return;\n\n    const cell = this.inputs.getCell(event.target as Element);\n    if (!cell) return;\n\n    this.gridBehavior.rangeSelect(cell);\n  }\n\n  /** Handles pointerup events on the grid. */\n  onPointerup(event: PointerEvent) {\n    if (!this.disabled()) {\n      this.pointerup().handle(event);\n    }\n  }\n\n  /** Handles focusin events on the grid. */\n  onFocusIn(event: FocusEvent) {\n    this.isFocused.set(true);\n\n    const cell = this.inputs.getCell(event.target as Element);\n    if (!cell) return;\n\n    this.gridBehavior.gotoCell(cell);\n  }\n\n  /** Indicates maybe the losing focus is caused by row/cell deletion. */\n  private readonly _maybeDeletion = signal(false);\n\n  /** Handles focusout events on the grid. */\n  onFocusOut(event: FocusEvent) {\n    const parentEl = this.inputs.element();\n    const targetEl = event.relatedTarget as Node | null;\n\n    // If a `relatedTarget` is null, then it can be caused by either\n    // - Clicking on a non-focusable element, or\n    // - The focused element is removed from the page.\n    if (targetEl === null) {\n      this._maybeDeletion.set(true);\n    }\n\n    if (parentEl.contains(targetEl)) return;\n    this.isFocused.set(false);\n  }\n\n  /** Indicates the losing focus is certainly caused by row/cell deletion. */\n  private readonly _deletion = signal(false);\n\n  /** Resets the active state of the grid if it is empty or stale. */\n  resetStateEffect(): void {\n    const hasReset = this.gridBehavior.resetState();\n\n    // If the active state has been reset right after a focusout event, then\n    // we know it's caused by a row/cell deletion.\n    if (hasReset && this._maybeDeletion()) {\n      this._deletion.set(true);\n    }\n\n    if (this._maybeDeletion()) {\n      this._maybeDeletion.set(false);\n    }\n  }\n\n  /** Focuses on the active cell element. */\n  focusEffect(): void {\n    const activeCell = this.activeCell();\n    const hasFocus = this.isFocused();\n    const deletion = this._deletion();\n    const isRoving = this.inputs.focusMode() === 'roving';\n    if (activeCell !== undefined && isRoving && (hasFocus || deletion)) {\n      activeCell.element().focus();\n\n      if (deletion) {\n        this._deletion.set(false);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../behaviors/signal-like/signal-like';\nimport {GridCell} from '../behaviors/grid';\nimport type {GridPattern} from './grid';\nimport type {GridRowPattern} from './row';\nimport type {GridCellWidgetPattern} from './widget';\n\n/** The inputs for the `GridCellPattern`. */\nexport interface GridCellInputs extends GridCell {\n  /** The `GridPattern` that this cell belongs to. */\n  grid: SignalLike<GridPattern>;\n\n  /** The `GridRowPattern` that this cell belongs to. */\n  row: SignalLike<GridRowPattern>;\n\n  /** The widget pattern contained within this cell, if any. */\n  widget: SignalLike<GridCellWidgetPattern | undefined>;\n\n  /** The index of this cell's row within the grid. */\n  rowIndex: SignalLike<number | undefined>;\n\n  /** The index of this cell's column within the grid. */\n  colIndex: SignalLike<number | undefined>;\n}\n\n/** The UI pattern for a grid cell. */\nexport class GridCellPattern implements GridCell {\n  /** A unique identifier for the cell. */\n  readonly id: SignalLike<string>;\n\n  /** Whether a cell is disabled. */\n  readonly disabled: SignalLike<boolean>;\n\n  /** Whether the cell is selected. */\n  readonly selected: WritableSignalLike<boolean>;\n\n  /** Whether the cell is selectable. */\n  readonly selectable: SignalLike<boolean>;\n\n  /** The number of rows the cell should span. */\n  readonly rowSpan: SignalLike<number>;\n\n  /** The number of columns the cell should span. */\n  readonly colSpan: SignalLike<number>;\n\n  /** The `aria-selected` attribute for the cell. */\n  readonly ariaSelected = computed<boolean | undefined>(() =>\n    this.inputs.grid().inputs.enableSelection() && this.selectable() ? this.selected() : undefined,\n  );\n\n  /** The `aria-rowindex` attribute for the cell. */\n  readonly ariaRowIndex = computed(\n    () =>\n      this.inputs.row().rowIndex() ??\n      this.inputs.rowIndex() ??\n      this.inputs.grid().gridBehavior.rowIndex(this),\n  );\n\n  /** The `aria-colindex` attribute for the cell. */\n  readonly ariaColIndex = computed(\n    () => this.inputs.colIndex() ?? this.inputs.grid().gridBehavior.colIndex(this),\n  );\n\n  /** The html element that should receive focus. */\n  readonly element: SignalLike<HTMLElement> = computed(\n    () => this.inputs.widget()?.element() ?? this.inputs.element(),\n  );\n\n  /** Whether the cell is active. */\n  readonly active = computed(() => this.inputs.grid().activeCell() === this);\n\n  /** The internal tab index calculation for the cell. */\n  private readonly _tabIndex: SignalLike<-1 | 0> = computed(() =>\n    this.inputs.grid().gridBehavior.cellTabIndex(this),\n  );\n\n  /** The `tabindex` for the cell. If the cell contains a widget, the cell's tabindex is -1. */\n  readonly tabIndex: SignalLike<-1 | 0> = computed(() =>\n    this.inputs.widget() !== undefined ? -1 : this._tabIndex(),\n  );\n\n  /** Whether the widget within the cell is activated. */\n  readonly widgetActivated: SignalLike<boolean> = computed(\n    () => this.inputs.widget()?.inputs.activate() ?? false,\n  );\n\n  constructor(readonly inputs: GridCellInputs) {\n    this.id = inputs.id;\n    this.disabled = inputs.disabled;\n    this.rowSpan = inputs.rowSpan;\n    this.colSpan = inputs.colSpan;\n    this.selected = inputs.selected;\n    this.selectable = inputs.selectable;\n  }\n\n  /** Gets the `tabindex` for the widget within the cell. */\n  widgetTabIndex(): -1 | 0 {\n    return this._tabIndex();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../behaviors/signal-like/signal-like';\nimport type {GridCellPattern} from './cell';\n\n/** The inputs for the `GridCellWidgetPattern`. */\nexport interface GridCellWidgetInputs {\n  /** The `GridCellPattern` that this widget belongs to. */\n  cell: SignalLike<GridCellPattern>;\n\n  /** The html element that should receive focus. */\n  element: SignalLike<HTMLElement>;\n\n  /**\n   * Whether the widget is activated, which pauses grid navigation to allow interaction\n   * with the widget.\n   */\n  activate: WritableSignalLike<boolean>;\n}\n\n/** The UI pattern for a widget inside a grid cell. */\nexport class GridCellWidgetPattern {\n  /** The html element that should receive focus. */\n  readonly element: SignalLike<HTMLElement>;\n\n  /** The `tabindex` for the widget. */\n  readonly tabIndex: SignalLike<-1 | 0> = computed(() => this.inputs.cell().widgetTabIndex());\n\n  /** Whether the widget is in an active state (i.e. its containing cell is active). */\n  readonly active: SignalLike<boolean> = computed(() => this.inputs.cell().active());\n\n  constructor(readonly inputs: GridCellWidgetInputs) {\n    this.element = inputs.element;\n  }\n}\n"],"names":["Modifier","EventManager","options","preventDefault","stopPropagation","modifiers","key","handler","_normalizeInputs","args","configs","push","_isMatch","event","MouseButton","PointerEventManager","on","button","matcher","computed","cells","length","maxRowCount","maxColCount","Math","max","_colCountsByRow","values","_coordsMap","coordsMap","Map","rowIndex","colIndex","row","cell","visitedCoords","rowSpan","colspan","colSpan","rowOffset","rowspan","colOffset","col","add","set","coords","spanCoords","entries","cellMap","_","colCount","colCountByRow","get","newColCount","signal","activeCell","undefined","stateStale","activeCoordsCell","inputs","grid","getCell","activeCoords","activeCellNotValid","activeCellCoords","activeCellMismatch","gridDisabled","focusMode","currentActiveCell","disabled","gridCells","every","constructor","getCellTabindex","Right","GridNavigation","gridFocus","focusCell","wrap","direction","rowWrap","colWrap","_peekDirectional","fromCoords","advance","nextCoords","peek","gotoCoords","peekFirst","peekLast","Left","select","toCoords","_validCells","selected","deselect","toggle","update","state","Grid","data","navigationBehavior","focusBehavior","gridTabIndex","activeDescendant","GridData","selectionBehavior","GridSelection","index","getCoords","Up","rangeSelectUp","Down","rangeSelectDown","_rangeSelectCoords","rangeSelectLeft","rangeSelectRight","first","firstInRow","last","selectRow","deselectAll","selectAll","gotoCell","rangeSelect","gridBehavior","tabIndex","pauseNavigation","flat","reduce","res","c","widgetActivated","isFocused","manager","KeyboardEventManager","up","down","left","right","Ctrl","Shift","Meta","selectCol","e","target","enableSelection","dragging","toggleSelect","rows","map","onKeydown","keydown","handle","pointerdown","onPointerup","pointerup","onFocusIn","selectable","ariaRowIndex","widgetTabIndex"],"mappings":"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"}