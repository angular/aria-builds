{"version":3,"file":"_widget-chunk.mjs","sources":["../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/event-manager/event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/event-manager/keyboard-event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/event-manager/pointer-event-manager.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-data.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-focus.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-navigation.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid-selection.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/behaviors/grid/grid.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/grid.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/row.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/cell.ts","../../../../../k8-fastbuild-ST-199a4f3c4e20/bin/src/aria/private/grid/widget.ts"],"sourcesContent":["/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\n/**\n * An event that supports modifier keys.\n *\n * Matches the native KeyboardEvent, MouseEvent, and TouchEvent.\n */\nexport interface EventWithModifiers extends Event {\n  ctrlKey: boolean;\n  shiftKey: boolean;\n  altKey: boolean;\n  metaKey: boolean;\n}\n\n/**\n * Options that are applicable to all event handlers.\n *\n * This library has not yet had a need for stopPropagationImmediate.\n */\nexport interface EventHandlerOptions {\n  stopPropagation: boolean;\n  preventDefault: boolean;\n}\n\n/** A basic event handler. */\nexport type EventHandler<T extends Event> = (event: T) => void;\n\n/** A function that determines whether an event is to be handled. */\nexport type EventMatcher<T extends Event> = (event: T) => boolean;\n\n/** A config that specifies how to handle a particular event. */\nexport interface EventHandlerConfig<T extends Event> extends EventHandlerOptions {\n  matcher: EventMatcher<T>;\n  handler: EventHandler<T>;\n}\n\n/** Bit flag representation of the possible modifier keys that can be present on an event. */\nexport enum Modifier {\n  None = 0,\n  Ctrl = 0b1,\n  Shift = 0b10,\n  Alt = 0b100,\n  Meta = 0b1000,\n  Any = 'Any',\n}\n\nexport type ModifierInputs = Modifier | Modifier[];\n\n/**\n * Abstract base class for all event managers.\n *\n * Event managers are designed to normalize how event handlers are authored and create a safety net\n * for common event handling gotchas like remembering to call preventDefault or stopPropagation.\n */\nexport abstract class EventManager<T extends Event> {\n  protected configs: EventHandlerConfig<T>[] = [];\n  abstract options: EventHandlerOptions;\n\n  /** Runs the handlers that match with the given event. */\n  handle(event: T): void {\n    for (const config of this.configs) {\n      if (config.matcher(event)) {\n        config.handler(event);\n\n        if (config.preventDefault) {\n          event.preventDefault();\n        }\n\n        if (config.stopPropagation) {\n          event.stopPropagation();\n        }\n      }\n    }\n  }\n\n  /** Configures the event manager to handle specific events. (See subclasses for more). */\n  abstract on(...args: [...unknown[]]): this;\n}\n\n/** Gets bit flag representation of the modifier keys present on the given event. */\nexport function getModifiers(event: EventWithModifiers): number {\n  return (\n    (+event.ctrlKey && Modifier.Ctrl) |\n    (+event.shiftKey && Modifier.Shift) |\n    (+event.altKey && Modifier.Alt) |\n    (+event.metaKey && Modifier.Meta)\n  );\n}\n\n/**\n * Checks if the given event has modifiers that are an exact match for any of the given modifier\n * flag combinations.\n */\nexport function hasModifiers(event: EventWithModifiers, modifiers: ModifierInputs): boolean {\n  const eventModifiers = getModifiers(event);\n  const modifiersList = Array.isArray(modifiers) ? modifiers : [modifiers];\n\n  if (modifiersList.includes(Modifier.Any)) {\n    return true;\n  }\n\n  return modifiersList.some(modifiers => eventModifiers === modifiers);\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SignalLike} from '../signal-like/signal-like';\nimport {\n  EventHandler,\n  EventHandlerOptions,\n  EventManager,\n  hasModifiers,\n  ModifierInputs,\n  Modifier,\n} from './event-manager';\n\n/**\n * Used to represent a keycode.\n *\n * This is used to match whether an events keycode should be handled. The ability to match using a\n * string, SignalLike, or Regexp gives us more flexibility when authoring event handlers.\n */\ntype KeyCode = string | SignalLike<string> | RegExp;\n\n/**\n * An event manager that is specialized for handling keyboard events. By default this manager stops\n * propagation and prevents default on all events it handles.\n */\nexport class KeyboardEventManager<T extends KeyboardEvent> extends EventManager<T> {\n  options: EventHandlerOptions = {\n    preventDefault: true,\n    stopPropagation: true,\n  };\n\n  /** Configures this event manager to handle events with a specific key and no modifiers. */\n  on(key: KeyCode, handler: EventHandler<T>): this;\n\n  /**  Configures this event manager to handle events with a specific modifer and key combination. */\n  on(modifiers: ModifierInputs, key: KeyCode, handler: EventHandler<T>): this;\n\n  on(...args: any[]) {\n    const {modifiers, key, handler} = this._normalizeInputs(...args);\n\n    this.configs.push({\n      handler: handler,\n      matcher: event => this._isMatch(event, key, modifiers),\n      ...this.options,\n    });\n\n    return this;\n  }\n\n  private _normalizeInputs(...args: any[]) {\n    const key = args.length === 3 ? args[1] : args[0];\n    const handler = args.length === 3 ? args[2] : args[1];\n    const modifiers = args.length === 3 ? args[0] : Modifier.None;\n\n    return {\n      key: key as KeyCode,\n      handler: handler as EventHandler<T>,\n      modifiers: modifiers as ModifierInputs,\n    };\n  }\n\n  private _isMatch(event: T, key: KeyCode, modifiers: ModifierInputs) {\n    if (!hasModifiers(event, modifiers)) {\n      return false;\n    }\n\n    if (key instanceof RegExp) {\n      return key.test(event.key);\n    }\n\n    const keyStr = typeof key === 'string' ? key : key();\n    return keyStr.toLowerCase() === event.key.toLowerCase();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {\n  EventHandler,\n  EventHandlerOptions,\n  EventManager,\n  hasModifiers,\n  ModifierInputs,\n  Modifier,\n} from './event-manager';\n\n/**\n * The different mouse buttons that may appear on a pointer event.\n */\nexport enum MouseButton {\n  Main = 0,\n  Auxiliary = 1,\n  Secondary = 2,\n}\n\n/** An event manager that is specialized for handling pointer events. */\nexport class PointerEventManager<T extends PointerEvent> extends EventManager<T> {\n  options: EventHandlerOptions = {\n    preventDefault: false,\n    stopPropagation: false,\n  };\n\n  /**\n   * Configures this event manager to handle events with a specific modifer and mouse button\n   * combination.\n   */\n  on(button: MouseButton, modifiers: ModifierInputs, handler: EventHandler<T>): this;\n\n  /**\n   * Configures this event manager to handle events with a specific mouse button and no modifiers.\n   */\n  on(modifiers: ModifierInputs, handler: EventHandler<T>): this;\n\n  /**\n   * Configures this event manager to handle events with the main mouse button and no modifiers.\n   *\n   * @param handler The handler function\n   * @param options Options for whether to stop propagation or prevent default.\n   */\n  on(handler: EventHandler<T>): this;\n\n  on(...args: any[]) {\n    const {button, handler, modifiers} = this._normalizeInputs(...args);\n\n    this.configs.push({\n      handler,\n      matcher: event => this._isMatch(event, button, modifiers),\n      ...this.options,\n    });\n    return this;\n  }\n\n  private _normalizeInputs(...args: any[]) {\n    if (args.length === 3) {\n      return {\n        button: args[0] as MouseButton,\n        modifiers: args[1] as ModifierInputs,\n        handler: args[2] as EventHandler<T>,\n      };\n    }\n\n    if (args.length === 2) {\n      return {\n        button: MouseButton.Main,\n        modifiers: args[0] as ModifierInputs,\n        handler: args[1] as EventHandler<T>,\n      };\n    }\n\n    return {\n      button: MouseButton.Main,\n      modifiers: Modifier.None,\n      handler: args[0] as EventHandler<T>,\n    };\n  }\n\n  _isMatch(event: PointerEvent, button: MouseButton, modifiers: ModifierInputs) {\n    return button === (event.button ?? 0) && hasModifiers(event, modifiers);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\n\n/** Represents coordinates in a grid. */\nexport interface RowCol {\n  /** The row index. */\n  row: number;\n\n  /** The column index. */\n  col: number;\n}\n\n/** A string representation of grid coordinates. */\ntype CoordString = `${RowCol['row']}:${RowCol['col']}`;\n\n/** The base interface for a cell in a grid. */\nexport interface BaseGridCell {\n  /** The number of rows the cell should span. */\n  rowSpan: SignalLike<number>;\n\n  /** The number of columns the cell should span. */\n  colSpan: SignalLike<number>;\n}\n\n/** Represents the required inputs for GridData. */\nexport interface GridDataInputs<T extends BaseGridCell> {\n  /** The two-dimensional array of cells that represents the grid. */\n  cells: SignalLike<T[][]>;\n}\n\n/** Controls internal coordinates for a grid of items. */\nexport class GridData<T extends BaseGridCell> {\n  /** The two-dimensional array of cells that represents the grid. */\n  readonly cells: SignalLike<T[][]>;\n\n  /** The number of rows in the grid. */\n  readonly rowCount = computed<number>(() => this.cells().length);\n\n  /** The maximum number of rows in the grid, accounting for row spans. */\n  readonly maxRowCount = computed<number>(() => Math.max(...this._rowCountByCol().values(), 0));\n\n  /** The maximum number of columns in the grid, accounting for column spans. */\n  readonly maxColCount = computed<number>(() => Math.max(...this._colCountsByRow().values(), 0));\n\n  /** A map from a cell to its primary and spanned coordinates. */\n  private readonly _coordsMap = computed<Map<T, {coords: RowCol; spanCoords: RowCol[]}>>(() => {\n    const coordsMap = new Map();\n    const visitedCoords = new Set();\n\n    for (let rowIndex = 0; rowIndex < this.cells().length; rowIndex++) {\n      let colIndex = 0;\n      const row = this.cells()[rowIndex];\n\n      for (const cell of row) {\n        // Skip past cells that are already taken.\n        while (visitedCoords.has(`${rowIndex}:${colIndex}`)) {\n          colIndex++;\n        }\n\n        const rowspan = cell.rowSpan();\n        const colspan = cell.colSpan();\n        const spanCoords: RowCol[] = [];\n\n        for (let rowOffset = 0; rowOffset < rowspan; rowOffset++) {\n          const row = rowIndex + rowOffset;\n          for (let colOffset = 0; colOffset < colspan; colOffset++) {\n            const col = colIndex + colOffset;\n            visitedCoords.add(`${row}:${col}`);\n            spanCoords.push({row, col});\n          }\n        }\n        coordsMap.set(cell, {coords: spanCoords[0], spanCoords});\n\n        colIndex += colspan;\n      }\n    }\n\n    return coordsMap;\n  });\n\n  /** A map from a coordinate string to the cell at that coordinate. */\n  private readonly _cellMap = computed<Map<CoordString, T>>(() => {\n    const cellMap = new Map();\n    for (const [cell, {spanCoords}] of this._coordsMap().entries()) {\n      for (const {row, col} of spanCoords) {\n        cellMap.set(`${row}:${col}`, cell);\n      }\n    }\n    return cellMap;\n  });\n\n  /** A map from a row index to the number of columns in that row. */\n  private readonly _colCountsByRow = computed<Map<number, number>>(() => {\n    const colCountByRow = new Map();\n    for (const [_, {spanCoords}] of this._coordsMap().entries()) {\n      for (const {row, col} of spanCoords) {\n        const colCount = colCountByRow.get(row);\n        const newColCount = col + 1;\n        if (colCount === undefined || colCount < newColCount) {\n          colCountByRow.set(row, newColCount);\n        }\n      }\n    }\n    return colCountByRow;\n  });\n\n  /** A map from a column index to the number of rows in that column. */\n  private readonly _rowCountByCol = computed<Map<number, number>>(() => {\n    const rowCountByCol = new Map();\n    for (const [_, {spanCoords}] of this._coordsMap().entries()) {\n      for (const {row, col} of spanCoords) {\n        const rowCount = rowCountByCol.get(col);\n        const newRowCount = row + 1;\n        if (rowCount === undefined || rowCount < newRowCount) {\n          rowCountByCol.set(col, newRowCount);\n        }\n      }\n    }\n    return rowCountByCol;\n  });\n\n  constructor(readonly inputs: GridDataInputs<T>) {\n    this.cells = this.inputs.cells;\n  }\n\n  /** Gets the cell at the given coordinates. */\n  getCell(rowCol: RowCol): T | undefined {\n    return this._cellMap().get(`${rowCol.row}:${rowCol.col}`);\n  }\n\n  /** Gets the primary coordinates of the given cell. */\n  getCoords(cell: T): RowCol | undefined {\n    return this._coordsMap().get(cell)?.coords;\n  }\n\n  /** Gets all coordinates that the given cell spans. */\n  getAllCoords(cell: T): RowCol[] | undefined {\n    return this._coordsMap().get(cell)?.spanCoords;\n  }\n\n  /** Gets the number of rows in the given column. */\n  getRowCount(col: number): number | undefined {\n    return this._rowCountByCol().get(col);\n  }\n\n  /** Gets the number of columns in the given row. */\n  getColCount(row: number): number | undefined {\n    return this._colCountsByRow().get(row);\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\nimport type {GridData, BaseGridCell, RowCol} from './grid-data';\n\n/** Represents an cell in a grid, such as a grid cell, that may receive focus. */\nexport interface GridFocusCell extends BaseGridCell {\n  /** A unique identifier for the cell. */\n  id: SignalLike<string>;\n\n  /** The html element that should receive focus. */\n  element: SignalLike<HTMLElement>;\n\n  /** Whether a cell is disabled. */\n  disabled: SignalLike<boolean>;\n}\n\n/** Represents the required inputs for a grid that contains focusable cells. */\nexport interface GridFocusInputs {\n  /** The focus strategy used by the grid. */\n  focusMode: SignalLike<'roving' | 'activedescendant'>;\n\n  /** Whether the grid is disabled. */\n  disabled: SignalLike<boolean>;\n\n  /** Whether disabled cells in the grid should be skipped when navigating. */\n  skipDisabled: SignalLike<boolean>;\n}\n\n/** Dependencies for the `GridFocus` class. */\ninterface GridFocusDeps<T extends GridFocusCell> {\n  /** The `GridData` instance that this focus manager operates on. */\n  grid: GridData<T>;\n}\n\n/** Controls focus for a 2D grid of cells. */\nexport class GridFocus<T extends GridFocusCell> {\n  /** The current active cell. */\n  readonly activeCell = signal<T | undefined>(undefined);\n\n  /** The current active cell coordinates. */\n  readonly activeCoords = signal<RowCol>({row: -1, col: -1});\n\n  /** Whether the grid active state is empty (no active cell or coordinates). */\n  readonly stateEmpty = computed(\n    () =>\n      this.activeCell() === undefined ||\n      (this.activeCoords().row === -1 && this.activeCoords().col === -1),\n  );\n\n  /**\n   * Whether the grid focus state is stale.\n   *\n   * A stale state means the active cell or coordinates are no longer valid based on the\n   * current grid data, for example if the underlying cells have changed.\n   * A stale state should be re-initialized.\n   */\n  readonly stateStale = computed(() => {\n    if (this.stateEmpty()) {\n      return true;\n    }\n\n    const activeCell = this.activeCell();\n    const activeCellCoords = this.inputs.grid.getCoords(activeCell!);\n    const activeCoords = this.activeCoords();\n    const activeCoordsCell = this.inputs.grid.getCell(activeCoords);\n\n    const activeCellNotValid = activeCellCoords === undefined;\n    const activeCellMismatch = activeCell !== activeCoordsCell;\n    return activeCellNotValid || activeCellMismatch;\n  });\n\n  /** The id of the current active cell, for ARIA activedescendant. */\n  readonly activeDescendant = computed<string | undefined>(() => {\n    if (this.gridDisabled() || this.inputs.focusMode() === 'roving') {\n      return undefined;\n    }\n    const currentActiveCell = this.activeCell();\n    return currentActiveCell ? currentActiveCell.id() : undefined;\n  });\n\n  /** Whether the grid is in a disabled state. */\n  readonly gridDisabled = computed<boolean>(() => {\n    if (this.inputs.disabled()) {\n      return true;\n    }\n    const gridCells = this.inputs.grid.cells();\n    return gridCells.length === 0 || gridCells.every(row => row.every(cell => cell.disabled()));\n  });\n\n  /** The tabindex for the grid container. */\n  readonly gridTabIndex = computed<-1 | 0>(() => {\n    if (this.gridDisabled()) {\n      return 0;\n    }\n    return this.inputs.focusMode() === 'activedescendant' ? 0 : -1;\n  });\n\n  constructor(readonly inputs: GridFocusInputs & GridFocusDeps<T>) {}\n\n  /** Returns the tabindex for the given grid cell cell. */\n  getCellTabindex(cell: T): -1 | 0 {\n    if (this.gridDisabled()) {\n      return -1;\n    }\n    if (this.inputs.focusMode() === 'activedescendant') {\n      return -1;\n    }\n    return this.activeCell() === cell ? 0 : -1;\n  }\n\n  /** Returns true if the given cell can be navigated to. */\n  isFocusable(cell: T): boolean {\n    return !cell.disabled() || !this.inputs.skipDisabled();\n  }\n\n  /** Focuses the given cell. */\n  focusCell(cell: T): boolean {\n    if (this.gridDisabled()) {\n      return false;\n    }\n\n    if (!this.isFocusable(cell)) {\n      return false;\n    }\n\n    if (this.inputs.grid.getCoords(cell) === undefined) {\n      return false;\n    }\n\n    this.activeCoords.set(this.inputs.grid.getCoords(cell)!);\n    this.activeCell.set(cell);\n\n    return true;\n  }\n\n  /** Moves focus to the cell at the given coordinates if it's part of a focusable cell. */\n  focusCoordinates(coords: RowCol): boolean {\n    if (this.gridDisabled()) {\n      return false;\n    }\n\n    const cell = this.inputs.grid.getCell(coords);\n\n    if (!cell || !this.isFocusable(cell)) {\n      return false;\n    }\n\n    if (this.inputs.grid.getCell(coords) === undefined) {\n      return false;\n    }\n\n    this.activeCoords.set(coords);\n    this.activeCell.set(this.inputs.grid.getCell(coords));\n\n    return true;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\nimport {GridFocus, GridFocusCell, GridFocusInputs} from './grid-focus';\nimport {GridData, RowCol} from './grid-data';\n\n/** A utility type that ensures an object has exactly one key from a given set. */\ntype ExactlyOneKey<T, K extends keyof T = keyof T> = {\n  [P in K]: Record<P, T[P]> & Partial<Record<Exclude<K, P>, never>>;\n}[K];\n\n/** Represents a directional change in the grid, either by row or by column. */\ntype Delta = ExactlyOneKey<{row: -1 | 1; col: -1 | 1}>;\n\n/** Constants for the four cardinal directions. */\nexport const direction: Record<'Up' | 'Down' | 'Left' | 'Right', Delta> = {\n  Up: {row: -1},\n  Down: {row: 1},\n  Left: {col: -1},\n  Right: {col: 1},\n} as const;\n\n/** The wrapping behavior for keyboard navigation. */\nexport type WrapStrategy = 'continuous' | 'loop' | 'nowrap';\n\n/** Represents an item in a collection, such as a listbox option, than can be navigated to. */\nexport interface GridNavigationCell extends GridFocusCell {}\n\n/** Represents the required inputs for a collection that has navigable items. */\nexport interface GridNavigationInputs extends GridFocusInputs {\n  /** The wrapping behavior for keyboard navigation along the row axis. */\n  rowWrap: SignalLike<WrapStrategy>;\n\n  /** The wrapping behavior for keyboard navigation along the column axis. */\n  colWrap: SignalLike<WrapStrategy>;\n}\n\n/** Dependencies for the `GridNavigation` class. */\ninterface GridNavigationDeps<T extends GridNavigationCell> {\n  /** The `GridData` instance that this navigation manager operates on. */\n  grid: GridData<T>;\n\n  /** The `GridFocus` instance that this navigation manager uses to manage focus. */\n  gridFocus: GridFocus<T>;\n}\n\n/** Controls navigation for a grid of items. */\nexport class GridNavigation<T extends GridNavigationCell> {\n  /** The maximum number of steps to take when searching for the next cell. */\n  private _maxSteps = computed<number>(\n    () => this.inputs.grid.maxRowCount() * this.inputs.grid.maxColCount(),\n  );\n\n  constructor(readonly inputs: GridNavigationInputs & GridNavigationDeps<T>) {}\n\n  /** Navigates to the given item. */\n  gotoCell(cell: T): boolean {\n    return this.inputs.gridFocus.focusCell(cell);\n  }\n\n  /** Navigates to the given coordinates. */\n  gotoCoords(coords: RowCol): boolean {\n    return this.inputs.gridFocus.focusCoordinates(coords);\n  }\n\n  /**\n   * Gets the coordinates of the next focusable cell in a given direction, without changing focus.\n   */\n  peek(direction: Delta, fromCoords: RowCol, wrap?: WrapStrategy): RowCol | undefined {\n    wrap = wrap ?? (direction.row !== undefined ? this.inputs.rowWrap() : this.inputs.colWrap());\n    return this._peekDirectional(direction, fromCoords, wrap);\n  }\n\n  /**\n   * Navigates to the next focusable cell in a given direction.\n   */\n  advance(direction: Delta): boolean {\n    const nextCoords = this.peek(direction, this.inputs.gridFocus.activeCoords());\n    return !!nextCoords && this.gotoCoords(nextCoords);\n  }\n\n  /**\n   * Gets the coordinates of the first focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  peekFirst(row?: number): RowCol | undefined {\n    const fromCoords = {\n      row: row ?? 0,\n      col: -1,\n    };\n    return row === undefined\n      ? this._peekDirectional(direction.Right, fromCoords, 'continuous')\n      : this._peekDirectional(direction.Right, fromCoords, 'nowrap');\n  }\n\n  /**\n   * Navigates to the first focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  first(row?: number): boolean {\n    const nextCoords = this.peekFirst(row);\n    return !!nextCoords && this.gotoCoords(nextCoords);\n  }\n\n  /**\n   * Gets the coordinates of the last focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  peekLast(row?: number): RowCol | undefined {\n    const fromCoords = {\n      row: row ?? this.inputs.grid.maxRowCount() - 1,\n      col: this.inputs.grid.maxColCount(),\n    };\n    return row === undefined\n      ? this._peekDirectional(direction.Left, fromCoords, 'continuous')\n      : this._peekDirectional(direction.Left, fromCoords, 'nowrap');\n  }\n\n  /**\n   * Navigates to the last focusable cell.\n   * If a row is not provided, searches the entire grid.\n   */\n  last(row?: number): boolean {\n    const nextCoords = this.peekLast(row);\n    return !!nextCoords && this.gotoCoords(nextCoords);\n  }\n\n  /**\n   * Finds the next focusable cell in a given direction based on the wrapping behavior.\n   */\n  private _peekDirectional(\n    delta: Delta,\n    fromCoords: RowCol,\n    wrap: 'continuous' | 'loop' | 'nowrap',\n  ): RowCol | undefined {\n    const fromCell = this.inputs.grid.getCell(fromCoords);\n    const maxRowCount = this.inputs.grid.maxRowCount();\n    const maxColCount = this.inputs.grid.maxColCount();\n    const rowDelta = delta.row ?? 0;\n    const colDelta = delta.col ?? 0;\n    let nextCoords = {...fromCoords};\n\n    for (let step = 0; step < this._maxSteps(); step++) {\n      const isWrapping =\n        nextCoords.col + colDelta < 0 ||\n        nextCoords.col + colDelta >= maxColCount ||\n        nextCoords.row + rowDelta < 0 ||\n        nextCoords.row + rowDelta >= maxRowCount;\n\n      if (wrap === 'nowrap' && isWrapping) return;\n\n      if (wrap === 'continuous') {\n        const generalDelta = delta.row ?? delta.col;\n        const rowStep = isWrapping ? generalDelta : rowDelta;\n        const colStep = isWrapping ? generalDelta : colDelta;\n\n        nextCoords = {\n          row: (nextCoords.row + rowStep + maxRowCount) % maxRowCount,\n          col: (nextCoords.col + colStep + maxColCount) % maxColCount,\n        };\n      }\n\n      if (wrap === 'loop') {\n        nextCoords = {\n          row: (nextCoords.row + rowDelta + maxRowCount) % maxRowCount,\n          col: (nextCoords.col + colDelta + maxColCount) % maxColCount,\n        };\n      }\n\n      // Back to original coordinates.\n      if (nextCoords.row === fromCoords.row && nextCoords.col === fromCoords.col) {\n        return undefined;\n      }\n\n      const nextCell = this.inputs.grid.getCell(nextCoords);\n      if (\n        nextCell !== undefined &&\n        nextCell !== fromCell &&\n        this.inputs.gridFocus.isFocusable(nextCell)\n      ) {\n        return nextCoords;\n      }\n    }\n\n    return undefined;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SignalLike, WritableSignalLike} from '../signal-like/signal-like';\nimport {GridFocus, GridFocusCell, GridFocusInputs} from './grid-focus';\nimport {GridData, RowCol} from './grid-data';\n\n/** Represents a cell in a grid that can be selected. */\nexport interface GridSelectionCell extends GridFocusCell {\n  /** Whether the cell is selected. */\n  selected: WritableSignalLike<boolean>;\n\n  /** Whether the cell is selectable. */\n  selectable: SignalLike<boolean>;\n}\n\n/** Represents the required inputs for a grid that has selectable cells. */\nexport interface GridSelectionInputs extends GridFocusInputs {}\n\n/** Dependencies for the `GridSelection` class. */\ninterface GridSelectionDeps<T extends GridSelectionCell> {\n  /** The `GridData` instance that this selection manager operates on. */\n  grid: GridData<T>;\n\n  /** The `GridFocus` instance that this selection manager uses to manage focus. */\n  gridFocus: GridFocus<T>;\n}\n\n/** Controls selection for a grid of items. */\nexport class GridSelection<T extends GridSelectionCell> {\n  constructor(readonly inputs: GridSelectionInputs & GridSelectionDeps<T>) {}\n\n  /** Selects one or more cells in a given range. */\n  select(fromCoords: RowCol, toCoords?: RowCol): void {\n    for (const cell of this._validCells(fromCoords, toCoords ?? fromCoords)) {\n      cell.selected.set(true);\n    }\n  }\n\n  /** Deselects one or more cells in a given range. */\n  deselect(fromCoords: RowCol, toCoords?: RowCol): void {\n    for (const cell of this._validCells(fromCoords, toCoords ?? fromCoords)) {\n      cell.selected.set(false);\n    }\n  }\n\n  /** Toggles the selection state of one or more cells in a given range. */\n  toggle(fromCoords: RowCol, toCoords?: RowCol): void {\n    for (const cell of this._validCells(fromCoords, toCoords ?? fromCoords)) {\n      cell.selected.update(state => !state);\n    }\n  }\n\n  /** Selects all valid cells in the grid. */\n  selectAll(): void {\n    for (const cell of this._validCells(\n      {row: 0, col: 0},\n      {row: this.inputs.grid.maxRowCount(), col: this.inputs.grid.maxColCount()},\n    )) {\n      cell.selected.set(true);\n    }\n  }\n\n  /** Deselects all valid cells in the grid. */\n  deselectAll(): void {\n    for (const cell of this._validCells(\n      {row: 0, col: 0},\n      {row: this.inputs.grid.maxRowCount(), col: this.inputs.grid.maxColCount()},\n    )) {\n      cell.selected.set(false);\n    }\n  }\n\n  /** A generator that yields all valid (selectable and not disabled) cells within a given range. */\n  *_validCells(fromCoords: RowCol, toCoords: RowCol): Generator<T> {\n    const startRow = Math.min(fromCoords.row, toCoords.row);\n    const startCol = Math.min(fromCoords.col, toCoords.col);\n    const endRow = Math.max(fromCoords.row, toCoords.row);\n    const endCol = Math.max(fromCoords.col, toCoords.col);\n    const visited = new Set<T>();\n    for (let row = startRow; row < endRow + 1; row++) {\n      for (let col = startCol; col < endCol + 1; col++) {\n        const cell = this.inputs.grid.getCell({row, col});\n        if (cell === undefined) continue;\n        if (!cell.selectable()) continue;\n        if (cell.disabled()) continue;\n        if (visited.has(cell)) continue;\n        visited.add(cell);\n        yield cell;\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, linkedSignal} from '@angular/core';\nimport {SignalLike} from '../signal-like/signal-like';\nimport {GridData, BaseGridCell, GridDataInputs, RowCol} from './grid-data';\nimport {GridFocus, GridFocusCell, GridFocusInputs} from './grid-focus';\nimport {\n  direction,\n  GridNavigation,\n  GridNavigationCell,\n  GridNavigationInputs,\n} from './grid-navigation';\nimport {GridSelectionCell, GridSelectionInputs, GridSelection} from './grid-selection';\n\n/** A type that represents a cell in a grid, combining all cell-related interfaces. */\nexport type GridCell = BaseGridCell & GridFocusCell & GridNavigationCell & GridSelectionCell;\n\n/** Represents the required inputs for a grid. */\nexport interface GridInputs<T extends GridCell>\n  extends GridDataInputs<T>,\n    GridFocusInputs,\n    GridNavigationInputs,\n    GridSelectionInputs {\n  /** Whether selection is enabled for the grid. */\n  enableSelection: SignalLike<boolean>;\n}\n\n/** The main class that orchestrates the grid behaviors. */\nexport class Grid<T extends GridCell> {\n  /** The underlying data structure for the grid. */\n  readonly data: GridData<T>;\n\n  /** Controls focus for the grid. */\n  readonly focusBehavior: GridFocus<T>;\n\n  /** Controls navigation for the grid. */\n  readonly navigationBehavior: GridNavigation<T>;\n\n  /** Controls selection for the grid. */\n  readonly selectionBehavior: GridSelection<T>;\n\n  /** The anchor point for range selection, linked to the active coordinates. */\n  readonly selectionAnchor = linkedSignal<RowCol>(() => this.focusBehavior.activeCoords());\n\n  /** The `tabindex` for the grid container. */\n  readonly gridTabIndex = computed(() => this.focusBehavior.gridTabIndex());\n\n  /** Whether the grid is in a disabled state. */\n  readonly gridDisabled = computed(() => this.focusBehavior.gridDisabled());\n\n  /** The ID of the active descendant for ARIA `activedescendant` focus management. */\n  readonly activeDescendant = computed(() => this.focusBehavior.activeDescendant());\n\n  constructor(readonly inputs: GridInputs<T>) {\n    this.data = new GridData(inputs);\n    this.focusBehavior = new GridFocus({...inputs, grid: this.data});\n    this.navigationBehavior = new GridNavigation({\n      ...inputs,\n      grid: this.data,\n      gridFocus: this.focusBehavior,\n    });\n    this.selectionBehavior = new GridSelection({\n      ...inputs,\n      grid: this.data,\n      gridFocus: this.focusBehavior,\n    });\n  }\n\n  /** Gets the 1-based row index of a cell. */\n  rowIndex(cell: T): number | undefined {\n    const index = this.data.getCoords(cell)?.row;\n    return index !== undefined ? index + 1 : undefined;\n  }\n\n  /** Gets the 1-based column index of a cell. */\n  colIndex(cell: T): number | undefined {\n    const index = this.data.getCoords(cell)?.col;\n    return index !== undefined ? index + 1 : undefined;\n  }\n\n  /** Gets the `tabindex` for a given cell. */\n  cellTabIndex(cell: T): -1 | 0 {\n    return this.focusBehavior.getCellTabindex(cell);\n  }\n\n  /** Navigates to the cell above the currently active cell. */\n  up(): boolean {\n    return this.navigationBehavior.advance(direction.Up);\n  }\n\n  /** Extends the selection to the cell above the selection anchor. */\n  rangeSelectUp(): void {\n    const coords = this.navigationBehavior.peek(direction.Up, this.selectionAnchor());\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Navigates to the cell below the currently active cell. */\n  down(): boolean {\n    return this.navigationBehavior.advance(direction.Down);\n  }\n\n  /** Extends the selection to the cell below the selection anchor. */\n  rangeSelectDown(): void {\n    const coords = this.navigationBehavior.peek(direction.Down, this.selectionAnchor());\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Navigates to the cell to the left of the currently active cell. */\n  left(): boolean {\n    return this.navigationBehavior.advance(direction.Left);\n  }\n\n  /** Extends the selection to the cell to the left of the selection anchor. */\n  rangeSelectLeft(): void {\n    const coords = this.navigationBehavior.peek(direction.Left, this.selectionAnchor());\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Navigates to the cell to the right of the currently active cell. */\n  right(): boolean {\n    return this.navigationBehavior.advance(direction.Right);\n  }\n\n  /** Extends the selection to the cell to the right of the selection anchor. */\n  rangeSelectRight(): void {\n    const coords = this.navigationBehavior.peek(direction.Right, this.selectionAnchor());\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Navigates to the first focusable cell in the grid. */\n  first(): boolean {\n    return this.navigationBehavior.first();\n  }\n\n  /** Navigates to the first focusable cell in the current row. */\n  firstInRow(): boolean {\n    return this.navigationBehavior.first(this.focusBehavior.activeCoords().row);\n  }\n\n  /** Navigates to the last focusable cell in the grid. */\n  last(): boolean {\n    return this.navigationBehavior.last();\n  }\n\n  /** Navigates to the last focusable cell in the current row. */\n  lastInRow(): boolean {\n    return this.navigationBehavior.last(this.focusBehavior.activeCoords().row);\n  }\n\n  /** Selects all cells in the current row. */\n  selectRow(): void {\n    const row = this.focusBehavior.activeCoords().row;\n    this.selectionBehavior.deselectAll();\n    this.selectionBehavior.select({row, col: 0}, {row, col: this.data.maxColCount()});\n  }\n\n  /** Selects all cells in the current column. */\n  selectCol(): void {\n    const col = this.focusBehavior.activeCoords().col;\n    this.selectionBehavior.deselectAll();\n    this.selectionBehavior.select({row: 0, col}, {row: this.data.maxRowCount(), col});\n  }\n\n  /** Selects all selectable cells in the grid. */\n  selectAll(): void {\n    this.selectionBehavior.selectAll();\n  }\n\n  /** Navigates to and focuses the given cell. */\n  gotoCell(cell: T): boolean {\n    return this.navigationBehavior.gotoCell(cell);\n  }\n\n  /** Toggles the selection state of the given cell. */\n  toggleSelect(cell: T): void {\n    const coords = this.data.getCoords(cell);\n    if (coords === undefined) return;\n\n    this.selectionBehavior.toggle(coords);\n  }\n\n  /** Extends the selection from the anchor to the given cell. */\n  rangeSelect(cell: T): void {\n    const coords = this.data.getCoords(cell);\n    if (coords === undefined) return;\n\n    this._rangeSelectCoords(coords);\n  }\n\n  /** Extends the selection to the given coordinates. */\n  private _rangeSelectCoords(coords: RowCol): void {\n    const activeCell = this.focusBehavior.activeCell();\n    const anchorCell = this.data.getCell(coords);\n    if (activeCell === undefined || anchorCell === undefined) {\n      return;\n    }\n\n    const allCoords = [\n      ...this.data.getAllCoords(activeCell)!,\n      ...this.data.getAllCoords(anchorCell)!,\n    ];\n    const allRows = allCoords.map(c => c.row);\n    const allCols = allCoords.map(c => c.col);\n    const fromCoords = {\n      row: Math.min(...allRows),\n      col: Math.min(...allCols),\n    };\n    const toCoords = {\n      row: Math.max(...allRows),\n      col: Math.max(...allCols),\n    };\n\n    this.selectionBehavior.deselectAll();\n    this.selectionBehavior.select(fromCoords, toCoords);\n    this.selectionAnchor.set(coords);\n  }\n\n  /** Resets the active state of the grid if it is empty or stale. */\n  resetState(): boolean {\n    if (this.focusBehavior.stateEmpty()) {\n      const firstFocusableCoords = this.navigationBehavior.peekFirst();\n      if (firstFocusableCoords === undefined) {\n        return false;\n      }\n\n      return this.focusBehavior.focusCoordinates(firstFocusableCoords);\n    }\n\n    if (this.focusBehavior.stateStale()) {\n      // Try focus on the same active cell after if a reordering happened.\n      if (this.focusBehavior.focusCell(this.focusBehavior.activeCell()!)) {\n        return true;\n      }\n\n      // If the active cell is no longer exist, focus on the coordinates instead.\n      if (this.focusBehavior.focusCoordinates(this.focusBehavior.activeCoords())) {\n        return true;\n      }\n\n      // If the cooridnates no longer valid, go back to the first available cell.\n      if (this.focusBehavior.focusCoordinates(this.navigationBehavior.peekFirst()!)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed, signal} from '@angular/core';\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport {KeyboardEventManager, PointerEventManager, Modifier} from '../behaviors/event-manager';\nimport {Grid, GridInputs as GridBehaviorInputs} from '../behaviors/grid';\nimport type {GridRowPattern} from './row';\nimport type {GridCellPattern} from './cell';\n\n/** Represents the required inputs for the grid pattern. */\nexport interface GridInputs extends Omit<GridBehaviorInputs<GridCellPattern>, 'cells'> {\n  /** The html element of the grid. */\n  element: SignalLike<HTMLElement>;\n\n  /** The rows that make up the grid. */\n  rows: SignalLike<GridRowPattern[]>;\n\n  /** A function that returns the grid cell associated with a given element. */\n  getCell: (e: Element) => GridCellPattern | undefined;\n}\n\n/** The UI pattern for a grid, handling keyboard navigation, focus, and selection. */\nexport class GridPattern {\n  /** The underlying grid behavior that this pattern is built on. */\n  readonly gridBehavior: Grid<GridCellPattern>;\n\n  /** The cells in the grid. */\n  readonly cells = computed(() => this.gridBehavior.data.cells());\n\n  /** The tab index for the grid. */\n  readonly tabIndex = computed(() => this.gridBehavior.gridTabIndex());\n\n  /** Whether the grid is disabled. */\n  readonly disabled = computed(() => this.gridBehavior.gridDisabled());\n\n  /** The ID of the currently active descendant cell. */\n  readonly activeDescendant = computed(() => this.gridBehavior.activeDescendant());\n\n  /** The currently active cell. */\n  readonly activeCell = computed(() => this.gridBehavior.focusBehavior.activeCell());\n\n  /** Whether to pause grid navigation. */\n  readonly pauseNavigation = computed(() =>\n    this.gridBehavior.data\n      .cells()\n      .flat()\n      .reduce((res, c) => res || c.widgetActivated(), false),\n  );\n\n  /** Whether the focus is in the grid. */\n  readonly isFocused = signal(false);\n\n  /** Whether the user is currently dragging to select a range of cells. */\n  readonly dragging = signal(false);\n\n  /** The keydown event manager for the grid. */\n  readonly keydown = computed(() => {\n    const manager = new KeyboardEventManager();\n\n    if (this.pauseNavigation()) {\n      return manager;\n    }\n\n    manager\n      .on('ArrowUp', () => this.gridBehavior.up())\n      .on('ArrowDown', () => this.gridBehavior.down())\n      .on('ArrowLeft', () => this.gridBehavior.left())\n      .on('ArrowRight', () => this.gridBehavior.right())\n      .on('Home', () => this.gridBehavior.firstInRow())\n      .on('End', () => this.gridBehavior.lastInRow())\n      .on([Modifier.Ctrl], 'Home', () => this.gridBehavior.first())\n      .on([Modifier.Ctrl], 'End', () => this.gridBehavior.last());\n\n    if (this.inputs.enableSelection()) {\n      manager\n        .on(Modifier.Shift, 'ArrowUp', () => this.gridBehavior.rangeSelectUp())\n        .on(Modifier.Shift, 'ArrowDown', () => this.gridBehavior.rangeSelectDown())\n        .on(Modifier.Shift, 'ArrowLeft', () => this.gridBehavior.rangeSelectLeft())\n        .on(Modifier.Shift, 'ArrowRight', () => this.gridBehavior.rangeSelectRight())\n        .on([Modifier.Ctrl, Modifier.Meta], 'A', () => this.gridBehavior.selectAll())\n        .on([Modifier.Shift], ' ', () => this.gridBehavior.selectRow())\n        .on([Modifier.Ctrl, Modifier.Meta], ' ', () => this.gridBehavior.selectCol());\n    }\n\n    return manager;\n  });\n\n  /** The pointerdown event manager for the grid. */\n  readonly pointerdown = computed(() => {\n    const manager = new PointerEventManager();\n\n    manager.on(e => {\n      const cell = this.inputs.getCell(e.target as Element);\n      if (!cell) return;\n\n      this.gridBehavior.gotoCell(cell);\n\n      if (this.inputs.enableSelection()) {\n        this.dragging.set(true);\n      }\n    });\n\n    if (this.inputs.enableSelection()) {\n      manager\n        .on([Modifier.Ctrl, Modifier.Meta], e => {\n          const cell = this.inputs.getCell(e.target as Element);\n          if (!cell) return;\n\n          this.gridBehavior.toggleSelect(cell);\n        })\n        .on(Modifier.Shift, e => {\n          const cell = this.inputs.getCell(e.target as Element);\n          if (!cell) return;\n\n          this.gridBehavior.rangeSelect(cell);\n          this.dragging.set(true);\n        });\n    }\n\n    return manager;\n  });\n\n  /** The pointerup event manager for the grid. */\n  readonly pointerup = computed(() => {\n    const manager = new PointerEventManager();\n\n    if (this.inputs.enableSelection()) {\n      manager.on([Modifier.Shift, Modifier.None], () => {\n        this.dragging.set(false);\n      });\n    }\n\n    return manager;\n  });\n\n  constructor(readonly inputs: GridInputs) {\n    this.gridBehavior = new Grid({\n      ...inputs,\n      cells: computed(() => this.inputs.rows().map(row => row.inputs.cells())),\n    });\n  }\n\n  /** Handles keydown events on the grid. */\n  onKeydown(event: KeyboardEvent) {\n    if (!this.disabled()) {\n      this.keydown().handle(event);\n    }\n  }\n\n  /** Handles pointerdown events on the grid. */\n  onPointerdown(event: PointerEvent) {\n    if (!this.disabled()) {\n      this.pointerdown().handle(event);\n    }\n  }\n\n  /** Handles pointermove events on the grid. */\n  onPointermove(event: PointerEvent) {\n    if (this.disabled()) return;\n    if (!this.inputs.enableSelection()) return;\n    if (!this.dragging()) return;\n\n    const cell = this.inputs.getCell(event.target as Element);\n    if (!cell) return;\n\n    this.gridBehavior.rangeSelect(cell);\n  }\n\n  /** Handles pointerup events on the grid. */\n  onPointerup(event: PointerEvent) {\n    if (!this.disabled()) {\n      this.pointerup().handle(event);\n    }\n  }\n\n  /** Handles focusin events on the grid. */\n  onFocusIn(event: FocusEvent) {\n    this.isFocused.set(true);\n\n    const cell = this.inputs.getCell(event.target as Element);\n    if (!cell) return;\n\n    this.gridBehavior.gotoCell(cell);\n  }\n\n  /** Indicates maybe the losing focus is caused by row/cell deletion. */\n  private readonly _maybeDeletion = signal(false);\n\n  /** Handles focusout events on the grid. */\n  onFocusOut(event: FocusEvent) {\n    const parentEl = this.inputs.element();\n    const targetEl = event.relatedTarget as Node | null;\n\n    // If a `relatedTarget` is null, then it can be caused by either\n    // - Clicking on a non-focusable element, or\n    // - The focused element is removed from the page.\n    if (targetEl === null) {\n      this._maybeDeletion.set(true);\n    }\n\n    if (parentEl.contains(targetEl)) return;\n    this.isFocused.set(false);\n  }\n\n  /** Indicates the losing focus is certainly caused by row/cell deletion. */\n  private readonly _deletion = signal(false);\n\n  /** Resets the active state of the grid if it is empty or stale. */\n  resetStateEffect(): void {\n    const hasReset = this.gridBehavior.resetState();\n\n    // If the active state has been reset right after a focusout event, then\n    // we know it's caused by a row/cell deletion.\n    if (hasReset && this._maybeDeletion()) {\n      this._deletion.set(true);\n    }\n\n    if (this._maybeDeletion()) {\n      this._maybeDeletion.set(false);\n    }\n  }\n\n  /** Focuses on the active cell element. */\n  focusEffect(): void {\n    const activeCell = this.activeCell();\n    const hasFocus = this.isFocused();\n    const deletion = this._deletion();\n    const isRoving = this.inputs.focusMode() === 'roving';\n    if (activeCell !== undefined && isRoving && (hasFocus || deletion)) {\n      activeCell.element().focus();\n\n      if (deletion) {\n        this._deletion.set(false);\n      }\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {SignalLike} from '../behaviors/signal-like/signal-like';\nimport type {GridPattern} from './grid';\nimport type {GridCellPattern} from './cell';\n\n/** The inputs for the `GridRowPattern`. */\nexport interface GridRowInputs {\n  /** The `GridPattern` that this row belongs to. */\n  grid: SignalLike<GridPattern>;\n\n  /** The cells that make up this row. */\n  cells: SignalLike<GridCellPattern[]>;\n\n  /** The index of this row within the grid. */\n  rowIndex: SignalLike<number | undefined>;\n}\n\n/** The UI pattern for a grid row. */\nexport class GridRowPattern {\n  /** The index of this row within the grid. */\n  rowIndex: SignalLike<number | undefined>;\n\n  constructor(readonly inputs: GridRowInputs) {\n    this.rowIndex = inputs.rowIndex;\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../behaviors/signal-like/signal-like';\nimport {GridCell} from '../behaviors/grid';\nimport type {GridPattern} from './grid';\nimport type {GridRowPattern} from './row';\nimport type {GridCellWidgetPattern} from './widget';\n\n/** The inputs for the `GridCellPattern`. */\nexport interface GridCellInputs extends GridCell {\n  /** The `GridPattern` that this cell belongs to. */\n  grid: SignalLike<GridPattern>;\n\n  /** The `GridRowPattern` that this cell belongs to. */\n  row: SignalLike<GridRowPattern>;\n\n  /** The widget pattern contained within this cell, if any. */\n  widget: SignalLike<GridCellWidgetPattern | undefined>;\n\n  /** The index of this cell's row within the grid. */\n  rowIndex: SignalLike<number | undefined>;\n\n  /** The index of this cell's column within the grid. */\n  colIndex: SignalLike<number | undefined>;\n}\n\n/** The UI pattern for a grid cell. */\nexport class GridCellPattern implements GridCell {\n  /** A unique identifier for the cell. */\n  readonly id: SignalLike<string>;\n\n  /** Whether a cell is disabled. */\n  readonly disabled: SignalLike<boolean>;\n\n  /** Whether the cell is selected. */\n  readonly selected: WritableSignalLike<boolean>;\n\n  /** Whether the cell is selectable. */\n  readonly selectable: SignalLike<boolean>;\n\n  /** The number of rows the cell should span. */\n  readonly rowSpan: SignalLike<number>;\n\n  /** The number of columns the cell should span. */\n  readonly colSpan: SignalLike<number>;\n\n  /** The `aria-selected` attribute for the cell. */\n  readonly ariaSelected = computed<boolean | undefined>(() =>\n    this.inputs.grid().inputs.enableSelection() && this.selectable() ? this.selected() : undefined,\n  );\n\n  /** The `aria-rowindex` attribute for the cell. */\n  readonly ariaRowIndex = computed(\n    () =>\n      this.inputs.row().rowIndex() ??\n      this.inputs.rowIndex() ??\n      this.inputs.grid().gridBehavior.rowIndex(this),\n  );\n\n  /** The `aria-colindex` attribute for the cell. */\n  readonly ariaColIndex = computed(\n    () => this.inputs.colIndex() ?? this.inputs.grid().gridBehavior.colIndex(this),\n  );\n\n  /** The html element that should receive focus. */\n  readonly element: SignalLike<HTMLElement> = computed(\n    () => this.inputs.widget()?.element() ?? this.inputs.element(),\n  );\n\n  /** Whether the cell is active. */\n  readonly active = computed(() => this.inputs.grid().activeCell() === this);\n\n  /** The internal tab index calculation for the cell. */\n  private readonly _tabIndex: SignalLike<-1 | 0> = computed(() =>\n    this.inputs.grid().gridBehavior.cellTabIndex(this),\n  );\n\n  /** The `tabindex` for the cell. If the cell contains a widget, the cell's tabindex is -1. */\n  readonly tabIndex: SignalLike<-1 | 0> = computed(() =>\n    this.inputs.widget() !== undefined ? -1 : this._tabIndex(),\n  );\n\n  /** Whether the widget within the cell is activated. */\n  readonly widgetActivated: SignalLike<boolean> = computed(\n    () => this.inputs.widget()?.inputs.activate() ?? false,\n  );\n\n  constructor(readonly inputs: GridCellInputs) {\n    this.id = inputs.id;\n    this.disabled = inputs.disabled;\n    this.rowSpan = inputs.rowSpan;\n    this.colSpan = inputs.colSpan;\n    this.selected = inputs.selected;\n    this.selectable = inputs.selectable;\n  }\n\n  /** Gets the `tabindex` for the widget within the cell. */\n  widgetTabIndex(): -1 | 0 {\n    return this._tabIndex();\n  }\n}\n","/**\n * @license\n * Copyright Google LLC All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.dev/license\n */\n\nimport {computed} from '@angular/core';\nimport {SignalLike, WritableSignalLike} from '../behaviors/signal-like/signal-like';\nimport type {GridCellPattern} from './cell';\n\n/** The inputs for the `GridCellWidgetPattern`. */\nexport interface GridCellWidgetInputs {\n  /** The `GridCellPattern` that this widget belongs to. */\n  cell: SignalLike<GridCellPattern>;\n\n  /** The html element that should receive focus. */\n  element: SignalLike<HTMLElement>;\n\n  /**\n   * Whether the widget is activated, which pauses grid navigation to allow interaction\n   * with the widget.\n   */\n  activate: WritableSignalLike<boolean>;\n}\n\n/** The UI pattern for a widget inside a grid cell. */\nexport class GridCellWidgetPattern {\n  /** The html element that should receive focus. */\n  readonly element: SignalLike<HTMLElement>;\n\n  /** The `tabindex` for the widget. */\n  readonly tabIndex: SignalLike<-1 | 0> = computed(() => this.inputs.cell().widgetTabIndex());\n\n  /** Whether the widget is in an active state (i.e. its containing cell is active). */\n  readonly active: SignalLike<boolean> = computed(() => this.inputs.cell().active());\n\n  constructor(readonly inputs: GridCellWidgetInputs) {\n    this.element = inputs.element;\n  }\n}\n"],"names":[],"mappings":"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"}